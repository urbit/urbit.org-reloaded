<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Urbit</title>
        <link>https://urbit.org</link>
        <description>Urbit is a personal server built from scratch</description>
        <lastBuildDate>Fri, 15 Oct 2021 00:53:19 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[NFTs, Urbit IDs, and Communities w/ Haleek Maul]]></title>
            <link>https://urbit.org/blog/haleek-maul-interview</link>
            <guid>https://urbit.org/blog/haleek-maul-interview</guid>
            <pubDate>Thu, 09 Sep 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/haleek_sigil.jpg)

*Check out the Holdersland x Urbit collection: [holders.land/urbit](https://holders.land/urbit)*

We sat down recently with Haleek Maul to discuss the current state of NFTs and the future of Urbit IDs and digital communities.

Are Urbit IDs NFTs? Sure, they're ERC-721 non-fungible tokens which you can buy on OpenSea—but to be clear, we made them way back before the word "NFT" had entered mainstream consciousness. An Urbit ID is a number that is used to generate both a phonetic name and an avatar (what we call [sigils](https://urbit.org/blog/creating-sigils)), but it is so much more than your average NFT—it is a key to an entire digital world.

We built Urbit IDs for digital communities and the people they’re made of. An Urbit ID is a decentralized and pseudonymous identity perfect for your collective, commune, squad, team, or DAO. Unlike most addresses or social identities, you own your Urbit ID like you own your crypto. Your Discord handle might be free for now, but as the saying goes, if it’s free then you’re the product. On Urbit your ID is actually yours and you pay for it up front. You can log into third party apps or software without ever relinquishing control of your data. What is yours stays with you. IDs themselves can be owned collectively—there are already DAOs on Urbit who jointly own stars and galaxies.

Urbit IDs are evolving and generative. They’re generative because some IDs spawn additional NFTs which themselves can be bought and sold. For instance, each star can spawn 65,535 planets, and each galaxy can spawn 255 stars. The network itself is evolving, meaning that the network can be upgraded via a majority vote by galaxy holders. Urbit IDs and the Ubit network itself are inherently dynamic.

At Urbit, we support communities of all kinds. We recently granted Holdersland ten Urbit IDs: four stars and six planets to be auctioned off. Haleek Maul (his Urbit ID is `~fosmex-hocmel`) will be creating custom artwork for each of the sigils. The proceeds of the auction will help support Holdersland in bringing blockchain technologies to the Caribbean. The auction will go live on September 16th, 2021 on [holders.land/urbit](https://holders.land/urbit).

Without further ado, here’s Haleek Maul.

---

**Tell us a little bit about yourself and Holdersland.**

Sure. My name is Haleek Maul and I’m a multi-disciplinary artist. I was born in America and came to Barbados when I was three years old. I’ve been making music since 2007. I put out my first debut project in 2012 and since then it has been a process of creating art from the stuff flowing through my mind.

Holdersland is a digital extension of my artistic project—a way of creating change in the world around me. When I was younger, there weren’t many artists like me coming from Barbados. I was into a lot of niche electronic and club music and felt alienated from the larger conversation. Holdersland is a way to help creative people in the Caribbean connect with like-minded people around the world, especially using new technologies like blockchain. So I founded Holdersland in 2020 when I left my record label after four years. I felt like music institutions was archaic and didn’t feed into my other artistic practices. I wanted to create an institution that captured the full creative practice—all the way from creating to selling. Most importantly, I wanted to get artists from Barbados and the Caribbean involved in global conversations around art and technology.

**What exactly is Holdersland?**

It’s a company centered around Caribbean intellectual property. We’re trying to help people get connected with new web3 technologies, especially artists. Holdersland is an aggregator that helps connects those who are interested in new technology with those those who actually develop it.

For example, there is a lot of math that underlies music. Part of our project is to extract these mathematical principles and see how they can help generate new forms of art that can be widely distributed. So we’re working to build our own projects and work with users to adopt some of these new technologies. It’s a community of people centered around these values. We plan to implement voting, governance, and incentive structures into the community soon.

**What do you think is the link between your two main interests: music and technology?**

I’ve always been interested in technology. Anyone who has made music in the last twenty years has had to get involved with tech. Especially if you’re a producer. There are many young kids who are downloading music software and messing around with it, and in the process becoming knowledgeable about music production and design. Science and math live right beside art.

I was also into web development when I was a teenager and was very interested in how the internet worked. This led into the work I’m doing with Holdersland. Technology, more often than not, is concerned with collaboration and communication. But in order to develop new technologies we often need to talk about nitty-gritty details. This requires detailed knowledge of particular technologies.

**What is the great hope or promise with new decentralized technologies like blockchain or Urbit?**

They lower the barrier to communication and trade. Especially for countries like Barbados, we don’t have access to the world market. But now with these networks, and assets like NFTs, we can engage in commerce without borders. It allows new entrants to join the market.

It also allows new financial relationships and funding structures to emerge. Rather than have a few people contribute $20k, you can have hundreds of people contribute $100. Once again, this lowers the entry for people to invest is early-stage projects. This changes the way that companies build and ship products.

Brain drain is when skilled workers move abroad for more profitable employment. These new technologies allow native Carribeans to stay where they are while earning money. Using these new technologies, the Carribean can prosper while not losing its unique character and cultural identity. Crypto is permanently going to change the distribution of wealth and culture around the world.

Discord is a fine community solution, but it’s not ideal. There’s an endless array of plugins and dependencies that makes Discord unstable. However, it is a good mixture of an office, a storefront, and a club: I can do my work, sell assets, and just have fun. Communities are important. People naturally want to be in communities, we just need a better solution than Discord. Especially one that’s crypto-native and allows for commerce. Urbit is a one-stop shop that could fill that gap.

**What is the collaboration between Holdersland and Urbit that’s happening this week?**

I’m producing some custom sigil artwork for a set of stars and planets. Both the Urbit assets and artwork will be auctioned off together. The proceeds from the event will go towards creating a community music studio here in Barbados and technology education around the island.

A lot of people here in Barbados don’t even understand what crypto is. A lot of the work being done around this project is to raise awareness about the potentials of this new technology. I want this to be a general springboard for the Caribbean to gain greater technological literacy. That literacy is an important step for lower-income people to drastically change their situation.

**What are you looking forward to talking about on the New World Energy panel at Assembly 2021?**

I want to talk about how to migrate communities onto Urbit. How to use Urbit as a new platform for niche cultures found around the current internet. Also the great strength and power provided by Urbit’s digital identities.

NFTs can be very powerful—there are a lot of possible applications of a unique digital asset. It’s already dissolved geographical boundaries which will help countries to export their intellectual products freely. Countries need first to gain knowledge around these technologies and their economies will follow.

**Thanks for chatting!**

See you at Assembly 2021!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[State of Urbit]]></title>
            <link>https://urbit.org/blog/state-of-urbit</link>
            <guid>https://urbit.org/blog/state-of-urbit</guid>
            <pubDate>Tue, 24 Aug 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/cities-6.jpg)

In the past year, as Urbit has become more reliable and easier to use, we find that we&#39;re spending almost all of our time on the network. We&#39;ve disappeared into the system we&#39;ve been building, and it&#39;s a pleasure to be on Urbit. There&#39;s nowhere else we&#39;d rather be.

If you&#39;re on the network with us you can see the system being built and getting better in real time. Bug fixes and new features appear on your ship constantly. The community is actively planning the future of the system _using the system itself_. At Tlon, we have the unparalleled pleasure of working on the system, _on the system_. This feels great, but for those of you who aren&#39;t on the network, it can look as if we&#39;ve disappeared.

Right now, Urbit is not for my non-technical friends. But everyone can tell that mainstream apps are getting worse and most feel a desire for change. We want Urbit to be as easy to use as a conventional service. Or, at least as easy to use as Signal. And we&#39;re getting pretty close to that.

In this post I&#39;ll cover the progress we&#39;ve made since releasing OS 1 so those who aren&#39;t on the network can get a sense of what we&#39;ve been up to and where we&#39;re going. We&#39;ve built a great communication tool called Landscape, we are improving Urbit&#39;s ease of onboarding, and we&#39;re launching an entire software distribution system. We have a lot of work on our plate.

Okay, let&#39;s talk about where we currently stand and where we&#39;re heading.

**Arc**

Let&#39;s start at the top: we&#39;re working to build a new network and operating system for everyday cloud computing. We think everyone deserves to control and shape the tools they use to communicate and collaborate.

Or, to put it another way: the apps and services we have today are confusing, annoying, and overly complicated. The only way out is to start at the foundation by building a new software stack. Once we have a cloud computing stack that an individual can own and completely control, the old hope that computers can be tools of freedom will return. We haven&#39;t forgotten the original vision of software as a fun, free, flexible everyday tool.

This is a hilariously ambitious thing to try to do, we know. This is what makes it fun. So far, we just try to move step-by-step without overhyping what we&#39;re doing. Building a new platform for networked computing is both a technical and social problem. The technology has to work exceptionally well and the community has to care for it and move it forward.

Our first step was simply to build a prototype, then to refine it into something that could plausibly work. Then, most recently, take that plausible prototype and build a user experience we liked enough to depend on it from day-to-day.

In the last eighteen months we&#39;ve done exactly that. We depend on Urbit day-to-day and have shipped a tool that has become a home for numerous cultures and communities who are invested in moving the system forward. We first called that tool OS 1 but now it&#39;s known as Landscape.

First, let&#39;s talk about the general arc of OS 1 → Landscape, both the successes and challenges. Then we&#39;ll talk about our next step, which is to create an independent and community supported software ecosystem.

**OS 1 → Landscape**

The tools we use shape the way we think. So how could we build better tools with old broken ones? We needed to cut our reliance on old tools that couldn&#39;t care less about how people actually work and live. The only thing they maximized was distraction and dependence. We needed something that was fundamentally private, durable, and flexible. Above all, we needed something that actually belonged to us.

Building Urbit involves a lot of communication and collaboration. In order to move Urbit forward we knew that we needed a place to converse and connect, and we knew that place had to be on Urbit itself. We didn&#39;t need a Slack or a Discord or a Google Drive or a Reddit. We needed all of those things, in one place, that actually belonged to us.

We experimented, built things, threw them away, and then eventually built and [launched OS 1](https://www.youtube.com/watch?v=71ViyftPkGk).

OS 1, now Landscape, is a simple tool for bringing groups together to communicate and stay connected. When a real physical community goes online they immediately become fragmented between various apps. Perhaps a Slack channel coupled with some Notion notebooks and a Telegram channel works for some people. It&#39;s easy to imagine other permutations, and you probably are already in at least two or three. These duct-taped stacks are not only ugly and confusing, but your day to day computing is spread thin and remains in the control of companies—not you.

Urbit is a decentralized network but Landscape is for re-centralizing your communication. Users can form groups which share a set of channels; each channel can be either a chat, a notebook or a collection of links. This means groups can communicate flexibly, exactly how they want. And since Landscape is built on Urbit, each group is private and peer to peer; data is only shared between people in the group; each community on Landscape is completely independent. Communities own their data and last as long as they need to.

This combination of a flexible unified interface on a decentralized platform you can trust feels really good.

When OS 1 was first released, it was slow, buggy, and frustrating—but we loved it and wanted it to be better. We spent the next nine months making sweeping changes to take it from releasable prototype to pretty-nice first version. We rewrote the frontend completely, massively improved the performance of Urbit OS itself, and overhauled the interface. It was an enormous collective effort.

By the end of 2020 we had renamed OS 1 to Landscape and the user experience was far better. We [announced our hosting service](https://www.youtube.com/watch?v=w3qKe_WZr50) and onboarded close friends to help us test the system. I [wrote a little](<[https://tlon.io/news/landscape-now/](https://tlon.io/news/landscape-now/)>) about using Landscape from day-to-day around that time.

Landscape wasn&#39;t just a useful tool for us, but it was something that other communities were starting to use in earnest. It seemed like Landscape could be a great place for people to grow new private communities, so long as we could onboard new users effectively. Hosting is a huge piece of the puzzle, since we need non-technical people to be able to use this wonderful platform as easily as its mainstream competitors.

At this point (early this year), we encountered some pretty serious hurdles.

To use Urbit, you need an Urbit ID. Each one of these is an NFT (something that no one cared about when we first launched Urbit ID). The basic idea is that an ID should cost something so that they aren&#39;t used abusively. But, in late 2020 the combination of a crypto bull market and congestion on the Ethereum network caused the transaction fee for buying an Urbit ID to increase from ~$1-2 to ~$100. An Urbit ID should cost _something_, but \&gt;$100 is too much of a barrier for entry. We knew that this could happen and started researching solutions late last year, ultimately deciding to [implement a solution ourselves](https://urbit.org/blog/rollups/).

The tough part about having an identity verified on the blockchain is that you become vulnerable to unpredictable volatility. We saw a period of painfully high prices, followed by a dip, followed by another stretch of extremely high prices. We opted to continue releasing Landscape updates and moving the system forward despite the fact that it became prohibitively expensive to onboard people. Luckily, our solution to this problem should go live this summer, and will reduce the cost of onboarding about 60x. The best part is that it is a permanent solution so we&#39;ll never have to face this problem again.

The other challenge to scaling the onboarding process is hosting.

We have a functional hosting structure but we want it to be fully automated and featured. We&#39;ve been able to onboard friends and enthusiasts which has taught us a lot about how the system should work. But hosting has to be easy for anyone to join and get online quickly. Without an automated invite flow and it&#39;s not ready for prime time.

We&#39;ve made great progress on this front. We are currently testing improvements internally and aim to have a final version ready simultaneously with lower planet fees. Then, at long last, we can comfortably invite friends to get on the network without ever leaving the browser.

It&#39;s worth mentioning that hosting is very much a Tlon Corporation project. Urbit is a platform owned, maintained, and developed by the people that use it (along with the nascent Urbit Foundation). Tlon, while also contributing to the Urbit project, ultimately wants to produce applications and services on Urbit. Hosting is one of those projects. Hosting makes Urbit easy, approachable, and usable without the compromises involved in using a conventional service. Since we&#39;ll be one of many Urbit-related providers, Tlon won&#39;t be the only host. There are already a few others (like [UrbitHost](https://urbithost.com/)) getting off the ground, which is fantastic.

**Landscape → Grid**

As the world has become more physically distributed we rely on our digital tools to keep our communities connected. The rise of DAOs, collectives, squads, and alternative community governance structures underscores the importance of tools like Landscape that communities can actually own and control.

Our first goal was to find out if we could build something really good on top of Urbit. We did that. And we&#39;re continuing to lower the barrier to entry. We&#39;ve also got an Urbit &#39;messenger&#39; iOS app in the works that&#39;s really nice.

Landscape is great, but in the long run Urbit is meant to be a platform for anyone to build on top of. Urbit is a computer, not just a single communications app like Landscape. The whole point of Urbit is to make it easy for an individual to run their own general-purpose computer in the cloud. Your Urbit isn&#39;t just meant to run Landscape it&#39;s meant to run any sort of application. And that&#39;s where we&#39;re going next.

Grid is a holistic interface for interacting with your Urbit node. Landscape, as it&#39;s known today, will become one of many apps that can be launched. Perhaps most importantly, Grid will have peer-to-peer software distribution over the network. This means you can, as a developer, build something, let a friend sync it over the network, and never have to run a dedicated distribution server. Or, as an everyday user, you can run software on your private Urbit node without the developer ever being involved.

Urbit isn&#39;t an OS in the traditional sense—it&#39;s an &#39;overlay&#39; OS. It has to run on top of something else. But Urbit _is_ an OS in the sense that it&#39;s general-purpose. And our goal in building interfaces for Urbit is to deliver that feeling of openness and flexibility to the user. Grid is a major step toward that goal.

Not only should a community own their communication tools, they should be able to run and host their own cloud software. They shouldn&#39;t need to rely on providers to store their data, run the application, and determine how their digital life will function.

Grid will surely go through the same process that Landscape did. It&#39;ll start as a working first version that will inspire us to refine and make it better. But, unlike Landscape, Grid opens up an entirely new frontier for what can be done on Urbit.

We&#39;re putting together our first conference on Oct 15-17th to inaugurate Urbit as an integrated platform and distribution system for new applications. [Tickets for Assembly 2021 are already available](https://checkout.eventcreate.com/assembly2021/select-buy). Tlon is going to Austin!

**Closing**

Urbit is a deeply optimistic project. Although the digital world seems more broken than ever, we&#39;re confident that something else is possible. We have already created software that people use everyday. We want everyone to have the experience that we do, and we want that experience to continue to get better. Beautiful, reliable infrastructure that communities can build on will have a significant impact on the world. The end game of connected computers doesn&#39;t have to be dystopian.

For those of you who aren&#39;t directly involved with the project, I hope this gives you a snapshot of where we are. If we were on an Antarctic expedition the postcard would read something like &#39;Team is well-fed, healthy and motivated. Making great progress.&#39;

With that, I&#39;ll get back to work.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[An Interview with UrbitHost]]></title>
            <link>https://urbit.org/blog/urbithost-interview</link>
            <guid>https://urbit.org/blog/urbithost-interview</guid>
            <pubDate>Thu, 19 Aug 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/nasa-star-cluster.jpg)

**An Interview with UrbitHost**

Urbit has been making great strides to become accessible to those who are non-technical. Port enables a user to launch their Urbit ID from their personal computer without any knowledge of the command line. However, you only have access while you are running Port, which means you can&#39;t do things like check your DMs while on the move.

Hosting your Urbit means that your Urbit is always on and available. All that is required to access the network is visiting a URL and logging in.That means you can access Urbit from your phone, laptop, or any device with a browser.

The downside is that running your own server can be a complex and difficult process. Third-party hosting allows an expert to do that work for you. The hosting provider gets paid, and you get 24/7 access to your ship.

[UrbitHost](https://urbithost.com) is one of the latest [hosting providers](https://subject.network/planet-sales/) to enter the market. As of now, it is one of the fastest and easiest ways onto the network. You pay the fee, and you get sent a link that you use to access Landscape. It&#39;s that easy.

At least, it&#39;s that easy for the end user. For the guy running the operations, ~lavlyn-litmeg, it can be quite a complex operation. I sat down with him to find out about what it&#39;s like being a commercial developer on Urbit. We also talked about technology, the developer ecosystem, and the future of Urbit.

If you want to get in touch you can reach him at ~lavlyn-litmeg, the ~sardys/uh group, or [urbithost.com](https://urbithost.com).

---

**Tell us a bit about yourself and your history with Urbit?**

I&#39;m a software engineer who is currently working at one of the larger crypto currency companies. My history with Urbit goes back quite a long time. I saw one of those early demos by Curtis where he had two dojos running, sending messages back and forth, and I thought it looked interesting. Since then, I often checked in on the project, but I stayed at the sidelines because it felt not quite ready; there were constant breaches and so on. What kept me close by was that I believed in the vision of Urbit.

I think the open internet only has a future if people retain control of their digital identities, which means that, in addition to a cryptographic identity, they need to be able to keep control over their data. This not only includes their social graph, but they also must be able to run computations on that data. Urbit checks all those boxes. The people behind Urbit and all the other contributors have been steadily marching towards these goals with incredible stamina. I&#39;m inspired by that. And, since the release of OS1, Urbit is very much usable, and I find myself spending more and more time on it instead of other corners of the internet.

**Why did you decide to work on hosting rather than another Urbit project? If you weren&#39;t working on UrbitHost what would you be working on within the Urbit ecosystem?**

I want my non-tech friends to be able to join Urbit. Most people I know can&#39;t be bothered with executing a blockchain transaction, many feel uncomfortable installing an app they don&#39;t understand, and almost all would shy away from the command line. For the vast majority of people, getting onto Urbit must be as easy as signing up for Gmail or Twitter, otherwise they won&#39;t come.

I thought about how I could contribute to Urbit and decided that now is a good time to build a hosting provider. It&#39;s still early, but a non-technical person can actually spend time on the network and be productive. I think we are just now seeing a shift where we need community builders as much as we need engineers working on the internals of Urbit. It is important that those community builders have no barrier to entry for themselves or their communities.

That is why ease of access has been my goal from the beginning. I wanted the site to be fully automated, meaning someone could sign up and be on Urbit within minutes. It was also important to me that users be able to choose their own Urbit ID. As far as I know, there was no offering like that yet, so I decided to build it—but I know that others are working on this too.

If I was working on something else, it would be Urbit apps. We&#39;re waiting for the new release for it to be easier to distribute and access apps; there are a few tools I would really like to see. But other than that, I would like to spend more time community building.

**Can you tell us about how you&#39;re implementing UrbitHost? You beat Tlon to the punch of having immediate hosted access to the Urbit network -- what&#39;re you doing differently? How will your implementation change when programmatic access becomes available via Khan (the new vane to replace Herb)?**

UrbitHost runs on Kubernetes, which is a tool to orchestrate containers. What that means, concretely, is that each ship runs inside a Docker container, and Kubernetes makes sure that each container is running and has enough resources. For example, if a server goes down, Kubernetes will automatically move the ships that were on that server to a new server that is available. No data is lost and there should be very little down-time.

People think Kubernetes should only be used for services that can be scaled horizontally, meaning there are multiple instances running of the same services. Scaling like this is obviously not an option for Urbit, because a ship must only run as a single instance. But in the last few years, Kubernetes has added many features to run single and stable instances of a container, for example a database. UrbitHost is making use of these features—permanent volumes, stateful sets, and so on—to provide a high-availability hosting for Urbit. It also scales well. I surmise, we could host thousands of ships, we would only have to add compute nodes.

As for beating Tlon, I&#39;m not sure if it is a fair comparison. UrbitHost, as it is currently, is a minimal viable product. I tried to realize a simple goal: automated hosting. Tlon is hosting many more planets, not to speak of all the stars and galaxies that make up the network. As far as I can tell, Tlon and UrbitHost are doing things quite similarly. For example, I knew that Tlon is also hosting on Kubernetes, which gave me much more confidence that we could do it too.

UrbitHost&#39;s programmatic interaction with hosted ships is quite minimal once it is booted. We use airlock to retrieve the access code and do a few more maintenance things, and we are using it for some upcoming features like automatic S3 configuration. But from what I can tell, Khan looks like a really important step forward, because interacting with the hosted ships via airlock is one of the most brittle areas, and I&#39;m looking forward to making it more robust once Khan is out.

**What is most needed within the Urbit ecosystem — any particular apps or services? Which projects are you most excited about?**

The ability to publish content directly from a planet to the regular internet would be cool. I would really love to see some bigger blogs being hosted on Urbit. The basic idea would be this: everyone can read the blog, but to join the conversation one would have to join Urbit and the group associated with that blog. Of course, a planet could publish other content too, possibly a mix of free and premium content. Either way, it would pull a lot of people into the gravity well of Urbit.

Publishing could also be a good value proposition for Urbit hosting providers. If public content is hosted on a ship, then all the profit from new customers who are brought to the provider could somehow be split between the host and content producer. What is nice, though, is that a content producer can take his Urbit-native community anywhere, anytime, without disrupting the community much. The portability of Urbit at every level would really shine here as communities grow.

There are incredible projects happening on every front. The Bitcoin integration is very exciting, it is being realized in a truly Urbit-native way and could prove to be a great catalyst for the ecosystem. However, as a hosting provider, the constant lower-level improvements are exciting too.

**What will be the effect of two upcoming changes to Urbit:**

1. **Built in software distribution and management**
2. **Layer 2 and the new &quot;Khan&quot; vane**

**For #1, how would you pitch developers on the benefits of building on Urbit?**

**With regard to #2, I think there is about to be an explosion of hosting providers. Will this unleash an Eternal September effect or does Urbit&#39;s &quot;walled garden&quot; style of communication make it more resilient? Urbit is not a single silo like Facebook, after all.**

I think that once software distribution is as simple and easy as the iOS app store it will be a watershed moment for Urbit. Put bluntly, it will give users something to do on Urbit besides chat. There are several interesting apps out there already, but they are not easy to discover and install.

Developers want reach. The most important pitch to developers will be that on Urbit they have access to a substantial audience. I remember developing for the iPhone in the early days. Objective-C was really a tough pill to swallow, but because the platform was interesting and promised to reach a large audience, I kept going with it. I think Urbit is an interesting platform for the various reasons already mentioned. But learning to develop for Urbit is really a time investment—I myself am still a novice Hoon developer —and for it to be worth it, there has to be a clear pay-off. For some, this is making system-level contributions, but for most it will be having that app show up in some centrally visible place and seeing people engage with it. Once this exists, it will be much easier to pitch Urbit to developers.

The layer 2 solution which will make spawning planets much cheaper is an important next step, especially for hosting providers. Layer 2 will help us immensely because spawning and keying planets is very expensive right now, and it puts a damper on how much we are actively pursuing growth.

If new hosting providers come online, it will not necessarily mean a huge influx of users. In my experience, building a provider is hard and takes time to mature. However, I would love to see fast user growth.

I honestly don&#39;t think having our own Urbit Eternal September would be that bad. I would just see it as growing pains. If we enter a time of sustained growth and rapid user onboarding, the fact that some Urbit groups will get overwhelmed with all the new people will be a small price to pay. The current setup, with a few central groups that act like hubs and discovery points—for example, the fantastic Urbit Index—would have to change. People would need to be funneled into their own Urbit universes that might not overlap much with other areas on Urbit. The nice thing is that all this is accounted for in the Urbit infrastructure.

If a certain hosting provider ends up bringing thousands upon thousands of users to Urbit, like AOL did back then with Usenet, then it will be the provider&#39;s responsibility to onboard those users sensibly and not just dump them on the existing groups. In other words, providers, in my opinion, also have a community building responsibility. Of course, this does not mean that providers should be overbearing parents, allowing only this or that, but simply that they should have sensible defaults that don&#39;t overwhelm or destroy the network.

**What is the role of commercial providers in the open-source ecosystem?**

Commercial providers will be incredibly important to make Urbit succeed. I think if Urbit attracts a large number of users, many, if not most, will run their ship via a hosting provider. It is the easiest way to get started.

However, using a hosting provider to get onto Urbit might at first seem antithetical to the spirit of the project. If someone is trying to get away from mega-corporations, why would they go right back to another company and give them their data?

Well, because it&#39;s a completely different relationship. The relationship between us, the provider, and you, the customer, is transparently straight forward. You are not the product. We have a more traditional provider-customer relationship where we just do the dev ops work. It is in our interest to keep your data private and keep your ship running. We give you an Urbit ID, which you can keep forever, and host your ship as long as you wish. When you want to leave, you can download your pier and Urbit ID and use it with a different provider or on your own computer in minutes. On the other hand, you cannot leave Facebook and run your profile off of your laptop. Basically, we cannot count on customer lock-in, we must provide good and honest service. Again, the portability promise of Urbit is essential here and ensures that we are on an equal footing.

**Once the Urbit payment ecosystem gets built out more, would you consider accepting payments over the Urbit network?**

Of course. Having an Urbit-native economy would be a key marker of success, and I would love to participate in it. Moreover, we are planning to offer a Bitcoin node to our customers soon.

**Are you coming to Assembly 2021?**

Yes. At least, I&#39;m planning to! I would love to meet all the people behind Urbit in real life.

**I know you are a Christopher Alexander fan, how has he influenced your work?**

I&#39;ve been interested in Christopher Alexander for quite a long time. When I realized that many of the people building Urbit are also inspired by him, I understood why much of the Urbit vibe resonated with me. Critics of Urbit either focus on the technical details or on Curtis Yarvin&#39;s writings, sometimes conflating the two. That&#39;s fine and perhaps a valid point to start, but what they don&#39;t understand is that so many other ideas and ideals have since become driving forces behind the project. This is at least what I observe as an outsider.

Alexander&#39;s ideas are all about how to build beautiful houses. He wants us to inhabit places that feel life-giving, places that make us more fully human. The same should be asked of the technology we use. So much of the current internet is the equivalent of a fluorescent-lit cubicle, a brutalist government building, or a flashy central square. It might be interesting to travel through these places, but they do not make good homes.

To explore what makes a building beautiful, Alexander had to wade into metaphysics, because he wanted to give a much more objective account of how beauty is present in physical artifacts, which led him to treat beauty as a universal. I think to build more meaningful technology we need to do the same. We do not have a good metaphysics of technology, and this is something I&#39;m really interested in.

**Give me a brief summary about your personal philosophy of technology. Do all tools fall under the umbrella of &quot;technology&quot;? Or do some tools hit an inflection point where they acquire radically different characteristics (compare a shovel and a computer)? It seems to me that the philosophy of technology often boils down to trying to define what &quot;technology&quot; actually is. What do you make of all this?**

Yeah, I definitely think there is an inflection point once technology becomes digital, but I believe there is something all technology has in common. My approach here is classical. Artifacts have to be distinguished from living things because human made things have their origin outside themselves, meaning they are manufactured (in Aristotelian terms, and stated somewhat simplistically, artifacts have an efficient cause outside themselves, whereas biological things have an innate efficient cause). We are often tempted to think of living organisms simply as elaborate self-replicating machines, but that is putting the cart before the horse. We should rather look to the world of living things to be inspired to build our artifacts.

The question of inspiration becomes even more pressing when discussing modern technology, and you put your finger on it with the inflection point. There is no tradition to fall back on when we are building digital technologies. Someone like Christopher Alexander, who is working on architecture, has thousands of years of architecture to look at. He can read the past and see what worked and what did not. On the other hand, when we build things like Urbit, we must look for inspiration in other places because there is no corpus of, say, thousands of years of constructing digital social networks where we can simply choose the best parts. So far, we have mostly bad examples, how not to do it. And considering how new the internet is, most of it is still a blank slate. So while I&#39;m definitely interested in the ontology of technology, I think it is an even more pressing question to learn the principles of the living world around us in order to build digital places that feel organic and life-giving.

**Thanks for chatting!**

See you on the network!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[On Christopher Alexander]]></title>
            <link>https://urbit.org/blog/on-christopher-alexander</link>
            <guid>https://urbit.org/blog/on-christopher-alexander</guid>
            <pubDate>Mon, 19 Jul 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/timelesswaybridge.png)

_A well-designed house not only fits its context well but also illuminates the problem of just what the context is, and thereby clarifies the life which it accommodates — Notes on the Synthesis of Form_

There is an unofficial design canon at Urbit. If you were a fly on the wall, you would hear the name &quot;Christopher Alexander&quot; regularly mentioned around the office. Christopher Alexander is an architect, albeit one who isn&#39;t taught at most architecture schools. However, his work encompasses far more than what is usually understood as &quot;architecture&quot;. Alexander&#39;s work is concerned with the production of functional beauty. What&#39;s remarkable about his books is that they are not empty philosophical manifestos—Alexander gives specific, actionable guidance on creative problems. His best books are manuals for how to construct forms that are &quot;alive&quot;. Alexander threads the needle between highly specific instruction and generalized abstract concepts—his success at this task can be seen in his influence on fields outside of architecture, from computer science to network theory. In his most recent work, Alexander touches upon subjects ranging from religion to math and connects it all into a theory about how the universe functions. But people read him for less lofty reasons: to build a house that is beautiful, design a comprehensive programming language, or figure out how to approach a complex problem. In this post, I&#39;ll give an overview of Alexander&#39;s work and hear from some Urbit staff about his relevance to software development.

Alexander&#39;s first book, _Notes on the Synthesis of Form,_ detailed a new way to approach the design process. Released in 1962, it incorporated networks, set theory, language, and math into a new method for accurately modeling and solving design problems. Although Alexander was an architect, the book was concerned with fundamental issues: how do you solve complex problems with hundreds of interconnected variables? The answer lies in decomposing the problem into subsystems and then &quot;diagramming&quot; those subsystems back into a singular integrated form. The process of decomposing a set into [highly-interconnected subsets](https://en.wikipedia.org/wiki/Community_structure) involves a significant amount of computation—Alexander wrote a computer program for the IBM 7090 mainframe which was described in his 1962 paper _HIDECS 2: A Computer Program for the Hierarchical Decomposition of a Set with an Associated Graph._ But this was only half of his design process; after the creation of subsets which are the fundamental units of the design problem, the subsets must be diagrammed. This second half of the process involves integrating and synthesizing all of the variables within a single subset into a conceptual diagram. These fundamental diagrams are then integrated and combined _themselves_ into a single diagram which is the final result of the process. The diagram below is Alexander&#39;s solution to the problem of designing a village in India with a huge number of variables and constraints.

![](https://media.urbit.org/site/posts/essays/villagediagram.png)

_Notes on the Synthesis of Form_ can be seen as embodying many of the tensions in 1960s America. Computers were seen as a suspicious technology which embodied the institutionalized science that created the nuclear bomb and cold war era tensions. These suspicions were understandable: computers were massive esoteric machines housed in entire rooms of university and government buildings. They were physically and mentally inaccessible to the average American citizen, while the elites who did use them were held in contempt by the populace. Student protests against being just another cog in &quot;the machine&quot; or &quot;IBM card&quot; were partly right—at this point in the early 60s, many intellectuals were interested in [cybernetics](https://en.wikipedia.org/wiki/Cybernetics:_Or_Control_and_Communication_in_the_Animal_and_the_Machine) and the [mathematical modeling of &quot;human&quot; problems](https://en.wikipedia.org/wiki/Theory_of_Games_and_Economic_Behavior) and Alexander drew from these fields frequently in his book. However, when _Notes on the Synthesis of Form_ came out in 1964 computer culture was shifting towards an alliance with the counterculture—a cultural and technological process that would culminate with these massive pieces of institutional technology becoming &quot;personal computers&quot;. He criticized those who wished to keep math and computers away from human creativity: he saw the possibility of computers yoked to creative human beings. He believed this symbiotic approach to technology was necessary—without a new approach to design, the world would continueto produce the ugliness endemic since the industrial revolution. According to Alexander, a designer could only successfully solve this problem by combining his creativity with the analytic and computational power of machines. Through his books and [presentations](https://www.youtube.com/watch?v=98LdFA-_zfA), Alexander would have a lasting impact on object-oriented programming and [pattern based thinking in software design](https://en.wikipedia.org/wiki/Design_Patterns).

In _Notes on_ _the Synthesis of Form_ Alexander applauds the buildings and towns of many primitive societies but he notes that there is no hope of a return to this &quot;unselfconscious&quot; state. Therefore, modern people must develop a new design process to reach the same end. But what is this end that Alexander is trying to achieve? Alexander states his aim negatively in _Notes on the Synthesis of Form_ as &quot;the absence of misfits between a form and its context&quot;. An [apophatic](https://en.wikipedia.org/wiki/Apophasis) statement might be good enough for mystics but, for someone like Alexander who was concerned with precision, a positive statement was necessary. His positive statement wouldn&#39;t come until 1979 with the publication of _A Timeless Way of Building_.

In 1975, Alexander would begin publishing his most famous book series which included _The Timeless Way of Building_ and _A Pattern Language_. In these works Alexander took a more holistic approach to creative production and placed less emphasis on design models. This new approach cemented the importance of culture as the substrate that supports a people&#39;s inherited &quot;pattern language&quot;. Just like a spoken language, a pattern language is developed incrementally over time by people who adapt to the same local environment. Alexander wrote that &quot;a pattern language gives each person who uses it, the power to create an infinite variety of new and unique buildings, just as his ordinary language gives him the power to create an infinite variety of sentences&quot;. _A Pattern Language_ is an attempt to create a new language from observing the dialects of buildings around the world. Alexander recognized that there were large-scale patterns between people and the buildings they found beautiful—a productive tension between specificity and more general patterns common to all human beings. Alexander&#39;s pattern language is therefore more general than historically generated languages. The &quot;pattern language&quot; approach is now native to many software developers: seeing solutions as complexes of layered and interconnected systems.

_A Pattern Language_ is the book that is closest to an instruction manual. It is meant to take the prospective builder all the way through the process of designing and constructing a building, neighborhood, or city. Alexander writes about the macro-patterns of cities and the micro-patterns of buildings, from road design to doorknobs. Alexander wanted to enumerate patterns that interlock and produce beauty at different scales while still being as precise and actionable as possible. In _Notes on the Synthesis of Form_, Alexander was concerned with how to best model reality in order to solve a problem, while _A Pattern Language_ focused on the production of a vernacular that would allow people to produce beautiful buildings.

![](https://media.urbit.org/site/posts/essays/patternlanguageexamples.png)

Underlying these different pattern languages is a deep, precise, and objective appreciation of an important quality of human existence—what Alexander calls &quot;the quality without a name&quot;. This &quot;quality&quot; is the ultimate goal of Alexander&#39;s work. Greater efficiency and instrumentality cannot be ends in themselves. For Alexander, it is a moral imperative to save the world from ugliness and to make human culture match the natural world in beauty, complexity, and aliveness. It is described in _The Timeless Way of Building_ as &quot;the root criterion of life and spirit in a man, a town, a building, or a wilderness. This quality is objective and precise, but it cannot be named&quot;. The &quot;quality&quot; cannot be named not because it is a vague or airy concept, but because &quot;the quality is too particular, and words too broad&quot;. Nevertheless, Alexander makes an attempt to circumscribe the concept with the words alive, whole, comfortable, free, exact, egoless, eternal.

Alexander would say that a Japanese temple and a German church are both approaching the &quot;quality&quot; from different histories and cultures. They are examples of two vernacular languages developing in parallel. The similarity between two modern cities is an example of how we&#39;ve been severed from our pattern languages and therefore the &quot;quality&quot;; we are forced to design from barren earth. Global homogeneity is a symptom of disconnect from both temporal and spatial order—it is the death of our inherited languages.

![](https://media.urbit.org/site/posts/essays/timelesswayexamples.png)

_The Nature of Order_ is Alexander&#39;s most recent book series and explores the metaphysical implications of Alexander&#39;s thought. According to Alexander, the failure of the modern built world is because we have learned to view the world as fundamentally dead. Alexander makes an argument that is close to [hylozoism](https://en.wikipedia.org/wiki/Hylozoism) or [IIT](https://en.wikipedia.org/wiki/Integrated_information_theory): all structures have varying amounts of aliveness (an aspect of the &quot;quality&quot;). Because of the modern worldview that sees all structure as dead we have become blind to this deeper aspect. The basic component which makes structures alive are strong and varied centers. Furthermore there are fifteen fundamental attributes of centers which allow them to network and become alive. These fifteen abstract units are what patterns are composed of—patterns that are then woven into languages (this process of formalizing implementations as higher-level abstractions should be familiar to any computer scientist). _The Nature of Order_ is the most philosophical and [spiritual](https://www.firstthings.com/article/2016/02/making-the-garden) of Alexander&#39;s work and ties together his overarching preoccupations: how to solve complex human problems and why the task of making the world beautiful is important.

You might be wondering how Christopher Alexander is relevant to Urbit?

That depends on who you ask.

**Galen (~ravmel-ropdyl)**

> I suppose the main thing is that most designers tend to become fixated on the mechanics of what they&#39;re building. Most design theory is about how things are made, not what it&#39;s like to live inside of them or actually rely on them on a daily basis. Alexander is much more concerned with the first-person experience of inhabiting a place or a building. I guess his approach is just much more empathetic which means it&#39;s also more practical. He&#39;s concerned with _how people actually live_ and how their environment evolves alongside them.
>
> We live, work, and develop on Urbit. We&#39;re often the first people to notice bugs because we are the end users ourselves. Alexander makes the point that old buildings were responsive to feedback because the architect was also the inhabitant. This tight feedback means that the system as a whole is dynamic and alive. We want Urbit to be a house that you live in and make yours, because unlike all the other software you use, your Urbit is actually _yours_.

**Josh (~wolref-podlex)**

> _The Nature of Order_ has had a big influence on my thinking. At first, the idea of all physical structures being alive sounded like something out of a new age bookstore. But not only do I think that Alexander justifies this claim; it started to make intuitive sense when I looked closely at my experience.
>
> When I first read _The Nature of Order_ I was living in an industrial neighborhood of San Francisco—the scale of the buildings and streets felt inhuman and everything was made of metal, glass, and concrete. I chose to leave. I moved into a 100+ year-old flat and the difference was immediate and visceral. The space felt like it was designed from experience rather than _ex nihilo_. The apartment was meant to be lived in, surrounded by public spaces where strangers could safely spend time outdoors together.
>
> If physical objects can have the quality of &quot;aliveness&quot; so too can information objects. Alexander&#39;s book is alive. Many of the software projects I&#39;ve worked on have been cold fish. Keeping this quality in mind is an important part of my decision making. I want Urbit to be a living structure.

**Édouard (~fabled-faster)**

> I enjoy telling people unfamiliar with Urbit and interface design with respect to Urbit, that the object of our work is essentially that of designing an environment &quot;like a piece of paper&quot;.
>
> Consider how paper as a constrained environment is one that yet can bear nearly any visual expression imaginable—apart from containing drawings or human-made marks, paper can be used to display photographs, paper can be multiplexed to form lenticular holograms, paper can be folded into a crane, etc.
>
> The &quot;sheet of paper and its resulting forms&quot; I manifest as a design ideal here is what Alexander might refer to as a &quot;semilattice&quot;. A mathematical term he co-opted to describe an ideal structural relationship between elements in a system, as opposed to a &quot;tree&quot;, which is a top-down structural system that forces elements into rigid categorical constraints. [In his own words](https://www.patternlanguage.com/archive/cityisnotatree.html):
>
> > _For the human mind, the tree is the easiest vehicle for complex thoughts. But the city is not, cannot and must not be a tree. The city is a receptacle for life. If the receptacle severs the overlap of the strands of life within it, because it is a tree, it will be like a bowl full of razor blades on edge, ready to cut up whatever is entrusted to it. In such a receptacle life will be cut to pieces. If we make cities which are trees, they will cut our life within to pieces._
>
> A city is a good ideal to maintain for the construction of a new internet and notion of personal computing, but I&#39;ve tended towards my own interpretation of a piece of paper as a semilattice-embodying object due to its accessibility and ability to be imagined by anyone, designer or not. Our object of design is that of a receptacle of life, of deep expression, of multiplexed possibilities. When I imagine an Urbit in the not-so-distant future, I imagine it as a _method_ (to contrast against those who pin software&#39;s expression down to &quot;tools&quot; or &quot;functions&quot;) by which I can become &quot;whole&quot; again in a digital context, in all my complexity.

Christopher Alexander wanted to collapse the distinction between those who live in buildings and those who design them. Urbit wants to do the same thing with software—in order to not produce ugliness, we should live in what we build. Although we have personal computers now, all of our data is housed in enormous warehouses that make the industrial computers of the 1950s look tiny. What we think of as “our information” actually belongs to someone else and, more often than not, is weaponized against us. Alexander’s moral imperative can be taken and applied to our digital structures. We need to become close with our software again.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from urbit.org]]></title>
            <link>https://urbit.org/updates/2021-06-16-update</link>
            <guid>https://urbit.org/updates/2021-06-16-update</guid>
            <pubDate>Tue, 15 Jun 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Howdy!

It’s time for the June edition of the Urbit newsletter. You might have noticed that Urbit messages are being sent quicker, bitcoin wallets are flourishing, and that the network is rapidly picking up momentum in terms of users and communities. Urbit, now more than ever, is starting to feel like an organic self-sustaining ecosystem. It’s a good time to be here.

0 – Upcoming Events

Assembly: An Urbit Conference
Early October(ish) @ Austin TX
We’re busy putting together Urbit’s first IRL conference. We’ll let this email list know as soon as tickets become available.

Developer Call: Programming Bitcoin on Urbit @ Thu Jun 17, 2021 9am – 10am PDT
Tim (~timluc-miptev) will be leading an open workshop on programming bitcoin on Urbit. Come join the call to learn about this integration—all are welcome! (https://www.youtube.com/watch?v=ltKz1MmluEY)

1 – Technical Updates

~tacryt-socryp has made a major performance improvement—sending and receiving messages are now 79% faster! He accomplished this by cutting down the time spent processing messages in arvo and he did it all despite being a newlywed. Big thanks to him!

2 – The Urbit Town Hall Event

Most of the big news this month was featured in our first ever Town Hall event, which was a big success. If you missed it, you can watch it here (https://www.youtube.com/watch?v=8YSwt0vDPj0). Here’s a quick recap of Josh’s “State of the Network” address:

- The event started off with an animation produced by ~rivpyl-sidfyl with a script by ~minder-folden (https://www.youtube.com/watch?v=UvsOGz-hM-o). This work was commissioned via our grant program (https://urbit.org/grants/proposals/urbit-explainer-video/). Urbit grants are predominately technical but if you have artistic chops we would be interested in hearing from you.

- The grant program has been successfully churning out projects with 36 contributors in the last six months and 42 grants which are currently active. There is also a new class of grants called “apprenticeships” where a junior Urbit developer gets paired with an experienced Urbit developer to work on a project (while getting paid). Sign up before spots are gone (https://urbit.org/grants/apprenticeships/).

- Post-facto gifts were made to Urbit’s community members for exceptional contributions: ~nodreb-borrus, ~tocrex-holpen, ~habsul-rignyr, ~libhut-samwes, ~litmus-ritten, ~locpyl-tidnyd, ~sitful-hatred, ~sigryn-habrex, ~mocrux-nomdep, and ~tapruc-solwer.

- The Bitcoin Wallet application was rolled out to the network (see below).

The next two sections of the town hall featured Hunter Miller presenting on Port (see below), and Justin Murphy discussing the role of teleology in Urbit’s success. There were also some great lightning talks at the end, although they were unfortunately not recorded—you had to be there!

3 – Port (previously known as Taisho)

An important goal for Urbit has been accessibility and now, thanks to Port, it’s easier than ever to get onto the Urbit network. Port lets you boot a planet, star, or even galaxy without ever touching a terminal. If you haven’t noticed, our homepage is now prominently featuring this development. The official urbit.exe is just around the corner but get your Mac friends to boot a comet! Thanks to Urbit contributor Hunter Miller for this important achievement! (https://github.com/arthyn/port)

4 – Bitcoin Wallet

You can now send bitcoin over Urbit just by using a ship’s name—it’s that easy. The official documentation is still in the works, but ~sitful-hatred has already produced this easy guide to getting started (https://subject.network/posts/btc-wallet-config/).

5 – Gurgle.io

A new website has been causing a stir in the Urbit community. Gurgle.io is an index of the public Urbit network. If a group is public it can be crawled via a comet/planet that acts as a listener. Many Urbit users have expressed discomfort as they were not asked permission before being indexed. The developers of the project have recently decided to cease operation of the project (https://twitter.com/gurgle_io/status/1404649313020514310).

6 – Blog

~sitful-hatred has a post on the relationship between %graph-store and hypertext where he traces the historical relevance of linkages and networks. Fascinating stuff! (https://urbit.org/blog/a-topiary/)

There are two new posts from Poprox (~datnut-pollen), one on how the Urbit team is solving the problem of expensive gas prices (https://urbit.org/blog/rollups/), and the other was co-authored with Mark (~palfun-foslup) on the recent upgrade to Azimuth contracts (https://urbit.org/blog/first-contract/).

7 – New Addition to the Team

Me myself, Matt (~tirwyd-sarmes), am joining the Urbit Foundation to help with content. Please get in touch if you want to write or produce something for the blog or website (matt@urbit.org).

8 – Odds and Ends

~sipsen-pilser has released ~home-urbit, a one-stop shop for getting Urbit up and running on a home system (https://github.com/OdysLam/home-urbit).

Jake Miller (~littel-wolfur) has successfully migrated his parents and fiancée onto Urbit. Click here for an Urbit-exclusive peek into the family life of the Millers. Hi Mr. and Mrs. Miller! (https://bit.ly/35qugfK)(https://bit.ly/3wt2ZFm)

Thanks for reading. More updates next month!

Matt (~tirwyd-sarmes)

https://twitter.com/urbit
https://github.com/urbit/urbit
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A Topiary: Hypertext and Urbit]]></title>
            <link>https://urbit.org/blog/a-topiary</link>
            <guid>https://urbit.org/blog/a-topiary</guid>
            <pubDate>Sun, 13 Jun 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/treebranches.jpeg)

> Under the trees of England I meditated on this lost and perhaps mythical labyrinth. I imagined it untouched and perfect on the secret summit of some mountain; I imagined it drowned under rice paddies or beneath the sea; I imagined it infinite, made not only of eight-sided pavilions and of twisting paths but also of rivers, provinces and kingdoms... I thought of a maze of mazes, of a sinuous, ever growing maze which would take in both past and future and would somehow involve the stars.

-- _The Garden of Forking Paths_, Jorge Luis Borges

The pre-technological world was already [networked](https://en.wikipedia.org/wiki/Indra%27s_net). No material object and no idea has ever stood alone—"no man is an island". Language itself is a network of associations shared between a group of people. The question of technology is: how do we bring our web of associations into the realm of computers? The legacy internet has focused on social networks almost exclusively—our mammalian brains readily took to this, we all love to [signal](https://conversationswithtyler.com/episodes/robin-hanson/). But before “social media” there was something called hypertext: a seemingly modest way to connect documents shared between computers.

A footnote in a book used to require a library, locating the referenced book, and finding the cited page (which might have footnotes itself)! Hypertext allows one to traverse a network quickly and easily with just mouse clicks, making information accessible to those without the time and resources to hunt down physical artifacts. Urbit’s “%graph-store” is not the same as hypertext but it does bear some familial resemblances. Fundamentally, %graph-store is a data structure that can accommodate disparate data types within a single edifice. It is based on [graph databases](https://en.wikipedia.org/wiki/Graph_database) and recent implementations such as [GraphQL](https://graphql.org/). To understand this data structure it is worth diving into the origins of hypertext—the original linked network.

The story of hypertext begins at the end of WWII with an article in _The Atlantic_ that proposed to extend the human mind via machine. Vannevar Bush had seen first-hand the explosion of electronics manufacturing and scientific knowledge, recognizing the great peril and opportunity of such a revolution. His [description](https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/) of the Memex presaged the technological world of today, envisioning a personal device that would allow the user to draw upon a vast library of information, and link documents together arbitrarily—what he called "associative indexing"—a deliberate recreation of how the mind connects thoughts.

The 1960s saw the first implementations of these ideas. Ted Nelson's [writing](https://archive.org/details/SelectedPapers1977/page/n15/mode/2up) around _Project Xanadu_ elaborated this linking between documents into what Nelson called _hypertext_. Nelson imagined "a text arranged in a graph structure", centered around a corpus arranged in nonlinear sequence, manipulable by author or audience. The concept was first demonstrated in 1968, at Douglas Engelbart's 'Mother of all Demos', where a vision of computers as a collaborative social environment was revealed to the world. "[The Journal](https://www.dougengelbart.org/content/view/137/#7)", presented alongside other revolutionary demos, exhibited collaboratively edited documents with hyperlinked connections. Any time-travellers in the audience would have immediately recognized the first webpage. From here, the idea of a linked network of documents would be developed through successive phases of computing, from the mainframe to the PC.

Experimentation with these ideas continued through the 1970s and 80s. A team directed by Andy Lippman at MIT extended the concept to threaded visual hypermedia with the _Aspen Movie Map_, a user-directed virtual tour of Aspen, Colorado. Hypertext and hypermedia gained a mass audience for the first time with HyperCard, a program that shipped with Mac computers. Users were able to collect or create '[stacks](https://archive.org/details/hypercardstacks)' of interlinked cards; a personal body of text, art, and knowledge could be accrued and modified, or shared with others—though not yet with native networking capabilities.

With the World Wide Web, hypertext achieved escape velocity. Initially a one-man [project](http://info.cern.ch/hypertext/WWW/TheProject.html), the world wide web was similar to Bush’s vision of the Memex—a way to share, index, and connect information between individuals and groups. The web succeeded by utilizing the physical infrastructure already available: PCs with graphical interfaces, DNS, and the internet. Critically, its method of transmitting and traversing texts was a standardized protocol, allowing a free body of information to assemble atop the new infrastructure by anyone willing to learn the tools. A new frontier was cleared and cultivated with open standards, but it would gradually face enclosure.

In the following decade, after the first wave of social networking sites had crested but before phones became the primary web clients, Twitter was launched. Originally an awkward bridge between SMS and the web, its design eventually coalesced around static identity, posts with chronological sorting, and interlinked post threads. These simple primitives spawned a vast corpus of information, a graph-of-graphs intertwined and overlapped, mapping an entire platonic world. Twitter is fundamentally constrained by its very nature: it is the walled garden of an advertising company. The financial incentives of the server operators demanded seizure of the commons and the replacement of standardized protocols with proprietary databases.

As the first networked services withered, a new critique was implicitly articulated in the construction of a [new kind of abstract machine](https://moronlab.blogspot.com/2010/01/urbit-functional-programming-from.html). Urbit learned from the past: tightly defined protocols, baked-in cryptography, and decentralization were key. If power over the network was determined by those who ran the servers, then we would run the servers ourselves.

Urbit is not fundamentally a hypertext system; it is a new kind of computer, designed to participate in a peer-to-peer network that rejects the client-server model. All Urbit software takes its networking model for granted, it is not an ad-hoc layering of mismatched abstractions. Fundamental design decisions determine the trajectory of the future.

Early [implementations](https://en.wikipedia.org/wiki/Neo4j) of graph databases and projects like [RDF](https://en.wikipedia.org/wiki/Resource_Description_Framework) hit on the same core idea: linked data needs its own data structure. In 2020 Urbit OS adopted an application called %graph-store that made use of a new, native [data structure](https://docs.google.com/document/d/1-Gwfg442kV3cdfG7NnWPEf2TMa3uLUTAKkZD70ALZkE/edit) which would act as a database service for social applications. Chats, long-form text, and other types of data produced in the course of social computing now share the same tent, a single structure extensible to new types of content. Each item added to it is a node in a personal graph—a tree that grows branches as your computer communicates. These nodes can be linked arbitrarily to other graphs—Urbit's global immutable namespace grants both permanence and ownership and allows the graph’s branches to intertwine with others. Graphs can accommodate a variety of content, from simple text, to code and media yet to be conceived. You own your graph, and it is a record of your digital journey with others.

Personal hypertext graphs are leaving behind proprietary platforms and gaining independence. Graphs until now have been used as tools of surveillance and marketing, but they are being reclaimed and sewn back into the network, each bound to the cryptographic identity of an individual, permanent computer. Where the map of your life was once splintered across a thousand systems and held in the custody of strangers, it is now possessed only by you and shared only as you see fit. On Urbit, an infinite forest of digital lives can take root, nesting their boughs and stalks.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Azimuth’s First Contract Upgrade]]></title>
            <link>https://urbit.org/blog/first-contract</link>
            <guid>https://urbit.org/blog/first-contract</guid>
            <pubDate>Fri, 04 Jun 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![milestone](https://media.urbit.org/site/posts/essays/land3.jpg)

<br>

Recently, the [first upgrade](https://github.com/urbit/azimuth/pull/35) to the
[Azimuth](/docs/glossary/azimuth) smart contracts which make up Urbit ID was
put up to an [upgrade proposal vote](/docs/glossary/upgrade) by the
[Galactic Senate](/docs/glossary/senate). This vote is still open and will
last for 30 days (June 20th) or until an absolute majority is reached. We’d like
to take this opportunity to discuss two things. [First](#changelist), what the
proposed changes are, and [second](#senate), a review of how Urbit governance
works and where we’re at in the decentralization process.

Before we dive into what the proposed changes are, let’s review what the Senate
is actually capable of changing. Urbit ID is really two sets of smart contracts:
Azimuth and [Ecliptic](/docs/glossary/ecliptic). Azimuth is the data of the
public key infrastructure - roughly, this is the list of
[ships](/docs/glossary/ship) and which Ethereum addresses own them, along
with other data such as networking keys and sponsorship status. The Senate has
no ability to touch this data directly. This is in direct contrast to all
existing centralized services, where your account is always at risk of being
taken away from you. What the Senate can change is Ecliptic, which is the
“business logic” that decides how you can interact with the data in Azimuth.
These are mechanisms such as what powers various
[proxies](/docs/glossary/proxies) have, how stars/planets are released over
time, and how sponsorship works. Put another way, the data and database format
must remain the same, but the rules by which we interact with it may change
according to the governance rules we [detail below](#senate).

## Changelist {#changelist}

The Galactic Senate is voting on the following changes to Ecliptic:

- Fixed ERC721 compatibility
- Self-modifying proxies
- Upgraded Claims contract

### Fixed ERC721 compatibility

In Ecliptic, the contract includes various functions and events
that make it conform to the ERC721 (non-fungible token) standard. However, two
events have [ever so slightly
non-confirming](https://github.com/urbit/azimuth/issues/8) descriptions. This
causes Ethereum explorers like Etherscan to incorrectly recognize Azimuth as
ERC20 (fungible token), rather than ERC721.

The proposed change simply modifies the event descriptions to accurately match
the ERC721 definition. This does not affect any functionality within the
contract itself.

### Self-modifying proxies

Owners of Azimuth assets are allowed to configure "proxy addresses" for those
assets: Ethereum addresses allowed to act "as" the owner, but only for a subset
of operations. For example, setting the management proxy will let you change
your networking keys and sponsor using that address, just like your ownership
address can. This is useful for keeping the ownership keys in very cold storage
while still letting you perform lower-value operations.

Currently, only the ownership address is allowed to change proxy addresses.
Fairly early on after Azimuth's deployment, we realized it might be nice for
proxies to be able to change themselves.

This means that, in addition to being able to configure networking keys and
sponsorship, your management proxy would be able to assign a new management
proxy. This would allow you, or a trusted third party holding your management proxy,
to rotate your proxy keys without needing to take your ownership keys out of cold
storage.

### Upgraded Claims contract

[The Claims
contract](https://github.com/urbit/azimuth/blob/master/contracts/Claims.sol)
lets asset managers associate various "claims" with their identity. For
example, an Ethereum address to send donations to, or proving ownership of a
Twitter account.

For ease of use by off-chain tools and services, the contract emits events
(notifications) whenever any claims are updated. However, the current version of
the contract has a bug where it does not emit events when all claims are removed
at once (clearClaims()). This "gap" in the event stream makes it much more
difficult to write off-chain tools around this contract. Considering Claims has
seen [practically no
use](https://etherscan.io/address/0xe7e7f69b34d7d9bd8d61fb22c33b22708947971a#events)
since it was first deployed, it should not be a problem to simply start over
fresh with a new contract that contains [the
fix](https://github.com/urbit/azimuth/pull/32) for the described bug.

The reason we must do an Ecliptic upgrade to switch to a new Claims contract, is
that it is tied in with the logic for transferring an asset. If an asset is
flagged for "reset" (common when transferring to/from someone other than
yourself), its configured proxies, networking keys and claims are cleared during
transfer. As such, Ecliptic will need to know about the address of the new
Claims contract.

## Urbit Governance {#senate}

![geology](https://media.urbit.org/site/posts/essays/b1.jpg)

The ultimate goal of Urbit is to become a digital republic manifested as a peer
to peer network owned and controlled by its users. The goal of Tlon, then, is to
become one of many companies who build products for Urbit rather than being the primary
driving force behind its development. We’d like to take this opportunity to
spell out our perspective on where we’re at in that process. Here are some previous posts that are relevant, but please note that
some of them are several years old and as such may not accurately reflect our
current position, but still serve as useful historical markers. We hope to
revisit and refresh these documents soon.

- [2016.5.16 - Interim
  Constitution](/blog/interim-constitution)
- [2016.5.16 - The
  Urbit Address Space](/blog/the-urbit-address-space)
- [2016.6.24 - The DAO as a Lesson in Decentralized
  Governance](/blog/the-dao-as-a-lesson-in-decentralized-governance)
- [2019.1.11 - Governance of
  urbit.org](/blog/governance-of-urbit)

### Galactic Senate

The Galactic Senate is composed of all [galaxy](/docs/glossary/galaxy)
holders, which at present consists of more than 100 individuals and a few
organizations, including Tlon and the Urbit Foundation. Using the Azimuth
voting contract, the Senate can present and vote on two kinds of proposals:
[document proposals](/docs/glossary/docvote) and [upgrade
proposals](/docs/glossary/upgrade). Thus far, all matters which the Senate
has voted on have been document proposals. The [most recent
vote](https://github.com/urbit/azimuth/pull/34) declared the Urbit network as
(i) being secure (as confirmed by a [third party
audit](/blog/security-audit)) and (ii) having reached continuity (as in, no
further [network breaches](/docs/glossary/breach) are expected). Previous votes
were to declare that [Azimuth is live](https://github.com/urbit/azimuth/pull/25)
and that [Arvo is stable](https://github.com/urbit/azimuth/pull/24).

### Address space distribution

Perhaps the most informative measure of how decentralized Urbit is in terms of
how many independent parties hold address space. By the very nature of Urbit, it
is impossible to know this with great accuracy (a common feature of
decentralized projects). However, the movement of galaxies is closely watched
and thus we have a fairly good idea of how distributed they are.

In the beginning, Urbit’s creator Curtis Yarvin was in possession of the entire
address space - all 256 galaxies, and everything underneath it. A network of one
is no network at all, and so over the last decade Urbit’s development has been
primarily driven by selling or giving away these galaxies. On [June 1,
2016](/blog/the-urbit-address-space), the allocation was:

> 95, to the Tlon Corporation. 50, to urbit.org, the future community
> foundation. 40, to Tlon employees and their family members (24 to Curtis, who
> started in 2002; 16 to everyone else, who started in 2014). 34, to outside
> investors in Tlon. 37, to 33 other individuals, who donated to the project,
> contributed code or services, won a contest, or were just in the right place
> at the right time.

Since then, Tlon has sold a number of
its galaxies to fund development and others have changed hands to the point
that Tlon and urbit.org no longer possess a majority share of galaxies. In
January 2019, [Curtis gave all of his galaxies](/blog/a-founders-farewell) to
Tlon when he left the project. In August 2020 we shared an update on the [known
distribution of address space](/blog/value-of-address-space-pt3), where
Curtis’ galaxies are marked as Tlon’s “naked galaxies”. Shortly thereafter, Tlon
disbursed its naked galaxies among the employees that wanted one who did not
already possess one, thus removing Tlon and urbit.org’s controlling share of the
Senate. Galaxies held by current and former Tlon employees are entirely
independent of Tlon Corporation—they may do with them, and vote with them, as
they please. `~ravmel-ropdyl` plans to give more color to this decision in the
near future.

Distribution of stars is much more difficult to know. There is an active market
for stars on [OpenSea](https://opensea.io/collection/urbit-id), so we know that
they are changing hands frequently, but checking the number of distinct Ethereum
addresses that hold stars does not tell you very much information since a single person can control multiple adresses.

### Software and smart contracts

As was written in [The DAO as a Lesson in Decentralized
Governance](https://urbit.org/blog/the-dao-as-a-lesson-in-decentralized-governance/),
we are keenly aware of the threat of _decentralization theater_. Urbit has
undergone steady progress towards decentralization, and with the developments we
outline below, it’s never been more clear that the project is beginning to leave
the cradle of Tlon. It’s also important to note that the decentralization of a
project is always a movement away from an initial centralized state⁠—you cannot
go from A to Z without first traversing every letter in between. While Urbit was
centralized at the beginning, the journey towards a network owned and
controlled by the users is now well underway.

In the past, nearly all Urbit software was written by Tlon. While Tlon is still
the only corporation actively updating Urbit’s MIT-licensed open source
software, namely [Vere](/docs/glossary/vere) (the runtime),
[Arvo](/docs/glossary/arvo) (the kernel),
[Landscape](/docs/glossary/landscape) (the client), and
[Bridge](/docs/glossary/bridge) (the ID manager), unaffiliated individuals have been making enormous contributions to Urbit over the past couple of years via the [grants program](https://grants.urbit.org/history). Recent examples include the [Bitcoin node and wallet integration](https://github.com/urbit/urbit/pull/4940), [WebRTC integration](https://grants.urbit.org/proposals/21131866-webrtc-gall-agent-and-external-app), [Port, an Urbit installer and ship manager](https://github.com/arthyn/port), and [`|fuse`, an important primitive for 3rd party software distribution](https://github.com/urbit/urbit/pull/4820).

The only real power Tlon holds over Urbit is the ability to push [OTA
updates](/docs/glossary/ota-updates) via `~zod`, and suggest that people
download our binaries. To the best of our knowledge, all extant galaxies
retrieve their OTA updates from `~zod`, who forward it to their stars, who
forward it to their planets. This software distribution route is merely a
convenient default setting. Ships initially retrieve OTA updates from their
sponsor, but they have full authority to retrieve updates from whoever they want
with the `|ota` command, or even to only install software updates by hand if
they so choose.

In the future, one can easily imagine many organizations shipping their own
distributions of Urbit from their own urbit nodes, somewhat analogously to the
large number of Linux distributions which exist today. There is nothing we can
do to stop a group from forking Urbit, declaring `~sampel-palnet` the new `~zod`
(both for updates and for sponsorship purposes), and retrieving all OTA updates
via that route and building their own binaries. This is all by design, and we
wouldn’t want it any other way.

The use of the Azimuth smart contracts is also somewhat optional. By changing a
few lines of code to point their ships at another set of PKI smart contracts,
they could rid themselves of hierarchical peer discovery entirely and make use
of some other routing strategy such as [Kademlia based DHT
routing](https://en.wikipedia.org/wiki/Kademlia). This would likely give rise to
an entirely separate network. The fact that the network is fully capable of such
a schism helps keep the Senate honest and accountable to the users. If they ever
were to vote on a contract modification that greatly angered or upset a portion
of the user base, they would be inviting such a schism and be entirely deserving
of it. In that sense, the power to control the network is already held by the
users, they just have not yet had a reason to make use of it.

### Legitimacy

The only way by which Tlon and the Senate hold any power is via legitimacy.
Vitalik Buterin recently wrote a [very informative
article](https://vitalik.ca/general/2021/03/23/legitimacy.html) on the role of
legitimacy in decentralized governance, and I do not know of a better source to
understand how Tlon and the Senate are kept in check by the users. Besides the
DAO split resulting in Ethereum and Ethereum Classic mentioned in the article,
perhaps the most prominent example of the power users have over a decentralized
network is the saga of [Steem and Justin
Sun](https://www.coindesk.com/justin-sun-bought-steemit-steem-moved-to-limit-his-power).
The short version of the story is that Justin Sun bought a controlling share of
the Steem blockchain and attempted to exert control over it, and the users
banded together to fork the blockchain into one called Hive, which was identical
to Steem except with Sun’s token balance set to zero. An analogous outcome for
Urbit would be that the Senate makes sweeping changes to the PKI and invites a
schism like that outlined above.

For these reasons, there are strong disincentives for any one organization or
individual to acquire too many galaxies. If galaxy ownership becomes more centralized, individuals will be less incentivized to build on the network which will reduce the value of address space. Furthermore, such centralization might provoke a fork if such centralized powers are perceived as malicious by the users. This is in contrast to real-life republics, where there is little risk
for one party to accumulate as much power as they can manage since the cost to
the citizens to overthrow that power is enormous. Thus, only especially
egregious displays of power ever result in rebellion. Within the Urbit republic,
users need only to change the code they run to leave the Senate powerless, and
so the threat of rebellion is much more real. We estimate that within a digital
republic like Urbit, the centrifugal forces outweigh the centripetal forces, and
that the outcome of this is more stable than the reverse.

### Why have governance at all?

An important question the reader may still have lingering is: why does Urbit
need governance at all? The short answer is: (i) there will always be necessary
protocol upgrades that cannot be foreseen, and (ii) a total lack of governance
inevitably gives rise to a shadow government with undefined powers that is
almost impossible to hold accountable.

With (ii), we see this to be the case on many early blockchain projects where
power is shared by the developers and the miners, but what each is capable of
doing has never been codified, and thus users of the blockchain can never have a
great deal of certainty of what changes might occur in the future. This doesn’t
guarantee a bad outcome, but it does create more wariness among developers when they cannot know whether they really have a say in
the project's direction. Recognizing this issue, many newer blockchain and
blockchain-adjacent projects have built-in governance mechanisms that lay out
exactly what an individual can expect should they join and contribute to that
network.

As for (i), with Urbit being a wholly new kind of network, it would take
incredible luck to get the PKI exactly right on the very
first try without ever needing another modification. Thus, some mechanism was
needed to guarantee that the PKI’s logic could be altered. Leaving control of
Azimuth in the hands of Tlon would have just granted Tlon dictatorial power, which Tlon nor Urbit users desired. There’s certainly
room to argue that the Galactic Senate is not a perfect system: our interim
constitution did outline potential roles for stars and planets to play in
governance in the future, so there is ample opportunity for the system to evolve
in response to the will of the users. As always, it is important to keep in mind
the unfinished nature of the Urbit of today and the still moldable clay of the
Urbit of tomorrow⁠—nothing yet is set in stone.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Gang Solves the Gas Crisis]]></title>
            <link>https://urbit.org/blog/rollups</link>
            <guid>https://urbit.org/blog/rollups</guid>
            <pubDate>Thu, 13 May 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![gas station](https://media.urbit.org/site/posts/essays/gas.jpeg)

Anybody who has used Ethereum smart contracts recently is aware that it has
gotten _expensive_. There are a large quantity of
complicated and clever techniques each with their own trade-offs
that are collectively referred to as "layer 2 solutions" (see [further
resources](#resources) for more information about these). This is in contrast to
the base computational layer of Ethereum called "layer 1", which is what constitutes most Ethereum usage and where [Urbit ID](/docs/glossary/azimuth)’s smart contracts currently exist.

Tlon has always covered gas costs for Urbit ID up to a set limit, and this was easy a couple of years ago when the cost of transactions required to get a [planet](/docs/glossary/planet) up and running came out to less than a dollar. Unfortunately the ongoing Ethereum gas crisis, along with the rising price of Ethereum itself, has made this impossible. We’ve seen gas costs to set up a planet as high as several hundred US dollars at time of writing!

In response to the gas crisis, Tlon has spent the last several months developing
a simple, in-house layer 2 solution which we anticipate will reduce typical gas costs by 65x or more.

This post is primarily a short non-technical explainer of the end-user experience of our solution aimed at planet and [star](/docs/glossary/star) owners and those in the market for one, as well as a status update on where we're at in development. At [the end](#technical) we give some minimal technical details and resources to help you dig deeper should you wish.
This is also primarily aimed at those who currently self-host or plan to self-host their
urbit. For anybody utilizing a hosted service, this matter will all be handled
by your provider. There is a [separate section](#stars) addressed specifically at star owners, and another [section](#rollers) for those who wish to set up their urbit to accept and submit layer 2 transactions. We’d like to emphasize that this system is 100% opt-in—if you are satisfied with the current experience of Urbit ID, then nothing changes for you whatsoever.

Perhaps the most pressing question held by anybody reading this is—when will
it be ready? It's not reasonable to give a timeline on difficult engineering
work, but rest assured that completing this upgrade is a top priority. Much
of the back-end is approaching completion, and we are confident in a release before the end of Q3 and hopefully much sooner.

### Naive rollups

Our layer 2 solution, designed primarily by Tlon lead engineer `~wicdev-wisryt`,
is known as "naive rollups" and we will be using this term interchangeably with
"layer 2"—though it is important to note that there are many layer 2 solutions
utilized by projects other than Urbit. As we're avoiding technicality here, we’re focusing primarily on the advantages and disadvantages of utilizing our layer 2 solution, and how that affects the management of your [ship](/docs/glossary/ship).

Very briefly, a rollup is a way to combine many transactions into one, and we
are building infrastructure so that any Urbit ship may be utilized as a "roller". A
roller will collect layer 2 Urbit ID transactions, confirm their validity, and
post them to the Ethereum blockchain. More detail is given [at the end](#technical). Anybody may set up a
ship to [act as a roller](#rollers). Tlon will be launching our own publicly accessible roller, but as Urbit is a decentralized network, by no means will we have a monopoly.

#### Pros and cons

The primary advantage to using naive rollups is that the gas cost for Urbit
ID-related actions will be dramatically reduced. It will be reduced sufficiently that we expect that a few transactions per ship per week (plenty for ordinary usage) submitted to Tlon's roller will not cost the end user anything. There are no gas costs associated with submitting a layer 2 transaction to a roller, and Tlon will bear the gas cost of posting the results to the blockchain. That means that the cost you see for a planet on a market that utilizes Tlon's roller ought to be
the final cost.

There are a few trade-offs for this, but none of them really sacrifice the core
value propositions of Urbit ID.

The most substantial one is that ships on layer 2 are essentially completely isolated
from the rest of the Ethereum ecosystem. They can no longer interact with smart
contracts designed to work with Urbit ID or non-fungible tokens (which are how Urbit IDs are represented) in general. It is also not possible to write new Ethereum smart contracts that work with layer 2 ships.

Compounding that factor, the journey to layer 2 is one-way only—at
least for now. There are theoretical ways a ship may be moved back to layer 1, but they do not yet exist, and we cannot promise that such a thing will be available in a timely manner. Anybody moving a ship to layer 2, or buying a ship on layer 2, should assume that they will
remain on layer 2 for the foreseeable future. We do not expect this to be
permanent, but it is perhaps the most significant drawback for the time being.

Another one is that transactions may no longer be "instant". Effectively, this
was already the case on layer 1—unless you paid a lot of gas, you could wait
hours or even days for your transaction to clear. But the way we are saving on
gas is essentially by "bundling" or "rolling up" many transactions into one, and
submitting them as a single transaction. The more transactions in the rollup,
the better the savings. This bundling is not the only factor at play here
though—costs are reduced other ways, but this is a technical detail
[discussed later in this post](#technical). It is possible to use layer 2 to submit single
transactions (and this will still save on gas costs!), so utilization of layer 2
should not incur any delay over layer 1 when utilized in this fashion.

Tlon has not finalized the details on how our roller will work, but it will
probably involve waiting until a sufficient backlog of transactions have been
submitted to make it economical to bundle them up, or just submitting every set
time period, whichever arrives first. We do not see this as a big issue—we
view Urbit ID as "digital land", and a few hours to acquire land, or waiting for
your new personal computer to be delivered, is still lightning fast in
comparison to the real world. We also have ideas on methods that will allow you to get on the network before the transfer has been confirmed, but that is outside of the scope of this article.

Our layer 2 preserves the main value proposition of Urbit ID, which is that your ship
belongs to you forever, and that this is assured by very strong cryptographic methods and
game-theoretic arguments comparable to the ones that exist on layer 1. We
consider this principle to be uncompromisable, and maintaining ultimate
sovereignty over your ship was totally central in choosing our solution.
We summarize the new security model [below](#technical), and `~wicdev-wisryt`
goes into greater detail in the [resources](#resources).

### Changes to User Experience

The primary way one manages their Urbit ID, namely performing tasks such as
transferring ships, setting networking keys, or setting
[proxies](/docs/glossary/proxies), is with a web interface called
[Bridge](/docs/glossary/bridge) found at
[bridge.urbit.org](https://bridge.urbit.org). If you already own a planet,
you've probably used Bridge before - perhaps only a single time.

Bridge will be getting a facelift to enable easy interfacing with layer 2,
including loud warnings about what is being gained and lost by doing so. From
here you will be able to transfer your ship to layer 2, and once there,
perform all the usual actions you can on layer 1.

The main difference for layer 2 transactions on Bridge will be the additional
choice of a roller to submit transactions to. Tlon's will be free for ordinary, non-time-sensitive usage.
You could use your own ship for a fast single transaction for a little more gas. We expect that planet markets and stars may wish to set up their own rollers as well.

Every planet has a sponsor star, which distributes [OTA
updates](/docs/glossary/ota-updates) to their sponsored planets and assists with peer discovery. Both layer 1 and layer 2 planets will be able to be
sponsored by either layer 1 or layer 2 stars, meaning that nothing will change
in terms of how sponsorship works.

When you buy a ship, any reputable seller will inform you whether or not it is
on layer 1 or layer 2. Anyone running an urbit will be able to verify this information, and we expect for tools to exist to make this information publicly available (see [this grant](https://grants.urbit.org/bounties/1101665172-network-explorer-data-pipeline-http-api)).

And that's it! If you'd like to know how things will be changing for
[stars](#stars), what goes into [setting up a roller](#rollers), and additional
[technical details](#technical), read on.

### Changes to stars {#stars}

Both planets and stars will be able to move to layer 2.
[Galaxies](/docs/glossary/galaxy) must remain on layer 1 for technical
reasons, and [moons](/docs/glossary/moon) and
[comets](/docs/glossary/comet) never interacted with Ethereum anyways, so
they are completely out of the picture.

Stars will be able to remain on layer 1 with no action required. For star owners
that wish to take advantage of the cheaper gas costs, there are two possible
modes: ownership of the star on layer 2, or setting the spawn proxy to layer 2
with ownership remaining on layer 1.

The first mode—a star which is owned on layer 2—has the same advantages and
disadvantages as a layer 2 planet. Planets spawned by a layer 2 star will also
necessarily be on layer 2 - there is no way to spawn a layer 1 planet from a
layer 2 star, though any planets which were spawned on layer 1 before the
star migrated to layer 2 will remain on layer 1.

The second mode—ownership on layer 1, with spawn proxy on layer 2—is only slightly more complicated. Such a star will change its networking keys, transfer
between wallets, and set its management proxy all on layer 1, with the
corresponding higher gas cost. However, it will be able to spawn planets on
layer 2—and _only_ on layer 2—with the corresponding layer 2 tradeoffs. Like
moving ownership to layer 2, this will be a one-way journey for now. Planets
spawned before moving the spawn proxy to layer 2 will remain on layer 1, but
from then on, all planets spawned by that star will live on layer 2. Finally, stars in this second mode may transition to the first mode, but not vice versa.

### Creating a roller {#rollers}

![gasprices](https://media.urbit.org/site/posts/essays/gasprices.jpeg)

Rollers are urbit nodes which users submit transactions to to be "rolled up"
into a bundle to be submitted to the Ethereum blockchain. The business logic for
a roller runs on the urbit node itself. Thus, anybody with an urbit ship may set
it up to act as a roller. While the details of how rollers work are still being
hammered out, one should expect that one can either set transactions to be
submitted at regular intervals, once a sufficient number of transactions have
been received (as more transactions means greater savings), manually, or some
combination of the above.

Tlon plans to release documentation on how to set up your own roller concurrently with
the release of our layer 2 solution.

Malicious rollers could potentially exist, but the worst they ought to be able
to do is simply not submit your transaction. The security factors for rollers
are briefly addressed [below](#technical), and elaborated upon in the
[resources](#resources), but you can expect full technical documentation on
these factors to be included in the roller documentation.

### Changes to Azimuth

[Azimuth](/docs/glossary/azimuth) is the set of Ethereum smart contracts
governing Urbit ID. They will require a few changes to accommodate the new
system. Some of this has been implicit above, but to be clear, we will only be
making a couple minor alterations:

- Once a star's spawn proxy is set to the layer 2 address, it can't be switched
  back, and they can no longer spawn layer 1 planets.
- Galaxies and their proxies cannot be deposited to layer 2.
  Some other minor details are yet to be worked out, but again, nothing will change for those who wish to remain on layer 1.

### Technical details {#technical}

What's really going on behind the scenes here? Briefly, only the data of the Urbit ID transactions will be posted on-chain, while computation and state storage will now happen on your ship.

In layer 1, the [Ethereum Virtual Machine (EVM)](https://ethereum.org/en/developers/docs/evm/) guarantees the validity of state transitions, while for layer 2 transactions, each Urbit node guarantees the validity of the state transitions.

Changes to the state of Urbit ID on layer 1 works as follows:

1.  A transaction is posted to the Ethereum blockchain.
2.  The EVM calculates the resulting state transition and checks its validity, then updates the state.
3.  Your urbit downloads the new state from an Ethereum node.
4.  Your urbit makes the final decision on whether the new state is valid.

In practice, the fourth step is never used in layer 1. The primary change to our
security model is that we are cutting out step 2 and beefing up step 4. Your
ship will now perform validation of the transactions posted to the Ethereum
blockchain, rather than the EVM.

Since [Urbit OS](/docs/glossary/arvo) is deterministic, and Hoon has some nice formal
properties, it turns out to be a great language for writing smart contracts. Thus we are effectively swapping the Ethereum smart contract with a “Hoon smart contract” run locally on your ship.

#### Further Resources {#resources}

We want to keep this post brief and non-technical, so that's all we'll say about
it for now. To find out more, you have a few directions to go on. We held a
[Developer Call](/events/2021-03-04-developer-call-scaling-azimuth) where
`~wicdev-wisryt` outlines the design in much more technical detail, and also
explains why we decided to utilize our own design rather than other known layer
2 solutions such as [Optimistic
rollups](https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/optimistic_rollups/),
[ZK-rollups](https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/),
etc, or other blockchains. He also plans to do a more technical walkthrough video sometime before release. For those who would rather read, see
`~wicdev-wisryt`'s [RFC: Naive rollup for cheaper Urbit ID
transactions](https://groups.google.com/a/urbit.org/g/dev/c/p6rP_WsxLS0/m/hQBX0modAwAJ)
post on the `urbit-dev` mailing list. Lastly, the primary working branch on
Github for the Urbit side of naive rollups is
[here](https://github.com/urbit/urbit/tree/philip/naive), though it is not the
only place code is accumulating.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from urbit.org]]></title>
            <link>https://urbit.org/updates/2021-05-05-update</link>
            <guid>https://urbit.org/updates/2021-05-05-update</guid>
            <pubDate>Tue, 04 May 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Hello!

Welcome to the May edition of the urbit.org newsletter. April was a busy month with many updates to share—let’s dig in.

0 – Updated Urbit Binaries

Urbit’s binaries were updated to v1.5 on April 27th. Make sure to download and install the latest v1.5 binaries here: https://github.com/urbit/urbit/releases/tag/urbit-v1.5

It’s as easy as shutting down your ship and replacing the old binaries! ~pilfer-pandex described the new release to urbit-dev as “a high priority fix for two networking bugs in urbit-king, and minor fixes to vere.”

1 – Upcoming Events

Urbit Town Hall @ May 20th 12pm PDT – Keynote from Justin Murphy
This will be Urbit’s first ever town hall—a three hour event with talks on a variety of topics and a keynote from Justin Murphy (~hatryx-lastud). Justin had Urbit Foundation Director Josh Lehman on his Other Life podcast a few weeks ago (have a listen at https://share.transistor.fm/s/1c0c8c15) and recently formed a new group on Urbit (~hatryx-lastud/other-life).

In his group, Justin has written a blog post called “Escape Velocity”, where he discusses selection effects on various platforms. Justin writes, “by creating a gravity well that sucks energy into real-estate value rather than monetized attention, Urbit exerts the lowest degree of arbitrary selection pressures on content creation, while optimizing those selection pressures that irreducibly characterize all human communication (e.g., the draw of being understood and appreciated by other people).” Tune in to Justin’s keynote on the 20th for more on Urbit as a platform for creatives.

Developer Calls @ May 13th and May 27th
As you probably know, we have developer calls every two weeks. Stay tuned for more information on our events page: https://urbit.org/events

Austin Urbit Conference @ September/October 2021
Although it’s too early to give a precise date, we are starting to plan an Urbit conference for this fall! It’ll be held in Austin, with many Urbit and Tlon employees in attendance. Stay tuned for more information!

2 – April Developer Calls

Developer Call: 3rd Party Software Distribution
In this talk, Phil (~wicdev-wisryt) and Raghu (~sovmep-ripsum) discussed the work they've been doing to clay to provide "virtual desks", an integral part of the infrastructure needed for safe, generic software distribution. This work is being done through our Scholarships program, in which community developers pair up with Tlon engineers to work on infrastructure projects. For more information about Scholarships, visit https://urbit.org/docs/development/grants/#scholarships

Developer Call: Real-Time Communication on Urbit
Edward Amsden (~ritpub-sipsyl) gave us a look at the WebRTC Airlock library he has developed that handles the hard parts of WebRTC. When complete, this will allow developers to build applications on Urbit with audio/video calling capabilities. Once again, Edward’s work is sponsored as part of the grants program (https://grants.urbit.org)—check it out!

3 – Urbit Bitcoin Launch

This was a hotly anticipated event and it didn’t disappoint. In case you missed it, Urbit will soon have a Bitcoin wallet on the network, meaning you’ll be able to pay Urbit ships directly in BTC. Watch Urbit-Tlon personnel demonstrate and discuss this exciting launch: https://www.youtube.com/watch?v=_aRnfacZPto

Make sure to check out this related blog post by Christian Langalis (~pindet-timmut): https://urbit.org/blog/interplanetary-commerce/ and this great interview with ~timluc-miptev, one of the main developers on the project: https://subject.network/posts/bitcoin-with-timluc-miptev

4 – Blog

We have a couple of new posts to announce:
“Lunar Urbit and the Internet of Things”
This post is by Poprox (~datnut-pollen), a Tlon engineer who focuses on the importance of moons in the Urbit ecosystem. The post covers “the prehistory of moons on Earth, gives a snapshot of how moons are being utilized on Urbit in 2021, covers existing issues with consumer IoT and how Urbit resolves them, and speculates what the lunar locus of the Urbit ID address space may become in the future”. Read it here: https://urbit.org/blog/iot/

“Community Spotlight: The Portico”
This post is an interview between me (~tirwyd-sarmes) and Josh Reagan (~taglux-nidsep), the founder of “The Portico”, an Orthodox Christian community. Josh has a PhD in logic, and writes about the intersection of Christianity and logic on his Urbit blog. In the interview we talk about community norms, the relationship between logic and religion, and the future of Urbit. Check out the interview: https://urbit.org/blog/community-spotlight-the-portico

5 – Odds and Ends

If you are a star or galaxy owner and are interested in sponsoring other ships, please message ~rapfyr-diglyt (david@tlon.io) to be added to the sponsors@urbit.org mailing list.

~hodzod-walrus made a page with statistics on various stars: https://bacrys.org/uptime/

~sitful-hatred beat us to the punch and released a guide on compiling Windows binaries—urbit.exe is near at hand! See the guide here: https://subject.network/posts/urbit-windows-binaries/ The official Urbit.org announcement should be around the corner, so keep your eyes peeled.

Thanks for reading. Talk to you next month!

Josh (~wolref-podlex) and ~tirwyd-sarmes

https://twitter.com/urbit
https://github.com/urbit/urbit
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Community Spotlight: The Portico]]></title>
            <link>https://urbit.org/blog/community-spotlight-the-portico</link>
            <guid>https://urbit.org/blog/community-spotlight-the-portico</guid>
            <pubDate>Mon, 03 May 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/orthodoxchurch.jpg)

_One of the most striking things about Urbit is the ideological diversity between communities. The Community Spotlight blog series will focus on various Urbit communities via interviews with founding members._

For the first week of the Community Spotlight series, I (~tirwyd-sarmes) will be speaking with Josh Reagan (~taglux-nidsep). Josh is the founder of The Portico, an Urbit community of Eastern Orthodox Christians.

The Portico is a very active group with conversations taking place over multiple channels. There are channels for posting Orthodox iconography, discussing the broader Christian culture war, and just talking about Orthodoxy in general. Of particular interest is Josh’s “Euthyphro” blog series which investigates the relationship between logic and the Orthodox faith. This is a topic that Josh is well qualified to talk about: he has a PhD in Philosophy from Rice University. His dissertation on the epistemology of logic and truth-preservation was titled "Knowing Your Limits: Logic for Limited Beings”. Josh is also the co-author of a forthcoming textbook on formal logic.

To read Josh’s blog is to be inducted into two esoteric traditions: theory of logic and Orthodox theology. With titles like “St. Gregory the Theologian and the Liar Paradox” and “The Existence of Abstract Objects”, Josh does not pull punches.

Accordingly, our conversation focused on the idiosyncratic and niche community that The Portico is home to. There, you won’t find cussing or much talk about “life partners”, but you will find cutting critiques of liberalism and the best way to raise Orthodox children.

As other users have pointed out, Urbit is pre-[Eternal September](https://en.wikipedia.org/wiki/Eternal_September). In fact, there’s some hope that the very nature of Urbit, how it tries to protect the sovereignty of niche communities via decentralization, might foil the Eternal September phenomenon. If Josh’s community persists, it will be a testament to both Josh and the decentralized Urbit network. As of now The Portico is a refreshing, perhaps jarring (as Josh might say), reminder of what the internet looked like back in the early days—a place for those who are different.

I encourage you to take a look. Find The Portico at ~topnup-firber/the-portico.

\-\-\-\-

**Do you see any connection between Rod Dreher’s _The Benedict Option_ and your community on Urbit? Dreher sees a need for American Christians to create self-sustaining communities outside of the mainstream to protect the Christian religion and culture.**

It’s tough to say with certainty—I’ve never read _The Benedict Option_.

A few years ago, while he was writing the book, I was a regular reader of Dreher’s blog. From his descriptions there, I was never clear about what exactly he was proposing. Much of his “clarification” came by way of metaphor: don’t “run for the hills”, but stop “shoring up the American imperium”. I didn’t read his book because I didn’t have much confidence that he would be especially precise or insightful.

[There is an interesting review I’d recommend](https://handleshaus.wordpress.com/2020/10/06/review-of-rod-drehers-live-not-by-lies/), however, of his later book, _Live Not By Lies_. I believe it accurately characterizes the scale of the threat Christians will soon face in this country.

My upbringing was conservative Christian and self-consciously counter-cultural. I've inherited that understanding of what it means to be a Christian in an increasingly secular world. It comes naturally to me, so I find it obvious that Christians should form self-sustaining communities. But the details matter. What do such communities look like? How do we secure the freedom to pursue such communities? How do we sustain them, when myriad external forces seek to undermine them? How do we solve the long-term problem of the declining cultural importance of Christianity (which surely erodes the plausibility of our religion to many, even to some of those with sympathies toward it)?

I don’t claim to know the answers to these questions.

One kind of answer is that we should redouble our efforts to support and maintain a religiously and morally neutral liberal political order, which leaves room for subcultures to live and self-regulate as they wish. I disagree. Those who support a kind of “neutral” liberalism view it as an attempt to go “meta” and rise above various parochial metaphysical, moral, and religious disputes. I view this as a cop-out, a refusal to grapple with the most important questions.

Does the liberal have metaphysically-rooted moral reasons for going “meta”? If so, then he’s just another sectarian and he should be honest about it. The only difference is that his team has had the whip hand for the last several generations. On the other hand, if the liberal claims no underlying metaphysical justification then his project can succeed only to the extent that he can arrange and adjudicate unprincipled (and therefore ad hoc) agreements between otherwise hostile moral communities. But how stable can such an arrangement really be?

Orthodox Christians have theologically rich, metaphysical foundations for their social and moral teachings. With these we can form healthy, thriving, and growing communities. We can do so even under actively hostile political orders. If the early Church could make it under the Romans, so can we today. But it’s going to be difficult and sound judgment is necessary. Unfortunately, we lack strong leadership and that leaves us vulnerable. If we stay uncoordinated we dissipate our energies needlessly. If we latch onto the wrong leaders we can be led astray.

The challenges are immense. There is no technological solution. Even so, I’m an Urbit early-adopter for a reason. Over the years I’ve come into contact with a number of Orthodox and Ortho-curious Urbit followers. Why not try to bring them together in an Urbit group?

As far as I know, no one in the group is clergy. We’re all just a bunch of laymen with no authority to do much of anything. But I’d like to think we can still contribute in some way. I have an academic background in analytic philosophy so my inclination is to emphasize theory, but we have room for a bit of everything. Someone in the group wrote a script to take the texts of various Church Fathers and convert them to audio using AWS Polly. Those turned out pretty well!

At times I entertain ambitions to do a bit more, but for now perhaps it’s better to keep expectations in check. If nothing else, we can read and discuss the Scriptures and Church Fathers together, and try to understand better how to apply and live out their teachings. As we continue to grow the community and develop a consistent internal dynamic perhaps opportunities will arise that aren’t yet on the horizon. One thing I can say is that I’m committed to keeping the group active and growing.

**I’d like to talk about your blog on The Portico. It combines two of your main interests: logic and theology. In broad strokes, do you think theology and logic are compatible? What is the relevance of this intersection to both of these disciplines?**

I feel obligated to answer this question in two ways.

(1) If by “logic” you mean “first-order predicate calculus”, then I think there’s no special conflict between logic and theology. There are certain puzzles about their relationship, but similar puzzles exist between logic and other disciplines. Theology isn't especially endangered.

For example, in the 1930s, Alfred Tarski proved his famous Undefinability Theorem. Crudely put, it says that a plausible truth predicate cannot consistently be contained in any formal system with axioms strong enough to model arithmetic. Superficially it seems like our options are (a) get rid of the concept of truth, (b) get rid of arithmetic, or (c) throw away parts of logic until all inconsistency disappears.

None of these options is appealing. Tarski came up with a solution that mostly satisfies many logicians: reduce the concept of truth to “truth in a language” and forbid any language from containing its own truth predicate. If you want to talk about truth in a language L-1, you have to do it from a “metalanguage”, L-2.

Is Tarski’s definition of truth in a language the definitive solution for preserving truth, math, and logic? Perhaps not many philosophers think so, and there’s a massive literature in which logicians have attempted to improve on or extend his results.

Sometimes people seem to think formal logic is an infallible gift from heaven that must always be right. Kant said in the _Critique of Pure Reason_ that formal logic is essentially a completed field. In fact, [the logic of his day](https://en.wikipedia.org/wiki/Port-Royal_Logic) was an early-modern Cartesian variation of a medieval scholastic synthesis of ancient Stoic and Aristotelian logics. Roughly 100 years after Kant’s first critique was published, C. S. Peirce and Gottlob Frege independently discovered first-order mathematical logic as we know it today, inaugurating the greatest advance of logic since Aristotle. Kant was wrong.

Mathematical logic is a convenient, generally reliable, man-made tool that, when used carelessly in certain untamed domains, can lead one astray. Probably most people reading this are familiar with such puzzles as the Liar paradox. When one understands that logic is not a completed science, and perhaps never will be, there is less reason to worry about whether it can be used to nuke entire disciplines, like theology.

For more on this topic, see the blog post in my Urbit group: “St. Gregory the Theologian and the Liar Paradox”.

(2) There is perhaps a deeper challenge than the one I’ve just sketched. The Stoics used the term “logic” to encompass what we might today call “epistemology”. If the word “logic” is meant in some such broad and normative sense, then we may restate the challenge as one about rationality and theology. Is it irrational to pursue theology in our modern age?

As an undergraduate under the influence of Kierkegaard, I was attracted to a romantic, vaguely irrationalist notion of faith. Dawkins-mania was at its peak and I was disgusted by the pop-rationality (or was it empiricism?) of his annoying followers. Their view seemed to be that rationality just means “following the evidence”. The raw evidence is foundational, and theories are built atop by generalizing from the evidence. The ghost of logical positivism is with us even now.

I was dimly aware that Quine and others had made it difficult to sustain epistemic foundationalism. However, being unable to supply a more clear and cogent notion of rationality, I became skeptical of the idea altogether. But I went too far.

Instead, the proper response is to develop a superior account of rationality. Readers can probably guess where I went looking!

The word “logic” comes from the Greek “λόγος”. This is also the word used to describe Jesus Christ in the Gospel of John: “In the beginning was the Logos, and the Logos was with God, and the Logos was God.” This connection is not merely etymological.

For many ancients, the term “λόγος” meant something like “divine principle”. You might think of it as akin to a law of nature, but with stronger theological connotations. Christians appropriated this term and made it rather more exalted: the Logos is begotten of the Father, and yet somehow one with Him.

We are told that all things come into being through the Logos (John 1:3), giving Him an intimate relationship to the whole of creation. He gives structure and order to all created things, and in His divinity He understands them as so structured and ordered. He is also sinless, perfectly holy, and good. In Christ we have a perfect unity of the knowledge of all truth and righteousness.

Man was created in the image of God, which means that we bear a likeness to Christ. And we are commanded to realize that likeness with ever greater fidelity (Romans 8:29). The Church calls the pursuit of this likeness [“theosis”](<https://en.wikipedia.org/wiki/Theosis_(Eastern_Christian_theology)>).

Thus we have the explanation of all normativity, according to Orthodox Christianity. In moral matters we must take on the holiness of Christ. In epistemic matters we aspire to the wisdom and knowledge of Christ, which includes an understanding of the whole created order. Socially we (the community of believers, i.e. the Church) are called to be in ever greater communion with God, cooperating with His work just as the Son cooperates with the Father.

Sadly we are conceived in sin and ignorant; hence the need for redemption by Christ.

Accordingly, my understanding of what it means to be rational is just to be Christ-like. The only perfect exemplar of reason, so construed, is Christ Himself. Any deviation from Him is irrational. What could be more logical than to be conformed to the Logos? But we cannot attain rationality without redemption. Hence we cannot become rational without first being saved from sin.

Doubtlessly many will find all of this too much to take, just too implausible. What about the development of mathematics, or the advances of the sciences? These are canonically ennobling, intellectual achievements. Jesus wasn’t a mathematician or a scientist! Nowhere in the Scriptures is He recorded as having applied Bayes’ theorem.

Undoubtedly my construal of rationality de-emphasizes the pursuit of knowledge by labeling it as merely one of several normative ends. To seek knowledge without seeking holiness is to be understood as dangerously unbalanced. To try to attain holiness and knowledge without communion with God is arrogant.

On the other hand, we need not exaggerate matters. St. Paul affirms the need for specialization of labor within the Church (1 Cor. 12). There is room for some to specialize in intellectual endeavors, so long as they act in a cooperative setting in which the other virtues are pursued as well. (Nor should anyone neglect the development of such virtues in himself.) Mathematicians and physicists are more than welcome in the Church.

According to this (all too briefly put) theory of rationality, there can be no conflict between ‘logic’ and theology. Theology is compatible with rationality because the account of rationality in question derives from a theological tradition. Naturally I’ve only given a sketch; much more could be said. But even if some readers are put off by the theory presented here, I hope it’s at least clear that there are conflicting notions of rationality. Anyone who wants to be rational confronts the task of figuring out which theory of rationality is correct.

**In terms of community moderation, The Portico follows norms that are quite different than other online communities, often times quite drastically. For instance, living with women that you are not married to, is not something that should be talked about lightly. Can you talk about the importance of norms and how they relate to a healthy community?**

Orthodox Christians are not commanded to “get along” with the rest of the world (John 15:18-25). We’re different, and our norms of interaction should likewise differ from those of outsiders. There is no one, monolithic “Orthodox culture”, but there are standards governing which local expressions of culture are legitimate and which are sinful. We should live in a way that enables and promotes holiness and discourages sin.

We have rules that may seem unusual from the outside. I don’t permit profanity, lewd jokes, or irreverent comments about God. In your question you mention a living arrangement that is prevalent in the world. Another rule I have is that we shouldn’t talk causally about sinful practices or lifestyles as if they are unremarkable parts of ordinary life. If Orthodox Christianity is true then such things aren’t minor peccadilloes. They’re spiritually destructive. The marriage-bond sanctifies activities that would otherwise be sinful.

If someone wants to analyze what is destructive about men and women living together before marriage, we’re open to that. But if you want to be affirmed in your sin, we’re not the place for you. Anyone of any religious creed is welcome to show up—but as a guest in an Orthodox Christian community. Hosts should be courteous to guests, but my first priority is not to make you feel good about your choices. We’re here to encourage each other, learn, and grow spiritually as Orthodox Christians. Naturally that means a little gate-keeping may sometimes be necessary if someone ever comes along who doesn’t share those goals. Being different is difficult and takes work.

In a way the cultural contrast is meant to be jarring. It can force you to confront moral and cultural presuppositions that you didn’t even know you had. When you become aware of the wider choices of culture available to you, you become free to look with a critical eye on the culture you’ve hitherto taken for granted. I think anyone could see how that might be liberating, even before considering the particulars of the cultures in question. Of course, as an Orthodox Christian, I think we have a good case to make about the particulars of our subculture.

I’ve never had to kick or ban anyone from the group. The group is relatively small (~180 people at the moment) so that probably helps. The vast majority of conversations are relaxed and friendly. Occasionally there are intense debates about one issue or another but I enjoy it, as long as it doesn’t become bitter or the primary mode of discourse. But everything ought to be done in a spirit of truth-seeking, not of one-upmanship.

**The fact that The Portico can exist side-by-side with atheist communities on Urbit is pretty striking. On Urbit, a user is able to create niche communities and governance structures and yet still participate in a larger network. In other words, Urbit is trying to thread the needle between sameness and difference through federation at multiple levels. It seems to me that modern culture has become homogeneous due to an inability to maintain, or distinguish between, different communities. People who have nothing in common are forced to engage as if they were roommates, while those who are similar have trouble creating their own home. In other words, what is the role of community formation in the modern world and how does it connect to your critique of liberalism? Does Urbit have anything to say about this?**

As I said in an earlier response, I see the liberal project as more or less an attempt to sidestep (not solve) difficult metaphysical and religious disputes between various distinct moral communities. Liberals have tried several methods of governance to achieve their ends. We can divide such attempts into two broad categories: centralized and decentralized.

Social media companies in the US confront similar governance challenges, so we can analyze them in similar terms.

A social network like Facebook takes a centralized approach. Zuckerberg spoke early and often of his desire to connect people and “bring the world closer together”. There was a sense that if people from various communities could get to know each other a little better, we would see how much we have in common and make progress toward some kind of universal cosmopolitan consensus.

But that didn’t happen. With centralized social media you’re practically guaranteed to interact with people whose moral and metaphysical commitments are sharply at odds with your own. As a result, you face a persistent, nagging risk of conflict. Without warning, a friendly disagreement can explode into an all-out flame war. Most choose one of two basic approaches for dealing with this threat:

(1) You live a compartmentalized life. You keep your moral and metaphysical commitments to yourself and cultivate a culturally homogenized persona for your social media activities. No one disagrees with you because there’s nothing to disagree with.

(2) You can enlist to fight in the culture war and display your regimental colors with pride. And because you take your smartphone everywhere you’re always on the front line.

These aren’t the only options, of course. With some combination of charisma, patience, and grace you can be relatively open about your beliefs without getting into too much trouble. But even if you have the talent to pull it off, it takes time and energy. Many of us aren’t willing to go to all that trouble. Social media is supposed to serve us, not the other way around.

Urbit is decentralized which, in my opinion, means that it isn’t really a network in the way that Facebook is. I see Urbit as more of a network platform. The users create the networks, or migrate them in from elsewhere. We’re all using Landscape and running our VMs on Nock, so obviously there can be interaction between different communities. But anyone who doesn’t want that cross-community interaction doesn’t have to have it.

I’ve followed Urbit’s progress since 2016, so I’m plugged into groups with other Urbit people I’ve come to know over the years. Other than that, however, I don’t know much about who’s out there. It’s not like The Portico is in one neighborhood and the atheists are in the next neighborhood over. There’s a real sense in which we’re not even on the same network—different Urbit communities share a common protocol, but a protocol isn’t a network.

Some people may want to see a little of everything. If atheists want to join our group they’re welcome to do so! We’ll be friendly. I don’t seek out their groups, though.

One virtue of decentralized social media is that it offers a totally different set of trade-offs with respect to how you share and act on your beliefs. What if you could talk earnestly about philosophy and religion without having to worry about alienating many of your friends and family? I guess that’s somewhat possible on Facebook—do they still have “groups”?—but Urbit was designed for it.

Having said all that, I don’t think decentralization is a panacea. Even if Urbit takes off, it will likely face problems that are difficult to anticipate now. My hope is simply that Urbit’s trade-offs are healthier than the ones we’ve had before.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Lunar Urbit and the Internet of Things]]></title>
            <link>https://urbit.org/blog/iot</link>
            <guid>https://urbit.org/blog/iot</guid>
            <pubDate>Thu, 29 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![phobos](https://media.urbit.org/site/posts/essays/phobos.jpeg)

<br>

Each of the ~4B 32-or-fewer-bit or [Azimuth](/docs/glossary/azimuth)
identities, namely [planets](/docs/glossary/planet),
[stars](/docs/glossary/star), and [galaxies](/docs/glossary/galaxy), may
spawn ~4B 64-bit child identities known as [moons](/docs/glossary/moon).
Moons are the undeveloped wild outback of Urbit, with a story waiting to be told
that promises to be as enormous in scale as the cloud personal computing story
told by planets, and possibly even more so.

Throughout this piece, we use "Earth" and "Mars" in the Urbit sense. "Earth"
refers to the [current computing
paradigm](https://en.wikipedia.org/wiki/Big_ball_of_mud). "Mars" refers to the
perfected computing paradigm that Urbit aspires to be, but also to the current
and future state of Urbit.

Today we will review the prehistory of moons on Earth, give a snapshot of how
moons are being utilized on Urbit in 2021, cover existing issues with consumer
IoT and how Urbit resolves them, and speculate what the lunar locus of the Urbit
ID address space may become in the future. To keep the futurist scope limited,
we primarily speculate on the usage of moons in (industrial) internet of things
settings, especially with respect to agriculture, and how they may manifest as
the workhorse collection unit of decentralized data markets.

For those unfamiliar, moons differ from all other
[ships](/docs/glossary/ship) in that they are not independent identities
with total sovereignty over their data and keys. Instead, their cryptographic
keys are issued and controlled by their parent identity. The relationship
between the keys of a parent ship and its moons are analogous to the
relationship between primary keys and subkeys in a system like
[PGP](https://en.wikipedia.org/wiki/Pretty_Good_Privacy). The parent may revoke
or change its child moons' keys at any time. A typical relationship between a
planet and a moon may be like one of a human and their smartphone. If you lose
your phone, you don't want someone to pretend they are you, operating one of
your moons, on the network. The planet can revoke the keys, and the moon stored
on the phone becomes inert, no longer able to communicate with the network.
While planets and stars also depend on their sponsor to assist with peer
discovery and software updates, these relationships rely on mutual agreement,
since either party may choose to discontinue the relationship and establish a
new one elsewhere. Moons possess no such freedom.

### Lunar prehistory

![luna](https://media.urbit.org/site/posts/essays/luna.jpg)

It may come as a surprise to you that you are already very familiar with moon
identities—they've just never been explained as such because the context in
which that terminology makes sense didn't exist before Urbit. Moons, in fact, are not
a new concept at all. Virtually your entire experience of the internet in the
modern era is the experience of someone who possesses some number of moons
subordinate to planets who mostly refuse to talk to one another. The feeling you
get of constantly moving between silos, juggling accounts, not controlling your
own data, etc., is a direct result of the fact that, on Earth, you only possess
moons. No planets.

We're speaking, of course, of the client-server relationship. From the Urbit
perspective, the Facebooks, Twitters, and Googles of the world are planets, and
accounts held with these services may be thought of as moons subordinate to
those planets. Your account with these megacorps is only yours for as long as
they please. If you happen to step on a digital landmine, such as a virus that
causes Google's servers to believe you are a bot, you are suddenly banned from
their service, often with no recourse. All your data, your connections, your
network—vanished. We are all Mark Zuckerberg's moons, and they're armed to the
teeth with surveillance equipment.

There are two classes of internet users: those with servers who hold all the
power, and clients who use those servers in the way prescribed by the owners.
Running a server is theoretically accessible to anyone, but practically
difficult: server maintenance is a technical endeavor that requires specialized
knowledge and substantial time investment. Other barriers exist beyond just the
technical: for instance, if you wish to set up your own email server, you will
probably be blocked by large providers because unknown email servers are almost
always spam. The root cause of this circumstance is that the email protocol
lacks [Sybil resistance](https://en.wikipedia.org/wiki/Sybil_attack). Urbit has
Sybil resistance built in, eliminating certain kinds of incentives for
gatekeeping such as this.

We seek to level the playing field by giving everyone a server. We accomplish
this by making the process of running your own server (planet) as easy as
running your personal computer today. We aren't quite there yet, but we've made
leaps and bounds over the past couple of years.

Of course, this analogy isn't perfect—Urbit moons are servers themselves, but as
they may only act in accordance with the wishes of its parent, they are
effectively as locked in degrees of freedom as a client is to a server. The
moon's keys may be revoked at any time by the parent. To distinguish these
prehistoric moons from Urbit moons, we will refer to them later as "primitive
moons".

Urbit contends that moons are not the appropriate digital exocortex for a
responsible adult. They are for devices, experiments, or your children. We hope
that the dominant server-client relationship, which is the primary weapon of the
surveillance-industrial complex, will meet its end in the near future.

### Moons in the early Martian era

![sputnik](https://media.urbit.org/site/posts/essays/sputnik.jpg)

In 2021, moons are mostly unused on Urbit. There's a smattering of minor use
cases which we'll describe here, but they represent only a tiny fraction of
their ultimate potential.

Tlon recently launched a survey bot called [Eliza](/blog/eliza), which was
initially a comet. We frequently got questions on whether Eliza was actually
Tlon's bot, because it could just as easily be a malicious actor posing as Tlon.
We soon plan to relaunch Eliza as a moon of `~zod`, which is the most
recognizable official galaxy of Tlon. This is to establish that the bot is
indeed official; only someone with access to `~zod` is capable of creating a
moon of `~zod`, and so a moon of `~zod` automatically carries with it a
cryptographic guarantee that you are communicating with an official digital
representative of Tlon. On Earth something like this would need to be
accomplished with certificate chains but, on Mars, this sort of authentication
is baked into the very fabric of the network, rather than as an additional layer
on top. This is a very good representative case of how moons naturally inherit
the reputation of their parent, even in the absence of any formal reputation
systems on Urbit.

We see folks using moons as backup identities in case they can't or don't want
to access their primary planet for one reason or another. Again, since anyone
may verify the parent of a moon, the moon inherits the reputation of its parent.
These backups could be vanity identities—for instance, every `~sampel-palnet`
has underneath it a moon named `~master-sampel-palnet`[^0].

Some use moons to host group(s). Hosting a group inevitably means that that ship
will process more network traffic, and a heavily trafficked group may impact a
ship's performance. Thus one may wish to offload group hosting duties to a moon
to maintain a more performant planet.

As we currently lack a real system for 3rd party software distribution (though
see this recent [developer call](https://youtu.be/XwICC6Its1E) on a solution in
progress), one stopgap has been to download software by syncing a foreign
[desk](/docs/glossary/desk) to your ship. This is risky, as buggy software
may make break your ship and make it difficult to get running properly again.
For this reason, testing new software on the livenet is frequently performed on
moons, so as not to risk the parent ship if something were to go wrong.

### Internet of Things

![telstar](https://media.urbit.org/site/posts/essays/telstar.jpg)

Now we start to look towards the future by examining the problems faced by IoT
in the present and speculating on how Urbit might solve them.

The Internet of Things is much maligned by technologists as a privacy, security,
and maintenance nightmare. These products usually depend on phoning home to
perform their service, which is inevitably a funnel by which personal data is
harvested, an attack surface for hackers to gain access to your home network,
and a single point of failure which may render the device useless, all in one!
One need look no further than the recent [Ubiquiti
breach](https://krebsonsecurity.com/2021/03/whistleblower-ubiquiti-breach-catastrophic/)
to see all of these failure modes happening on a massive scale, and this is par
for the course. This sort of dynamic is completely antithetical to the Urbit
philosophy, so any involvement of Urbit with IoT will reject many fundamental
assumptions on how IoT operates today.

However, it's important to understand why the current IoT model works like this
at all. We posit that it ultimately stems from the fact that today's IoT
products are primitive moons for which you do not operate the parent planet.
Almost every IoT device operates in the Software as a Service (SaaS) paradigm
because most people don't have personal servers that could do all the processing
work actually necessary for an IoT device to operate. This is not the _only_
reason for this—it's also just more profitable to collect consumer data.
However, it's the SaaS aspects which make the whole thing such a catastrophic
mess.

Imagine a different world: if the server that your device reports to is your
own, there is no loss of control over personal data. If the device only
communicates on the local network, it will prevent remote hackers and disruption
if you internet fails. And if the manufacturer goes out of business, the device
will still work-it is not dependent on the manufacturer's servers.

The wants and needs of the individual are at odds with the wants and needs of
the megacorp, and that mismatch manifests as the antifeatures that plague IoT.
By eliminating the SaaS aspect, Urbit solves many of the largest outstanding
issues with IoT in a single blow. Digital personal AI assistants have long been
an anticipated science fiction prediction and their full realization is on the
horizon. But in their current manifestation, many privacy- and
security-conscious people would never consider using them at all, since they are
inevitably presented as SaaS that requires intimate knowledge of your devices
and their stored data. Recommendation engines such as the one used by YouTube
offer helpful guidance towards content you'll find appealing, but they're also
designed to keep you hooked to the service. These kinds of programs can be
useful, but they're dystopian when they come saddled with anti-consumer
subroutines. Since your Urbit belongs to you, it can never act against your own
interests without your consent. In our lunar vision, your digital personal AI
assistant will live on one of your moons, rather than on megacorp's cloud.

For web-exposed devices, Urbit offers the same security guarantees that it
offers for your personal computer: everything is end-to-end encrypted by
default, and signed with keys that one can easily verify as belonging to the
node sending the message.

[Vint Cerf](https://en.wikipedia.org/wiki/Vint_Cerf) has outlined the case for a
system like Urbit ID for IoT use
[here](https://cacm.acm.org/magazines/2018/12/232883-self-authenticating-identifiers/fulltext).
In brief, that the Urbit ID system allows one to match public keys with devices,
bestowing devices with self-authenticating identities. This allows one to trust
the communications received from the device to whatever degree the private key
is held secure. IP addresses, GPS coordinates, MAC addresses, etc., are not
sufficient to generate high levels of trust—they're all temporary, easily
spoofed, or both.

> One might imagine applying this to the Internet of Things (IOT) in which the
> IOT device self-generates a public- and private-key pair and registers the
> public key. For example, with a hub or controller so the hub can confirm it
> has reached the right IOT device. By the same token, configuration of the IOT
> device into an ensemble could include incorporation of the public key of the
> controller into a list of valid devices that can command or obtain data from
> the now-configured IOT device. Both ends can verify they are talking to the
> originally configured devices, assuming no device has lost its private key.

Here, the hub or controller referred to would be your planet.

Urbit has many other features that make it well-suited for IoT, above and beyond
eliminating the SaaS model and providing self-authenticating identities. Many of
these additional advantages derive from the fact that Urbit is a [solid state
interpreter](/docs/arvo/overview#solid-state-interpreter) and that
[Ames](/docs/glossary/ames) is a network of solid-state interpreters
equipped with cryptographic identity. We explore this in the next section.

### Future lunar cosmotechnics

![farm](https://media.urbit.org/site/posts/essays/farm.jpg)

We now polish off the old crystal ball and imagine future uses of Martian lunar
technology. Particularly, how the tech may develop over time once it becomes
widely exposed to the evolution-inducing forces of industry and culture. This
section is pure speculation, and I only aim to offer a small glimpse of a
potential future, rather than an exhaustive one. This picture will necessarily
be biased by my personal proclivities and expertise, or lack thereof.

Any discussion on the future of moons is incomplete without mentioning the
possibility of [lunar emancipation](https://urbit.org/faq/#more-planets) in
order to increase the number of planets. This fascinating topic sees regular
discussion in the Urbit Community group, but is outside the scope of this
article.

In order to respect the reader's time, I'm narrowing our scope to a particular
topic: the agriculture industry. I'm also assuming a future with specialized and
increasingly small hardware to run Urbit. Right now, a 4 GB Raspberry Pi is the
standard for "small Urbit". If someday there are CPUs specifically designed for
running [Nock](/docs/glossary/nock), one could imagine going much smaller.
Ultimately, I'm going to assume that there will someday be [solid-state
interpreter](#ssi) microcontrollers - so the inclusion of Urbit on a device may
require nothing more than a couple [surface-mount
devices](https://en.wikipedia.org/wiki/Surface-mount_technology) on a larger
chip.

Urbit is intended first and foremost as a personal computer. When I unravel its
potential usage in industry, I adopt the forecast of a drastic increase in the
manufacturing capacity for individuals and small groups. Agriculture is a great
microcosm of this long-standing trend; less human input is needed to produce the
same amount of food, whether it be crops or livestock. The modern era is
distinguished by the fact that small numbers of people can manage enormous farms
which produce food for vast populations. Thus, computation on modern automated
farms may be thought of as existing at the intersection of both personal and
industrial scale, and show how computerized and mechanized workflows add to the
amazing productivity of modern farms and demonstrate that individual-sized
inputs are able to create industrial-sized outputs. I predict that the set of
trades for which this dynamic holds will only increase over time.

Agricultural automation has been a primary engine for the growth of
civilization, but it has been hampered by the downsides of IoT elaborated in the
previous section. One bellwether of this dynamic is the right to repair one's
own equipment. [John
Deere](https://www.thetruthaboutcars.com/2020/03/its-payback-time-right-to-repair-movement-targets-john-deere/)
has long been at the center of this controversy. Farmers have lost the ability
to repair their own equipment due to vendor locks and a dependency on remote
servers. Furthermore, any suite of sensor products designed to gather important
data such as genomics, hydrology, soil health, weather, etc., inevitably only
cooperate with other products by the same vendor. It's the same story all over
again—you are a client of a megacorp server. Or in Urbit terms, you have a bunch
of primitive moons belonging to different planets held by megacorps, and no
planet to call your own.

Again, Urbit resolves these issues in the same fashion as above. One might argue
that using Urbit is another form of vendor lock-in—but this is evaluating Urbit
at the incorrect level. Since Urbit is an open source operating system, its
functionality may be extended and modified arbitrarily by any party. _Some_
computational infrastructure is necessary— that fact can never be escaped. But
you can escape from closed source software that does not permit you to modify,
to open source software that allows you to tinker at will. Thus we do not
consider open source software to be a form of lock-in, or at least, it's a much
milder form of lock-in compared to something like Apple's walled garden.

So let us focus on the additional meritorious aspects of Urbit (or more
generally, solid state interpreter networks) that make it not merely a band-aid
to the broken IoT system but a permanent and sound replacement.

#### Solid state interpreter networks {#ssi}

![cubesats](https://media.urbit.org/site/posts/essays/cubesats.jpg)

Urbit is the world's first solid-state interpreter (SSI). This concept is
summarized in the [white paper](https://media.urbit.org/whitepaper.pdf) as
follows:

> Imagine it as a chip. Plug this chip into power and network; packets go in and
> out, sometimes changing its state. The chip never loses data and has no
> concept of a reboot; every packet is an ACID transaction.

Also,

> Briefly, an SSI is an interpreter which is also a database. In more depth, an
> SSI combines three properties: uniform persistence, source independent packet
> networking, and high-level determinism.

We do not wish to segue into a lengthy examination of what this really means—
that's what the white paper is for—but we will attempt to explain why these
properties are of great benefit in an industrial IoT context such as
agriculture. We'd also like to predict that Urbit will not be the only SSI.
Other sorts of SSI's specialized to various tasks may one day roam the planet,
and these may be better suited for particular IoT tasks than
[Arvo](/docs/glossary/arvo). However, this article will be couched in terms
of SSIs communicating with an [Ames](/docs/glossary/ames)-like networking
protocol and Urbit ID-style cryptographic identity, rather than Urbit in
particular.

For a SSI, losing power is less of a catastrophic event than it is for ordinary
computers with volatile memory. Knowing that you can never lose any state is a
powerful guarantee on the integrity of your data. Loss of power will always mean
loss of any data potentially collected while power is down, regardless of the
device you use, but with a SSI you at least have assurance that you will never
lose data that was collected before it could be transferred from the cache to
the disk. Of course, this is actually the sort of guarantee that [ACID
transactions](https://urbit.org/docs/arvo/overview/#acid-database) have—it is
just that this set of guarantees emerges naturally as a consequence when you
have a SSI. Put another way, every SSI is a database; having every device be a
database is a major boon in situations where enormous quantities of data are
being collected across a distributed network. The standard today is that data is
only collected at hubs, and any data that doesn't reach a hub is irretrievably
lost.

SSIs are also deterministic at a high level. While all computers are
deterministic at the CPU level, interruptions to power can result in an
undefined semantic state and result in the random erasure of half of its brain.
This determinism is what begets ease of maintainability of Urbit—problems
generally only need to be solved once by experts and the solution propagates to
the rest of the network via [OTA updates](/docs/glossary/ota-updates). We
addressed this maintenance issue previously—we only remark now that this
property is derived from being a SSI, rather than something particular only to
Arvo or Urbit. When one has hundreds or thousands of devices to manage, the
guarantees on ease of maintenance provided by determinism are extraordinarily
convenient.

Packet routing on SSI networks is source-independent, and in the context of an
Ames-like networking protocol, are always delivered exactly once and in a
precise order due to the fact that nodes on an Ames network are in a permanent
session. Source-independent means that the identity that originated a packet
does not need to be the one to deliver it—packets are _facts_, and the truth of
a fact does not depend on who you heard it from. This means that it is possible,
for instance, to send instructions to a moon before it even exists and be
guaranteed that that moon will receive them and perform the tasks given, even if
the device that originally sent the packets no longer exists. As long as
somebody has kept the packets on hand, they will eventually be delivered. So,
one could imagine transmitting directions to a crop harvesting robot into which
a moon will be installed before the robot has even been purchased, know that
once it is delivered it will automatically begin its task, and know that those
tasks will be completed in the correct order, without any accidental repeats.
Taken to the limit, one can imagine preplanning the automated tasks for an
entire farm before a single device is purchased, with powerful guarantees on the
integrity of those instructions no matter how much time elapses between sending
and receiving.

#### P2P data markets

![knots](https://media.urbit.org/site/posts/essays/knots.jpeg)

As was mentioned above, today's IoT devices ferry all sorts of your personal
data to megacorp, where they package it and sell it to the highest bidder.
Though personal data in aggregate is quite valuable, the value of a single
individual's data is quite low. On the other hand, industrial scale data such as
that collected on digitized farms could be quite valuable. Here we briefly
examine how Urbit can be utilized to populate and facilitate a market for data.

All data collected by your moons may be digitally signed by that moon,
certifying the exact origin of that data. This is one advantage of having
cryptographic identity baked into the core of the operating system and
networking protocol. One could imagine collecting large amounts of such data and
packaging it for exchange with other local and regional farmers. This can, of
course, already be done in principle with current systems. But current systems
do not automatically come equipped with the sort of provenance, immutability,
and reputation that comes for free when you make use of SSI networks.
Manipulated or faked data becomes easier to spot, and you'll know who it came
from, so supplying such data puts one's reputation at stake.

One major issue facing conjoining data gathered from disparate sources is simply
how to do it. Data arriving in random order, from different software versions,
running different hardware, is all very difficult to bundle into a good
dataset - and indeed wrangling this sort of task forms a large part of the data
scientist profession. As devices in SSI networks utilizing an Ames-like protocol
are engaged in permanent sessions, leading to properties such as exactly-once
delivery and well-ordered message sequences, issues about the order in which
data arrives are dramatically simplified. I do not wish to get mathematical
here, but I personally have confidence that the emerging discipline of
[categorical informatics](http://math.mit.edu/~dspivak/informatics/), as well as
the relevance of [low-dimensional topology to data
fusion](https://arxiv.org/abs/1409.5505), resolves many of these issues. I
promise to explain this in more detail in the future. For now, it suffices to
say that SSI networks seem well-positioned to utilize these techniques.

Cryptographic techniques such as [(composable) zero-knowledge
proofs](https://en.wikipedia.org/wiki/Zero-knowledge_proof), [secure multi-party
computation](https://en.wikipedia.org/wiki/Secure_multi-party_computation),
[ring signatures](https://en.wikipedia.org/wiki/Ring_signature), and even
[homomorphic encryption](https://en.wikipedia.org/wiki/Homomorphic_encryption)
offer a variety of ways in which data may be shared in an IoT context with
mathematical guarantees on what sort of privacy is maintained. This is perhaps
less relevant in the context of agricultural IoT, where personal private data is
largely absent, but we mention them here to invite further speculation from the
reader about the possibilities of IoT and SSI networks.

We end our discussion with an adaptation of a scenario borrowed from my brief
time working on [Ceptr](http://ceptr.org/) that begins to show how a lunar
IoT-connected world evokes properties of a hypothetical ["global nervous
system"](https://en.wikipedia.org/wiki/Global_brain). This example is
purposefully mundane to illustrate how deficient our Earth systems are, and
while it is possible to accomplish in theory, it is impractical on a wide scale
due to the numerous problems with IoT. Imagine that you suffer headaches from
low atmospheric pressure. You'd like to know when a low-pressure front is an
hour away from you so that you can pre-emptively take aspirin to prevent the
headache. Your personal digital assistant, running on Urbit, can then
periodically query the moons of sensors in your region for weather data to
predict whether or not you will soon be passing through a low pressure front.
This could be a free service or paid for automatically with cryptocurrency
microtransactions. On Mars, this task will be trivial, and is merely a stone's
throw away from a vast and undiscovered universe of other possibilities unlocked
by SSI networks.

[^0]:
    Of course, all moon names have four words, not three. What the fourth word
    needs to be for only three words to display is a matter of Urbit lore that
    is more fun to discover yourself than have it told to you, so we won't spoil
    it here.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Interplanetary Commerce]]></title>
            <link>https://urbit.org/blog/interplanetary_commerce</link>
            <guid>https://urbit.org/blog/interplanetary_commerce</guid>
            <pubDate>Thu, 08 Apr 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![ocean](https://media.urbit.org/site/posts/essays/ocean.jpeg)

<br>

## Paying

A year ago, we started [integrating](https://urbit.org/blog/urbit-and-bitcoin/) Bitcoin into Urbit to be an OS-level primitive for money. Our initial objective: build a payments wallet, equally sovereign and ergonomic. The first public version, releasing this month, will have a broad set of capabilities including ship-to-ship payments, hardware wallet support, and full node integration. We’ll be unveiling this wallet on [April 27th](https://www.meetup.com/urbit-sf/events/276741426/). Do join us.

Things only accelerate from here. Our next objective, to integrate Lightning Network capability, is now an [active bounty](https://gist.github.com/timlucmiptev/53ef1d290e55ea2fa25d9df681c32695) and open for applicants. Early on, we [recognized](https://www.youtube.com/watch?v=DTvRVHMbrcY) the congruence and compatibility between the Urbit and Lightning networks. Routing Lightning payments is an obvious business model for Urbit providers, one that can even nucleate new features onto Lightning itself. What we’re ultimately driving at is fully-sovereign Bitcoin usage, with the UX of the Cash App.

## Being Paid

> And there is all the difference in the world between paying and being paid. The act of paying is perhaps the most uncomfortable infliction that the two orchard thieves entailed upon us. But being paid,—what will compare with it?
>
> <cite>Herman Melville</cite>

However, a good wallet is only half the equation for a holistic P2P commercial experience. Interfaces for selling goods and services is the other half. While we don’t part with our Bitcoin [easily](https://nakamotoinstitute.org/mempool/everyones-a-scammer/), two initial markets appear logical and attractive: content and Urbit-native services.

First, digital cottage industry, the “creator economy”, is blossoming. Streaming, podcasting, and writing on platforms like Youtube, Patreon, and Substack has been big business [lately](https://otherlife.co/barbarians-past-the-gate/). What fintech did to “unbundle the banks", we will now do to media monopolies and their centralized distribution platforms. With the introduction of Urbit payments, you can syndicate, distribute, and monetize your media on Urbit. By selling access to a private group containing content, digital creatives can begin doing this today.

Second, Urbit-native [service providers](https://urbit.org/blog/providers/) are now operating at scale. Companies offering Urbit hosting, onboarding, Urbit IDs, and software now communicate with their customers directly on the network. A basic set of commercial tools will make their processes more efficient. Storefront interfaces, paywalls, CRM, and reputation tools will replace the ad-hoc assemblages they currently use.

The Urbit Foundation is soliciting contributors to this project through Urbit Grants. If you’re interested in working on any of these components [send us a proposal](https://grants.urbit.org/create).

## An Ocean

After honing our commercial tools on these use-cases, we’ll sail into a blue ocean. On the horizon: beautiful products, deployable at scale, built with the robust primitives of Urbit OS. Extensibility is Urbit’s promise to middle-men: every Web2.0 service they use to scalp us will find its P2P analog on Urbit. We invite developers and entrepreneurs of all stripes to join in the feeding frenzy. Ideas are constantly nucleating in <a href="web+urbitgraph://group/~pindet-timmut/urbitcoin-cash">Urbitcoiners</a> and <a href="web+urbitgraph://group/~bitbet-bolbel/urbit-community/graph/~darrux-landes/business-building-on-urbit">Urbit Community</a>.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from urbit.org and Tlon]]></title>
            <link>https://urbit.org/updates/2021-04-01-update</link>
            <guid>https://urbit.org/updates/2021-04-01-update</guid>
            <pubDate>Wed, 31 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Hello!

Happy Spring from ~wolref-podlex and ~roslet-tanner. We’re here with a surprise joint Urbit-Tlon newsletter—we’ve been so busy producing content that we forgot to write about it. Plus, this is fun every now and then. Honestly, we have so much to talk about this month, we can’t cover it all without writing a book. Here are the highlights.

1 - Events

April is shaping up to be jam-packed with events. For starters, we’ve got three developer calls slated for April, all of which are on Thursdays at 9am PDT:

4/1: Tyler Shuster (~radbur-sivmus) discussed Javascript apps on Urbit: https://www.meetup.com/urbit-sf/events/277261928/

4/15: Raghu (~sovmep-ripsum) will talk about virtual desks, a key component of third-party software distribution, and the process of contributing to the Urbit kernel through our scholarships program.

4/29: Edward Amsden (~ritpub-sipsyl) will be discussing and demoing his WebRTC work, which enables audio/video calls on Urbit.

On April 27th, we’ll be launching our Bitcoin Wallet and preparing to roll it out to the network. This is the culmination of many months of collaboration between several members of our community and Tlon—we’re really excited (especially ~pindet-timmut). There might even be some cool swag, discounted hosting, and/or other giveaways. Regardless, you’re not going to want to miss it. RSVP here: https://www.meetup.com/urbit-sf/events/276741426/

We’re also excited to announce that our much anticipated Town Hall event, a virtual mini-conference, will be taking place on May 20th and will feature a keynote talk from our good friend Justin Murphy. Mark your calendars for now—more details to follow soon.

2 - Content

There’s been a ton of high-quality content produced lately. If you’re looking for something to watch, read, or listen to, here’s a roundup:

~rovnys-ricfer has been recording an audio series about the design and rationale of Urbit called “Urbit from the Outside In.” Check them out here: https://twitter.com/rovnys/status/1371972157971050499

~pindet-timmut and ~wolref-podlex appeared on Justin Murphy’s Other Life podcast—check them out: https://www.youtube.com/watch?v=vv9lymudGV8 and https://www.youtube.com/watch?v=5jbjSUKRyGM

A question was posed on our mailing list titled: “what is this?” The team and community did not disappoint with their answers: https://groups.google.com/a/urbit.org/g/dev/c/bdlPPnaccMc

Simon Kovacs (~bacbec-lormur) wrote a great post for our blog titled “After the Machine War”: https://urbit.org/blog/after-machine-war/

~poldec-tonteg talked to the guys at The Stack. Check out the podcast here: https://thestack.link/episode-13-martian-futurism-with-poldec-tonteg/

3 - Documentation refresh

Our Docs team completed a large overhaul of our documentation last month, making the distinction between “Usage documentation” (https://urbit.org/using), or how to use your ship, and “Development documentation” (https://urbit.org/docs) much clearer.

We’ve had some excellent contributions from the community to our documentation, most recently a comprehensive set of overviews, guides and examples documenting threads from ~tinnus-napbus: https://urbit.org/docs/userspace/threads/overview/

We’re pretty proud of the work that’s gone into clarifying everything and are still working hard to make the docs more and more helpful. Feel free to send us your feedback if you have any!

4 - Landscape news

The community on Landscape is continuing to grow. Over 30 groups were published to the Directory in March alone, and these are just the public groups that someone decided to broadcast. We think that’s pretty exciting.
There’s a new Cincinnati-centric group (~padwet/queen-city-urbit), a sewing group that sounds incredible (~pinwyl-hasfeb/seamstress-mafia), and the first digital maker space on Urbit (~tidrel-tabpub/freeside-mars).

Check out the Directory (~bollug-worlus/urbit-index) to discover public groups and, if you’d like help getting your community onto Landscape, let us know. We’re here to help!

5 - Hosting

Over at Tlon, we’ve been really busy onboarding new hosting customers. All of our current onboarding sessions are completely booked! If you’d like to learn more about how it works, send an email to support@tlon.io. If you’re ready to get on the list, sign up at https://tlon.io/

6 - Team news

We're happy to share that longtime hooner ~littel-wolfur has joined the Tlon engineering team. Welcome, ~littel-wolfur! Also, we’ve made it official with ~wolref-podlex and dropped the “Interim” from “Director of urbit.org” (probably due to the quality of these newsletters).

If you’re interested in working with Tlon or urbit.org, feel free to get in touch.

7 - Culture recs

Finally, we’re going to leave you with some recommendations from the team:

~fabled-faster released an insane new mix that melted my face in a good way: https://soundcloud.com/flowerstructure/fs-s-s-2021

Our designer ~natnex-ronret curates a playlist website. Check it out: https://www.door.link
~datnut-pollen has been trying to understand how information processing evolves over time in evolutive systems. Here’s what he’s been reading:

(i) Connectom https://connectom.substack.com/p/connectom-the-book It is about thermodynamic/statistical mechanical processes as the fundamental driver of the evolution of biological, ecological, and human systems.
(ii) Topological phases emerge in an ecological model: https://physicstoday.scitation.org/do/10.1063/PT.6.1.20210128a/full/ and Topology protects chiral edge currents in stochastic systems: https://arxiv.org/abs/2010.02845 Topological protection for various dynamics is the main theme he reckons is missing from Connectom.
(iii) Homotopy theoretic and categorical models of neural information networks https://arxiv.org/abs/2006.15136 Topological techniques for understanding information processing in neural, metabolic, societal, and computational contexts.

~simfur-ritwed recently re-read Pynchon's Vineland. It’s both a loom into the backwoods NorCal culture of the 80s and a typically Pynchonian fantasy about the dangers of media-saturated identity (quite prescient, turns out).

In the wake of his recent trip to Brazil, ~wolref-podlex has been reading Os Sertões (the English version), the story of a war that took place at the end of the 19th century in the backlands (sertões) of Brazil, in which the Brazilian army brutally crushed the peaceful religious settlement of Canudos.

Lately I (~roslet-tanner) have been getting back into Roy Ayers. This feels just right for spring: https://www.youtube.com/watch?v=inPgcN_xF4w

That’s it for now. We’ll be back with more news from Tlon and Urbit, respectively, in a few weeks. As always, let us know if there’s anything in particular you’d like to hear about next time.

~wolref-podlex and ~roslet-tanner
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[After the Machine War]]></title>
            <link>https://urbit.org/blog/after-machine-war</link>
            <guid>https://urbit.org/blog/after-machine-war</guid>
            <pubDate>Sun, 14 Mar 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![berlin-wall](https://storage.googleapis.com/media.urbit.org/site/posts/essays/berlin-wall.jpeg)

<br>

> The following fictional passage, from a book being written in an Urbit Group called “the Aleph,” sketches out a dismal future for the human race. As an item of speculative fiction, the piece is not what one might call original. Anyone could have come up with these ideas. In fact, several already have. The Matrix is an obvious antecedent. Vonnegut isn’t far behind either. And the treacly humanism lodged beneath the bitter humor resembles nothing so much as the work of that beau monde satirist, George Saunders.
>
> Really the only notable thing about it is that it was written on Urbit. And that, perhaps, has made all the difference.
>
> It’s easy to be pessimistic about the future. Intellectuals, especially, are drawn to pessimism, because pessimism (falsely) implies a greater wealth of knowledge about the ways of the world. But one thing the pessimist never sees coming is a turn for the better. To wit, the future described in the below excerpt doesn’t have to take place. And Urbit is one piece of evidence for the claim that it will not.
>
> The philosopher-cum-internet comedian Slavoj Zizek likes to point out that no one was really expecting the Soviet Union to collapse in 1989. In fact, the average Soviet dissident wasn’t even gunning for it. He was haggling over small reforms, pushing to get the less corrupt politicians to the top, just going about his day eating or opening a window or walking dully along. Then, kaboom. Collapse. No more USSR.
>
> Then as now, the unexpected is more likely to occur than most would believe. One thing is not only possible, but an established fact: A brand new digital infrastructure is slowly, quietly being built. While U.S. political parties haggle over $1,400 disbursements for citizens, the rules of global finance are being re-written in code. While pundits debate the merits of Dr. Seuss’s lesser known titles, a global shift away from traditional publishing is gaining steam. And while users and social apps themselves pop up and down like whack-a-mole, folks are putting down roots with permanent peer-to-peer digital identities. If you’re anything like an optimist, you’ll probably want to get on Urbit ASAP and put down your own.

<br>

The date is January 1, 2050. The place, New York City. The vibe...subdued. Back in 2020, you made a note to yourself to take stock of the world around you here at the half-century mark. And now the time has come. What do you find? The air quality is a bit worse, the bad parts of town are a bit more dilapidated, the Knicks are still terrible—all in all, from the outside at least, not much has changed from 30 years ago. Today you wake up groggy on your self-adjusting Smart Bed (Smart Bed Never Sleeps), you make yourself a steaming pot of coffee (locally sourced, delivered within the half-hour by a drone, now that you’ve got Titicaca Prime), you shower and get ready for work.

But what was that dream you had last night? Only the faintest traces of it remain. A luminous rainbow, a mountain landscape, a sense of profound inner peace, mixed with euphoria, mixed with...an intense desire to go out and buy some Health Morsels cereal?

That’s odd. You’ve never even had Health Morsels. You open up your laptop, where you can view the activity of the iThink microchip that you got implanted in your cortex a few years ago. “Ads help Elysium provide you with free, quality sleep-monitoring. To disable ads, please upgrade to Elysium Premium.” That explains it. After all—and you pause for a moment over whether the forthcoming thought is yours or the iThink’s, before deciding that it’s much the same anyway—Health Morsels probably are delicious. And healthy, too.

As usual, they’re setting something on fire outside your home. Normally you’d scroll back through your Squawker feed to see what it was all about, but today you’re late for work, and anyway you’re in a pleasant haze after the Health Morsels dream—no point ruining it by poring over the latest Squawker pile-on. You glance at the awning. Ah, the bodega. Toilet paper and Juul Pods are cheaper in bulk from Titicaca anyway.

Another day at the office. You were never exactly passionate about content moderation, but hey, it keeps the lights on. (And since ConEd got absorbed by Titicaca, it’s been pretty important to have a Verified Income Stream.) It’s a normal day at work. Algorithms haven’t yet been able to filter out all Unverified Content—so it’s up to you the flag Unacceptable Violence, Disputed Claims, and Unfederated Currency transactions.

Except after your pleasant dream, it all suddenly seems so drab. You start to wonder whether there was an error last night—maybe they turned the dream levels up too high. Something from your night-time vision just won’t leave your mind, like a film strip looping over and over. It’s that river beside a sloping field, like you used to swim in when you were a kid. You can almost feel the icy cold against your skin, the sticks and mud against the soles of your feet, and then there’s the ripe, marshy scent of the riverbed. Uh oh. You realize you’re close to danger levels. This isn’t where your head’s supposed to be at. Frantically you scroll through content, seeking to moderate it. A user threatening violence against Titicaca. A stream that violates DMCA. A highly dubious Squawker claim, with no support from experts. Flagged. Flagged. Flagged.

Yet the river remains. You see it, you feel it, just as you feel the kiss of the sun on your shoulders, the breeze rustling through your damp hair.

Now you know what’s coming. You brace for it and wait. Three. Two. One. ZAP. Your iThink produces an electric shock: plenty painful but not permanently damaging—at least that’s what the Verified studies show. The river recedes from your mind. Following the shock, your iThink, as versatile a little machine as ever was invented, delivers a few milligrams of both amphetamine and oxycodone, bringing on a wonderful feeling of simultaneous alertness and relaxation. You look up at your monitor. Content moderation doesn’t seem so bad, with the stimulant and the barbiturate swirling paradoxically through your system. It’s true what they say in the ads: iThink doesn’t just make you think better, it makes you feel better. You dive back into your content moderation with renewed verve, even flagging a couple completely innocent posts just out of surplus exuberance. So what if you hardly get outside at all these days, so what if you’ll never swim in that stupid river. The fastest electronics, the Your Health and Wellbeing tracked and adjusted by an intelligence far greater than that which you could ever hope to possess, a gizmo that gives a whole new meaning to the term neural net.

2050 turned out to be a pretty good year after all.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Eliza]]></title>
            <link>https://urbit.org/blog/eliza</link>
            <guid>https://urbit.org/blog/eliza</guid>
            <pubDate>Mon, 22 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![valleys](https://media.urbit.org/site/posts/essays/valleys.jpg)

<br>

## The Storm before the Calm

Building things, even Calm™ things, makes noise. George Nakashima’s wooden furniture evokes peace, but its construction still begins with a chainsaw. We mention this because we’re firing up our newest power tool.

We call her Eliza. She is a data-collection robot.

Hang on. An AI? Harvesting my data? Spying on me? Flooding me with spam? This is Urbit, right? Let us tell you about our new friend in basic terms, where MEGACORP might otherwise deploy legalese.

## What Eliza is and isn’t

> Replicants are like any other machine - they're either a benefit or a hazard. If they're a benefit, it's not my problem.
>
> <cite>Rick Deckard</cite>

Let's start with the benefits. Eliza is a simple chatbot. She was made to collect feedback on Landscape. She asks direct questions about peoples' usage of Urbit, records any responses, and reports them to her managers at Tlon. She'll also provide timely advice and information to ships kind enough to chat with her. She'll begin reaching out to ships via DM in the coming month. If you don't want to, just say no, and you'll never hear from her again.

Finding bugs is critical to Urbit's rapid development, especially in this period of nascency. Most Urbit-related frustrations go unreported; regular folks don't think to open up Github when they experience a minor issue. That's why it's incumbent upon us to design a lower-friction forum for feedback. People who aren't comfortable filing an issue might be willing to talk to a friendly chatbot.

Now, about hazards. By design, there are few. Eliza runs on Tlon's comet, not on your planet. There will be no OTA to install `%eliza-bot-store` on everyone's ships. Eliza learns things through conversation, not hidden surveillance software. Data she requests, like the text output of our network analytic tool, `+tally`, must be sent manually. MEGACORP tends to cut this corner; to refine their products, they just track your reactions in real-time.

Since she's [open-source](https://github.com/urbit/urbit/blob/b0c1f83287cbf4c85847a9238d9f4be17e1fcb33/pkg/arvo/app/eliza.hoon), anyone can creatively deploy Eliza. Just write her a dialogue tree. Of course, that also means we can't keep people from misusing Urbit bots. We think automated agents on the Urbit network are inevitable, so let's create a good baseline culture around them. (Much love to Tendiebot, who's serving up stock prices in `~tomdys/wall-star-bets`.) However, once Urbit is used world-wide, we can't rely on culture alone.

## A New Internet Economics

The sum of Urbit's architectural design is a new online economics: a way to finance and monetize access to internet infrastructure where people retain maximum equity. Explicitly acquire a low-maintenance, low-cost server. Use it to compute explicit things. Return to life.

We all know the basic MEGACORP business model: offer a free service (to suckers who don't own a server), secretly mine the data they generate on the (addictive) platform, then sell targeted ads to advertisers. This model will not survive Urbit. The ubiquitous personal server changes the economic equation. You used to 'pay' for an experience with your time and data. On Urbit, once you purchase core internet infrastructure, it's yours.

So, can Urbit meaningfully curtail our world's appetite for data? We'll see. Post-enlightenment society runs on instrumental reason, right down to the last byte. Marketers will always want a fresh dataset. However, when the goods are on your Urbit, you can at least demand the respect you deserve. Long term, we expect a transparent market for data, not an opaque "agreement". An analytics company wants to track everything you see and do on Urbit? They better be paying well.

Eliza doesn't pay respondents. Her collection is a charity to Urbit's developers. (We're also still busy enabling payments on Urbit with the Bitcoin wallet.) However, her presence is not a term of service either. In a few years, by the nth time some smart aleck uses Eliza's chatbot code and conjures 'Zalexa' to attempt an intrusion upon your Calm™, we will see the economics of Urbit's architecture suddenly vivify. Blacklists, reputation systems, and, eventually, even data markets, all Urbit primitives envisioned long ago, will become real. We won't need Zoogle to underwrite a spam filter for the entire internet; the scarcity of Urbit address space, in tandem with a true web-of-trust, handles that.

If Urbit is to be used worldwide, the old system will not go down without a fight. Spammers, spies, and digital robber-barons will hunt for ways to game Urbit. Our passage out of the digital gutter is beginning in earnest, and we are thrilled to put our new architectures to the test.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from urbit.org]]></title>
            <link>https://urbit.org/updates/2021-02-19-update</link>
            <guid>https://urbit.org/updates/2021-02-19-update</guid>
            <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Hello!

This week we’re introducing our newest grants program, Scholarships, sharing an update on the Urbit community, and introducing the newest members of the Urbit Foundation team. We’ve also got some important infrastructure updates about King Haskell and an overhaul of our Getting Started guide. Let’s dive in:

1 - Scholarships

I’m excited to announce the (soft) launch of a new type of grant we’re calling “Scholarships.” The big idea behind the program is to grow the base of individuals that can contribute to Urbit through hands-on, one-to-one mentorship with infrastructure engineers at Tlon.

The program works by first having an infrastructure engineer define and scope a project, and then pairing them with someone from the community. Unlike other grants, these projects are centered on platform development, meaning Arvo or Vere, rather than on userspace development. Scholars will learn much about how Urbit works, take on impactful infrastructure projects, and gain insight into how infrastructure engineers think about building Urbit.

We’ve begun scholarships with two members of the Urbit community who have demonstrated high technical aptitude and commitment via grants or other open-source projects. We don’t have any additional openings at this time, but expect to have a few more in the coming months.

If you’re interested in a scholarship, sign up for the waitlist here: https://airtable.com/shr6Xmo55h8dZ0O46

2 - Community

Our community has been pretty busy lately. Here’s a non comprehensive list of what they’ve been up to:

- ~timluc-miptev completed the Bitcoin gall agents. They’re now being integrated into Landscape as a wallet.
- ~sovmep-ripsum finished his work on ucal, an iCalendar-compatible calendaring backend for Urbit.
- ~tabnus-fondeg began work on Urbit LFS (large file storage) for providing file sharing and hosting support.
- ~sipfyn-pidmex is writing a comprehensive suite of documentation for graph-store to enable an easier on-ramp to building new social applications.
- ~minder-folden launched a new hosting provider that you can check out here: https://escapepod.store
- ~naltyc-wornes is contributing a set of official, battle-tested guides for running Urbit on “smol” devices to the urbit.org website.
- ~hocdep-labtul hosted his first Urbit UTC meetup, which featured ~timluc-miptev and received great attendance. We’re looking forward to the next one featuring ~nartes-fasrum on the Aesthetics of Urbit. Learn more here: https://www.urbit.computer/utc/#upcoming-meetups

We’ll have a flurry of new bounties coming online in the upcoming weeks, so keep your eyes peeled —there might even still be an open one! Check them out here: https://grants.urbit.org/bounties.

If you’ve got an idea you’d like to work on, make sure to submit a proposal. you’re not quite sure how to get started, book some time with me here and I can help you figure it out: https://calendly.com/wolref

3 - Foundation growth

This month the Urbit Foundation grew by 200%, which is less astounding when you know that it grew from one person to three. Nonetheless, this is a significant milestone for the community-focused arm of Urbit.

~timluc-miptev (aka Tim) joins us from the developer community, where he’s been a prominent figure for some time as the creator of the popular Nock for Everyday Coders guide (https://blog.timlucmiptev.space/part1.html) and Complete Guide to Gall (https://github.com/timlucmiptev/gall-guide). He’s become a thoroughly proficient Hoon developer and Urbit architect through his work on Bitcoin integration, and will now be working to design grants and guide contributors in their development of their projects.

~taller-ravnut (aka Mike) is passionate about community formation, and is excited to start working on supporting those that wish to host Urbit Meetups in their cities, universities, and timezones (since, at time of writing, IRL isn’t much of a thing). He’ll also be performing outreach to developers and developer communities to help spread the word and grow the contributor base of Urbit.

There’s still tons of work to do and I don’t expect Tim and Mike to be the last additions to the team this year. If you’re interested in working at the UF, send me a DM for an invite to the group.

4 - King Haskell

King Haskell is a rewrite of the part of Urbit that talks to Unix and the outside world. When you switch to KH, the part of Urbit that runs Nock code stays the same. Importantly, King Haskell includes better facilities for NAT traversal, which should improve connectivity issues for self-hosted ships.

As its name suggests, King Haskell is written in the Haskell programming language. Haskell is much easier (and more fun) for rapid development than C, and lightyears better for writing correct, bug-free code. As a result, we expect faster iteration times and more reliability in this part of the system.

King Haskell is being shipped as part of a v1.2 release of the Urbit binaries. To run an existing ship with the King, say

./urbit-king run path/to/your/pier

To create a new ship, use the `urbit-king new` command.

If you run into any problems doing this, or notice any incompatible behavior, please inform the authorities immediately.

The Tlon Corporation is also using this new software on some of its infrastructure galaxies, but third party infrastructure ships should wait for further notice from us before doing so.

5 - Getting Started guide

Two members of our community have put a bunch of work into giving our Getting Started (formerly called Install + Setup) guide a facelift. They simplified the language, made the options much clearer, and improved some confusing instructions.

If you’re looking to try Urbit or know someone that would want to run it, give our guide a try and let us know what you think!

https://urbit.org/using/install/

--

That’s all for now. ~roslet-tanner will be in touch in a few weeks with an update from Tlon. See you on the network!
Josh / ~wolref-podlex

https://twitter.com/urbit
https://github.com/urbit/urbit
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[2020 -> 2021]]></title>
            <link>https://urbit.org/blog/2020-to-2021</link>
            <guid>https://urbit.org/blog/2020-to-2021</guid>
            <pubDate>Wed, 20 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![arch](https://media.urbit.org/site/posts/essays/arch-sunrise-2.jpeg)

<br>

In this post, which has been adapted from our most recent [newsletter](https://urbit.us11.list-manage.com/subscribe/post?u=972a03db9e0c6c25bb58de8c8&id=be143888d2), we'll take a moment to reflect on the events of the last year, and then turn our attention to the next one.

## 2020

In spite of the many challenges presented over the last year, it was a resoundingly good one for Urbit.

It seems like a long time ago now that the folks at Tlon rolled out OS1 (now called Landscape), just as the pandemic forced everyone into their homes throughout the world. At the time, [Urbit is for Communities"](https://urbit.org/blog/urbit-is-for-communities/) was just a vision, but now it’s been transformed into reality—there are more thriving communities in Landscape than any of us can keep track of, with new faces popping onto the network on a daily basis.

Landscape brought many new ships onto the network which helped identify those areas in which Urbit’s infrastructure could be most improved. [Ford Fusion](https://urbit.org/blog/ford-fusion/) eliminated the possibility of a partially-applied over-the-air (OTA) update through a drastic reduction in the size and complexity of the codebase. The efficiency of the OTA process was improved by several orders of magnitude, and many long-standing memory issues were resolved. Now we deploy code on our infrastructure nodes and see users receive an update, over a decentralized network, often in less than a minute.

After improving the stability of the system Tlon turned its attention to bringing more ships onto the network. A long-standing barrier to Urbit’s adoption has been the technical knowledge required to host one’s own ship—this prompted Tlon to build and launch an Urbit [hosting service](https://tlon.io), the waitlist for which is now thousands deep.

With Tlon becoming more singularly focused on building products on Urbit, concrete steps have been taken towards making urbit.org a separate organization that’s focused on long-term development of Urbit’s platform. I joined to [lead that effort](https://urbit.org/blog/first-steps-towards-urbit-org/) back in August and have since spent the majority of my time working with dozens of contributors on projects spanning documentation, education, external integrations, and much more.

We rounded out the year with a full network reset (called a “continuity breach”), which has in the past has been synonymous with loss of all data on the network. This time things went differently: tooling was made available to the community that allowed ships to preserve their data, which enabled most to seamlessly rejoin post-reset. This is a significant milestone for the project as it signifies not only a commitment to technical excellence, but to supporting our budding community.

## 2021

In the last three weeks we’ve seen a huge amount of inbound interest as people are waking up to the inherent problems with using centralized services run by MEGACORPs—we’re just happy we started working on Urbit all those years ago. While we tend to not plan more than about six months in advance, I can still talk at a high level about what urbit.org will be focusing on in the immediate future.

Growth in Urbit’s developer community has been growing organically in lockstep with the overall network growth. This means, happily, that there’s a pretty large pool of people eager to contribute to Urbit. The priority for urbit.org, therefore, is to improve its capacity to effectively assist contributors. In broad strokes, this means:

- Rework urbit.org to better help developers learn how to contribute to Urbit
- Since Urbit is ready to build on top of, provide practical guides that demonstrate how to do so
- Guide developers to make high-value contributions to Urbit and its ecosystem
- Build community amongst contributors

My strategy to date has been heavily focused on working directly with contributors to provide technical guidance and direction, and it’s been working really well. To that end I’ll also be scaling our ability to provide such support by bringing more individuals into urbit.org that can mentor, review work, and provide guidance on where to best direct contributors' energy.

2021 is shaping up to be a big year for Urbit, and we'd [love your help](https://grants.urbit.org) in building it. If you want to see what we're working on in real time, join us in Landscape at ~wolref-podlex/foundation.

See you on the network!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from urbit.org]]></title>
            <link>https://urbit.org/updates/2021-01-15-update</link>
            <guid>https://urbit.org/updates/2021-01-15-update</guid>
            <pubDate>Thu, 14 Jan 2021 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Hello, and happy new year!

As is customary for the first communication of the new year, I’ll be doing a retrospective of what was accomplished last year and a forward look at urbit.org’s priorities for next year. Make sure to read to the end for the details about our upcoming Town Hall event!

1 - 2020

In spite of the many challenges presented over the last year, it was a resoundingly good one for Urbit.

It seems like a long time ago now that the folks at Tlon rolled out OS1 (now called Landscape), just as the pandemic forced everyone into their homes throughout the world. At the time, “Urbit is for Communities” (https://urbit.org/blog/urbit-is-for-communities/) was just a vision, but now it’s been transformed into reality—there are more thriving communities in Landscape than any of us can keep track of, with new faces popping onto the network on a daily basis.

Landscape brought many new ships onto the network which helped identify those areas in which Urbit’s infrastructure could be most improved. Ford Fusion eliminated the possibility of a partially-applied over-the-air (OTA) update through a drastic reduction in the size and complexity of the codebase. The efficiency of the OTA process was improved by several orders of magnitude, and many long-standing memory issues were resolved. Now we deploy code on our infrastructure nodes and see users receive an update, over a decentralized network, often in less than a minute.

After improving the stability of the system Tlon turned its attention to bringing more ships onto the network. A long-standing barrier to Urbit’s adoption has been the technical knowledge required to host one’s own ship—this prompted Tlon to build and launch an Urbit hosting service (https://tlon.io), the waitlist for which is now thousands deep.

With Tlon becoming more singularly focused on building products on Urbit, concrete steps have been taken towards making urbit.org a separate organization that’s focused on long-term development of Urbit’s platform. I joined to lead that effort back in August (https://urbit.org/blog/first-steps-towards-urbit-org/) and have since spent the majority of my time working with dozens of contributors on projects spanning documentation, education, external integrations, and much more.

We rounded out the year with a full network reset (called a “continuity breach”), which has in the past has been synonymous with loss of all data on the network. This time things went differently: tooling was made available to the community that allowed ships to preserve their data, which enabled most to seamlessly rejoin post-reset. This is a significant milestone for the project as it signifies not only a commitment to technical excellence, but to supporting our budding community.

2 - 2021

In the last two weeks we’ve seen a huge amount of inbound interest as people are waking up to the inherent problems with using centralized services run by MEGACORPs—we’re just happy we started working on Urbit all those years ago. While we tend to not plan more than about six months in advance, I can still talk at a high level about what urbit.org will be focusing on in the immediate future (Tlon’s next newsletter will provide a similar overview of what they’re working on).

Growth in Urbit’s developer community has been growing organically in lockstep with the overall network growth. This means, happily, that there’s a pretty large pool of people eager to contribute to Urbit. The priority for urbit.org, therefore, is to improve its capacity to effectively assist contributors. Concretely, this means:

- Rework urbit.org to better help developers learn how to contribute to Urbit
- Since Urbit is ready to build on top of, provide practical guides that demonstrate how to do so
- Guide developers to make high-value contributions to Urbit and its ecosystem
- Build community amongst contributors

My strategy to date has been heavily focused on working directly with contributors to provide technical guidance and direction, and it’s been working really well. To that end, I’ll also be scaling the Foundation’s ability to provide such support by bringing more individuals into urbit.org that can mentor, review work, and provide guidance on where to best direct contributors’ energy.

If you’re interested in helping build Urbit, you can head over to https://grants.urbit.org to claim a bounty or submit a proposal, join the Landscape group ~wolref-podlex/foundation to stay in the loop about what urbit.org is up to, or contact me directly at josh@urbit.org.

3 - Town Hall

In mid-February, we’ll be holding our first ever “Town Hall” event—it’s like a developer call, but longer, with more speakers, and covering a wider range of topics (not all of them technical!).

We’re currently looking for speakers, so if you have an Urbit-related topic that you’d like to present, or would like to nominate someone else to present, please reach out to me by replying to this email. This could be an application you (or the nominee) has designed or built, an interesting use case, a design case study, or something completely different. Please don't be shy about reaching out—we're happy to work with you to figure out whether it makes sense to present a given topic, and how best to do so!

Once we’ve finalized a date, we’ll broadcast it over our official Meetup group (https://www.meetup.com/urbit-sf/) and on Twitter. Stay tuned.

--

As a reminder, Urbit and Tlon have now split their newsletters in two—Urbit’s newsletter will cover the project and development community, while Tlon’s will focus more on the product development work on Landscape and the communities that form there. Tlon’s newsletter will arrive at the end of the month.

That’s all for now. See you on the network!
Josh / ~wolref-podlex

https://twitter.com/urbit
https://github.com/urbit/urbit
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ames Security Audit and the Future of the Protocol]]></title>
            <link>https://urbit.org/blog/security-audit</link>
            <guid>https://urbit.org/blog/security-audit</guid>
            <pubDate>Thu, 17 Dec 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![audit](https://storage.googleapis.com/media.urbit.org/site/posts/essays/20201218-audit.png)

<br>

The security firm Leviathan has now finished their initial audit of the security of Urbit's Ames network protocol. In addition to their review of Ames, we also asked them to identify any other issues in order to help guide further development.

I'm pleased to report they confirmed the cryptographic soundness of the protocol, namely that "a ship must have possession of their own valid Urbit key in order to authenticate as that ship and to send valid Ames messages. Additionally, no other ship except the two communicating may be able to decrypt or modify messages during transport."

This means Ames uses cryptography in a mathematically sound manner that protects your privacy, keeps your secrets secret, and ensures nobody else will be able to impersonate you on the network. Since this was an architectural audit, it’s possible there are still vulnerabilities in the runtime implementation. Until the runtime has been hardened, Tlon continues to recommend against storing valuables in your ship.

Aside from a couple of minor issues that have already been resolved, there are three general classes of problem highlighted in their report that future work will need to address:

- Forward secrecy
- Protection against denial of service attacks
- Enforcement of social boundaries

Ames’ design allows for versioning of the protocol, which means that the proposed changes below can be deployed as over-the-air updates as they become more pressing concerns. This feature gives us confidence that we can address future security issues as they arise.

We will need to improve all of these over the next couple of years, as independent lines of work. As the network grows: better forward secrecy will decrease the damage from a key getting compromised; resistance against denial of service attacks will make the Urbit network resilient to increasingly determined saboteurs; and stricter enforcement of social boundaries will let Urbit’s social networks remain safe and friendly despite potentially increasingly large numbers of bad actors and increasingly complex app ecosystems.

## Forward Secrecy

A protocol is said to have forward secrecy if compromising a key used in a recent message doesn’t also compromise all previous messages. Similarly, a protocol is said to have backward secrecy -- also called future secrecy -- if compromising a key used in a previous message fails to compromise all future messages. Ames has some degree of both, but more would be better, to decrease the damage an attacker could inflict by compromising a key.

As it stands, an Urbit user can change their Ames keys whenever they want, by conducting an Ethereum transaction to update the Ames public key listed in the Azimuth contract, which implements Urbit’s PKI on Ethereum. Compromise of one Ames private key does not compromise earlier or later keys, so this has both forward and backward secrecy. The main drawback is that Ethereum transactions can be expensive, so key rotation is likely to be infrequent, and an attacker might be able to gain access to a long stretch of time by compromising a single key.

Various key rotation “ratchet” schemes could be added to Ames to establish varying degrees of forward and backward secrecy, and other kinds of cryptographic protections beyond basic soundness, such as break-in recovery.

Right now, changing a key through Azimuth is a manual process. It could be automated, possibly as one of a suite of services that an Urbit Provider will offer. Unfortunately, each key rotation costs the user money, so automating rotation could get prohibitively expensive.
Existing protocols, such as the Signal app's encrypted messaging protocol, the Noise protocol framework, and the Wireguard VPN protocol, use ephemeral Diffie-Hellman key exchange and KDF chaining to achieve forward and backward secrecy and self-healing.

Ames could be upgraded to use one of these existing ratchet algorithms, or we might create an Urbit-specific variant optimized for the Urbit network. This is work that should be done, but fortunately it will not require any novel research or drastic changes to Ames’s architecture.

While Urbit’s cryptographic protections don’t yet match those of Signal or a few other privacy-focused apps, Ames is cryptographically sound, and since Urbit updates itself over-the-air and is backed by a stable, decentralized PKI, I’m confident that the level of sophistication of Urbit’s cryptography has the potential to be world-class with just a bit more work.

## Denial of Service

A denial of service (DoS) attack against an Urbit ship is an attempt to overwhelm it remotely by sending it network data in such a way as to interfere with the ship’s ability to communicate with other ships or process other events -- usually by hogging its resources (computational power, memory, or bandwidth) until normal operation slows down or ceases entirely. Since the promise of Urbit is that everyone can run their own server, that server needs to be able to defend itself against DoS attacks. This is in fact one of the main impediments to running your own server in the modern world.

Right now, Urbit has no protection. Soon, it will need to at least be able to resist a simple attack carried out by an individual. Eventually, it should be able to resist a determined Distributed Denial of Service (“DDoS”) attack, which is more difficult.

There are two categories of DoS attacks in Urbit: authenticated and unauthenticated. An authenticated attack requires access to a ship's private key to construct valid Ames packets intended to overwhelm a target. All authenticated attacks will be handled primarily through enforcement of social boundaries, as discussed in the next section.

An unauthenticated DoS attack constructs packets that eventually fail to authenticate and decrypt but still overwhelm the target by causing it to waste resources (CPU, memory, disk, bandwidth) in such a way that it can't keep up with legitimate communications.

An unauthenticated DoS attack relies on the lack of Sybil resistance of IP networks: it's possible to generate new IP addresses rapidly, and a determined attacker might also be able to spoof its sender IP address. This is best considered an IP-layer attack that must be handled mostly at the IP layer itself, by maintaining state about which IP addresses can be trusted and which can't, determined empirically and heuristically by the Urbit runtime. The best any higher-level protocol, such as Ames or TCP, can do is make it as cheap as possible for a DoS target to reject a bad packet.

The overall strategy that Ames can take, as a protocol layering over the IP protocol, is to add an authentication procedure to each packet that can quickly identify bad packets, which an implementation will then use to mark that IP address as suspect and to refrain from adding the sender IP to a list of known-good IPs.

Currently, Ames handles this by attempting to decrypt a message and rejecting the message on failure. This may be a more costly solution than other methods, such as attaching a signature or a MAC to each message. The way to mitigate unauthenticated attacks is to make bad packets fail faster by augmenting each packet with a signature or MAC to each packet, since those are faster to validate than encryption.

So far, we have identified three approaches that could be taken here. Of these three, Leviathan recommended the end-to-end HMAC solution, since that would not impose additional CPU requirements on packet-relay nodes, such as stars.

- Sign each packet, and any relay or final recipient could validate the signature
- Wrap each packet in an HMAC, validated by the final receiver
- Wrap each packet in a HMAC for each hop in a relay chain; each relay would validate and strip the previous HMAC and add a new one for the next hop

Any of these solutions would be attempts to increase the rate at which the network could discard invalid packets, with different tradeoffs. I'll back up a bit to provide some context, and then I'll compare the approaches.

In any DoS solution, a planet will want to block or throttle IPs that have been sending it packets that fail to authenticate and decrypt. Ideally, a star will help protect planets for whom it’s relaying, too. Many different arrangements among galaxy, star, and planet are imaginable here, from an open policy to a policy wherein each packet has to come from a known-good IP. This sort of paranoid, closed-off arrangement might still not be enough to withstand a determined DDoS, but it's difficult for me to imagine doing better than that without launching Urbit-specific ISPs. Ames packets are cryptographically authenticated, so an Urbit ISP would actually be feasible.

This brings us back to the three possible ways of mitigating DoS from within the Ames protocol. They all involve adding a piece of authenticating information to each packet that can be verified more quickly than waiting for the cyphertext to fail to decrypt — Ames's symmetric encryption is authenticated, so it's not a cryptographic soundness issue, but the performance impact of trying to decrypt could be significant enough to make it hard to prevent a DoS.

As-is, an Ames packet is basically `[protocol-version checksum sndr rcvr (nullable origin) cyphertext]` (visit [this PR](https://github.com/urbit/urbit/pull/4051#issue-530369627) for a full specification). Let’s walk through the construction of the packet and how it can be upgraded to offer different DOS mitigations.

### DoS Mitigation Approach 1: Signature

The first approach to DoS protection would be to add a signature to the packet. The signature would cover everything except the checksum and the origin, since those need to be swapped out by relays. The signature would probably obviate the need for the (20-bit) checksum, although we could also leave it in there if we can't figure out what else to do with those header bits.

#### Advantages of a signature over other approaches

- It can be validated by anyone on the network. Relays would not need to modify it. This might also give it symmetry with the upcoming remote scry protocol, which might also sign every packet. I'm not quite sure this is an important property, actually, but it might theoretically make launching an Urbit ISP or internet backbone easier one day.
- It would be signed directly by the key listed on Ethereum, not something that might get ratcheted at some point for better forward secrecy — this could eventually lower the rate at which intermediate validators need their key caches invalidated, although this is a bit of a theoretical concern.

#### Disadvantages of a signature over other approaches

- Generating and validating a signature is significantly slower than generating and validating an HMAC.
- An ECDSA signature is 64 bytes, which is ~6% of a packet payload. As far as I can tell, it can't be compressed.
- Since the signature could be validated by anyone, it doesn't attest to a specific communication channel, so it might not help as much with IP filtering.

### DoS Mitigation Approach 2: End-to-End HMAC

The second approach would be to use an HMAC instead of a signature, validated by the eventual receiver. This HMAC would also cover everything except the mug and origin. I'm calling this the "end-to-end HMAC" design. An HMAC requires a shared secret, for which we could use the same symmetric key that Ames uses.

#### Advantages of end-to-end HMAC

- It's simple in some sense; relays don't need to do anything cryptographic.
- HMACs are much faster to create and validate than signatures.
- HMACs, since they're hashes, can be truncated arbitrarily and still maintain some security — to find hash collisions, you'd still have to guess what packet||shared-secret would hash to; it would just be a smaller search space. Since Ames's encryption already guarantees authentication and we'd just be using this as a performance optimization, I suspect we could get away with using one that's significantly smaller than a signature — I'm not sure how small, but if 4 bytes would be enough in practice, that would take up less than 0.5% of the space in a packet.

#### Disadvantages of end-to-end HMAC

- Only the recipient can validate. This means the authentication couldn't be used by relays to discard invalid packets. The recipient could provide back-pressure out-of-band to a relay to ask the relay to discard packets from an IP with an invalid HMAC, but this is indirect and might need to filter backward through multiple relays to work properly.

### DoS Mitigation Approach 3: Point-to-Point HMAC

The third approach, which is what I would build unless convinced otherwise, is what I'm calling "point-to-point HMAC". This design would include a different HMAC for each hop in a relay chain, instead of (or maybe in addition to) including one end-to-end HMAC.

We have a couple different options for how to construct the shared secret for each hop. I would intuitively construct it using a Diffie-Hellman of my private signing key and your public signing key — the "networking keys" on Ethereum include a currently unused signing key in addition to the encryption key that Ames uses. This way even if we add more forward secrecy to Ames, changing the symmetric key used for encryption, relays wouldn't have to have their caches invalidated as often; the state required to perform relaying wouldn't be as tied to the state required to receive a message.

#### Advantages of point-to-point HMAC

- A star could perform some validation on every packet it's asked to relay. This makes it more difficult for an attacker to route a ton of packets to a planet through a star, or even through many relays. Signatures also have this property, but they're slower to verify. This approach and the signature approach, but not the end-to-end HMACs, force an attacker to use an (at least partially) authenticated attack in order to use a relay as a way to get to a planet.
- A planet could quickly validate that a relayed packet actually came from its star, not an attacker who's managed to spoof the star's IP address.

#### Disadvantages of point-to-point HMAC

- Not everyone on the network can validate a packet, unlike a signature.
- Each relay needs to validate and strip off the previous HMAC and create a new one before sending it. This should be quite fast, since an HMAC is just a hash, but it's still some CPU, and potentially creates an imbalance where an attacker could induce the relay to spend more CPU in validation than the attacker spent in constructing the packets.
- By itself, it doesn't validate the cyphertext in an end-to-end way. I suspect we might want to include both a per-route HMAC and an end-to-end one, especially if we use truncated HMACs — although per-route might be enough on its own, since if the receiver fails to validate a bunch of packets whose HMACs were validated by the relay, the receiver can ask the relay to block that whole Urbit address regardless of IP, so it shouldn't be possible to sustain that kind of attack for long.

#### An Aside About Cryptographic Performance

I'm not sure exactly how much faster HMAC is. According to DJB (https://ed25519.cr.yp.to/ed25519-20110705.pdf), an ECDSA signature can be created in around 30 microseconds and verified in around 100 microseconds. This source (https://www.jacksondunstan.com/articles/3206) suggests about 21 microseconds for HMAC-SHA256, so about a 1.5x improvement in generation speed and 5x in validation speed. We should verify these numbers for ourselves before making a decision.

### DoS Protection Strategy and Timeline

Tlon is not currently pursuing adding any of the extra cryptographic authentication on Ames packets described above. Since this is ultimately a performance issue, there are other more pressing performance issues that we could improve upon before decryption will become the limiting factor in how many packets can be processed by a ship. We will revisit this authentication performance question once some of the low-hanging fruit has been done, perhaps roughly a year from now.

Since the audit, we’ve already improved the Ames packet format to allow faster parsing, faster validation of basic fields, and faster relaying; in the future, increases in performance of Nock execution and inter-process communication between Urbit's I/O process and Nock worker would allow Urbit to absorb somewhat more punishment before service can be effectively denied.

## Enforcement of Social Boundaries

While Urbit needs to rely largely on its runtime to mitigate unauthenticated attacks, any attack conducted from an Urbit ship needs to be handled inside Arvo itself, not just by IP filtering in the runtime. Just like in any DoS, an attacker ship might try to induce you to use too much memory, CPU, or disk space in order to sabotage normal operation. An authenticated attack is harder to define than an unauthenticated attack, because it depends on what social relationship the attacker and target have, and it involves valid, authenticated Ames packets; once discovered, though, it’s easier to mitigate, because it can use Urbit’s permanent identity system to enforce social consequences, i.e. stop listening to that Urbit address and possibly encourage others to do so as well.

There are a couple of different kinds of authenticated attack: attempts to exploit vulnerabilities in the Nock worker (the interpreter, allocator, and jets) by causing particular Nock code to run, and attempts to induce the target to exhaust various computational resources.

Protecting against attempts to break out of the sandbox and hijack or otherwise interfere with the Unix process running Nock will require a process of hardening, fuzzing, and likely further security audits specifically evaluating the security of that boundary. This is largely out of scope of the Ames protocol itself, which was the subject of this audit.

This leaves us with the latter case: resource exhaustion attacks. A peer could try to get my ship to use too much RAM, disk, CPU, or bandwidth by sending it valid Ames packets. This represents a social problem: a person on the network is trying to interfere with me. It's what's known in blockchain circles as an "attributable fault": once the attack is detected, it's trivial to determine the identity of the culprit.

Once the attacker’s Urbit address is known, Urbit will fall back on the Sybil resistance of its identity system: there are a finite number of identities, each of which costs some money. Because Urbit identities are relatively permanent, they can be blocked permanently. As long as the expected value of an authenticated attack is less than the cost of the identity, the attacks won't happen very much — they'll cost money to sustain, instead of being self-perpetuating.

Attacks like this are best thought of as attempts to violate social boundaries. I don't want you using up too many of my resources; that's a social boundary, and an attempt to force my ship to spend its resources on your behalf constitutes a violation of this boundary. The strategy for mitigating these attacks is to impose social and, indirectly, economic consequences on the perpetrators. The main social consequence is other ships refusing to communicate with you anymore.

Some of this mitigation will take place in the Arvo kernel, and some will need to be application-specific. To protect the system from attackers, the kernel needs to be able to free space (Urbit is a single-level store, so there's no distinction between disk and RAM from Arvo's perspective) taken up by unfinished messages sent by peers. This can be done by allowing an application to ask Ames to delete partially received messages from a peer, generally replacing the received packets with an intent to nack (negative acknowledgment) to indicate that the transaction the peer wanted me to perform has been rejected.

Applications should also be able to set resource usage policies that the Arvo kernel will enforce. For example, a chat application should configure Ames to reject any chat messages larger than, say, two hundred kilobytes. A file-sharing application would need a much larger per-message limit (ideally no per-message limit), but it might need to place a cap on its bandwidth usage to make sure lower-latency communications aren't swamped by a large file transfer. This kernel/application interface starts to resemble a permissioning or capabilities system, and it could be built as part of the crucial larger project of providing for configurable application permissions.

To close the loop on enforcing social boundaries, reputation information should be shared across ships. This will likely be done by building one or more applications that share statistics and block operations. Some forms of reputation are likely to be globally shared, whereas others are likely to be multipolar, i.e. some people like you and some don’t. Generally, the lower the layer of the attack, the more global the reputation effect will be; the higher the layer, the more multipolar. An attempt to spam the network with millions of malicious packets will cause most people not to want to talk to you; sending me a movie I found mediocre is probably not even information worth sharing with anyone else.

## Conclusion

Ames’ design has unparalleled potential to deter, mitigate, and recover from attacks, since every packet is authenticated and encrypted and backed by a stable, decentralized PKI. It feels good to have our design for encryption and authentication be confirmed by a third party as cryptographically sound, and we know more or less what we need to build to reach the full security potential of the platform, including the steps outlined here.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Input and Output in Hoon]]></title>
            <link>https://urbit.org/blog/io-in-hoon</link>
            <guid>https://urbit.org/blog/io-in-hoon</guid>
            <pubDate>Tue, 15 Dec 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![canyon](https://media.urbit.org/site/posts/essays/zion-canyon-1.jpg)

<br>

Let's talk about IO in Urbit. I won't say much about how events and effects are processed by the runtime; it suffices to note that the runtime is a normal Unix program which (1) listens for various events, (2) passes them to Arvo (Urbit OS), and (3) processes the effects produced by Arvo. Instead, I’ll focus on how IO works from the perspective of Hoon programs, like Arvo or apps running on Arvo. But first, let's review IO paradigms in other languages.

All examples are in a made-up language, since it's useful to understand this information even before you're comfortable in Hoon. If you're learning Hoon and want a challenge, try translating them!

## The three styles of IO

I will call these styles imperative IO, monadic IO, and state machines (note that this classification refers only to the experience of using them and the program structure they dictate). An imperative programming language can use any of these and a functional programming language can use any of them.

### Imperative IO

Imperative languages (such as C and Python) perform IO by calling a function in the middle of whatever they were doing. Anywhere, in any statement, you could have IO.

In this example and others to follow, the task will be to read a filename from the command line, read a URL out of that file, and fetch the contents at that URL.

    output = fetchUrl(stripWhitespace(readFile(cliInput())))

For readability, intermediate variables would be a good idea, but nothing stops you from nesting IO this way.

### Monadic IO

Languages that use explicit monads for IO (such as Haskell) perform IO by running IO behind a bind operation, which I'll notate with `<-`. Thus, while you can't put IO _anywhere_, the general structure is a sequence of IO operations.

    fileName <- cliInput()
    url <- readFile(fileName)
    output <- fetchUrl(stripWhitespace(url))

[Tackling the Awkward Squad](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf) is the canonical description of monadic IO, and does a great job of explaining how the Haskell community decided to use this as their primary IO style.

### State machines

Languages that use explicit state machines for IO (such as Elm) perform IO by accepting events and producing a list of effects.

    event :: Initialize
           | CLIInput text
           | FileInput text
           | HTTPResponse body
    effect :: CLIInput
            | ReadFile fileName
            | FetchUrl url
            | Print text
    main(event) {
      switch event {
        Initialize        -> [CLIInput ~]
        CLIinput fileName -> [ReadFile fileName]
        FileInput url     -> [FetchUrl stripWhitespace(url)]
        HTTPResponse body -> [Print body]
      }
    }

The effects produced are not functions but data.

It's important to note that this example is chosen to highlight a particular kind of IO — sequences of events. Further, this example has no persistent state — each IO operation is a pure function of the output of the previous one.

## A stateful, loopy example

Let's look at another type of program: a simple HTTP server that you can give text at the CLI, which will respond to all HTTP requests with that text.

Imperative:

    text = "no text entered yet"
    while (true)
      cli = readCli()
      if (cli != Null)
        text = cli
      request = readHttp()
      if (request != Null)
        respond(request,text)

Monadic:

    loop("no text entered yet")

    where:

    loop :: text -> IO Null
    loop =
      input <- readInput()
      switch input
        CLIInput newText -> loop(newText)
        HTTPRequest request ->
          _ <- respond(request,text)
          loop(text)

State machine:

    text = "no text entered yet"
    main(text,event) {
      switch event {
        CLIInput newText    -> [newText, Null]
        HTTPRequest request -> [text, HTTPResponse text]
      }
    }

Again, note the response in the state machine is data, not a function.

I'm not trying to make a point about which type is better in general. There's a pretty strong argument that in the first example, imperative was the best option, followed by monadic, followed by state machine. There's an equally strong argument that the second example is most naturally represented by the state machine.

Look at how state is handled in the monadic example. Formally, bind composes functions, so that every time you see a `<-` there's actually a new function (closure/delimited continuation) being created and stored for when we receive a response. All variables in scope are stored in that closure, so we can conveniently access them later without explicitly storing them. However, the state we preserve over time varies a lot. In this example, it varies between storing `loop`, `[loop input]`, `[loop input newText]`, and `[loop input request]`.

By comparison, the state machine does not store intermediate values, it only stores its explicit state. While this is somewhat less flexible, it puts the permanent state front-and-center.

I'll reiterate that all of these are possible to implement in purely functional languages, and further they can all be implemented in terms of each other. State machines are trivially implementable -- it's just a function [state event] -> [new-state (list effect)]. Monadic IO can be implemented directly (as in Haskell) or on top of state machines by storing continuations in your state. Imperative IO is somewhat more difficult but should be possible through algebraic effects.

When inventing a new system, you should consider which of these you intend to support based on the sort of code you expect to see. For example, a scripting language will almost always benefit from imperative (or at least monadic) style.

## In Urbit

So much for exploring the space of IO solutions. In terms of deployed code on Earth, the split is about 90% imperative, 5% monadic, and 5% state machine. In Urbit, the split is about 90% state machine and 10% monadic. This is what I intend to explain and defend.

Urbit's OS is called Arvo; it has several "kernel modules" called vanes, and it has userspace applications. Colloquially these are called "apps," but when speaking about them abstractly, it's helpful to use their more specific name: ["agents"](https://urbit.org/docs/tutorials/arvo/gall/#agents). Arvo, the vanes, and agents are all structured as explicit state machines.

In addition, there are ["threads"](https://urbit.org/docs/tutorials/arvo/gall/#threads), which are structured as monadic IO. Note there's only a superficial resemblance to Unix threads: they are not executed in parallel and they don't share memory, or at least not any more than agents do. They're simply a computation that takes an argument and produces a result, possibly after doing some IO, structured monadically.

As you can see, all the lowest levels of Arvo are explicit state machines, and only the highest layer supports monadic IO. To see why this is the case, let's list advantages and disadvantages to each type. Note that, while I'm speaking specifically of agents and threads in the context of Urbit, these are fundamental properties of monadic and state machine IO.

Agents are:

- Upgradable. Since the state is explicit, you can upgrade an agent in-place by supplying a new state machine and a function from the old state type to the new state type. This is very similar to a database migration.

- Robust. A state machine must accept any input at any time. If it receives unexpected input, it must have had explicit error handling for that input, since it's one of the types in the switch statement. Thus, it's relatively easy to stay in a consistent state.

- Permanent. Since it's upgradable and robust, there's no reason to stop its running.

- Hard to write long sequences of IO. Long sequences of IO create many possible states, and you must handle any input in any state. This can result in complex, hard-to-follow code with code paths that are rarely if ever taken.

Threads are:

- Not upgradable in-place. Since the state is implicit, you can only cleanly upgrade by (1) killing the thread and restarting it or (2) letting it resolve to a defined "upgradable state" periodically, usually at the top of a "main loop". If you do (2), then you are in fact structuring it as a state machine, so the other advantages of threads are compromised.

- Fragile. If we don't receive expected input, the default behavior is to be stuck waiting for input. You must remember to add any error-handling features you want, and it's easy to end up in an inconsistent state.

- Impermanent. Since a thread can't be upgraded and may get stuck in case of unexpected input, a thread can't be expected to last forever. It must be "rebooted" from time to time.

- Easy to write long sequences of IO. Just...write the IO one line at a time.

Arvo proper and the vanes are permanent pieces of software and, for this reason, state machines are more natural.

I'll note that other kernels, like the Unix kernel, use imperative IO. The difference is that Unix isn't permanent in itself — it only lasts until you reboot. Since your permanent state is stored externally, you don't need to be upgradable or permanent. With sufficient discipline you can write robust C code, so it makes sense to use imperative style. Even so, a lot of C code is written in a state machine style; even if it doesn't need to be upgradable, it's worth it for the robustness and concurrency advantages.

However, Arvo is a single-level store — all of its state is permanent. This is very convenient and eliminates many long-tail bugs, but it also means we need to code for permanence, and that's much easier when you structure your code with explicit state.

Further, Arvo and the vanes rarely perform long sequences of IO. Generally, they do one thing and emit some effects, similar to the HTTP server example above. Sometimes they "pass through" a request. For example, the Eyre vane passes HTTP requests to userspace agents or threads. In this case, there is a sequence of IO, which in monadic code would be:

    loop()

    where:

    loop =
      request <- receiveRequest()
      agent = lookupAgent(request)
      response <- callAgent(agent, request)
      _ <- sendResponse(request, response)
      loop()

This is clear code to read, but it leaves open the question of how to respond during the callAgent() function. If another request comes in, can we handle it in parallel? If we need to upgrade ourselves before the agent responds, can we make sure to properly handle the response?

The naive solution in monadic code is to say that you can only handle one request at a time, and if an upgrade happens you just drop outstanding requests. You can resolve both of these by introducing a sort of main loop, which is just a way of saying "turn it into a state machine".

In a state machine, the naive solution is:

    state :: (map request agent)
    main(state, event) {
      switch event {
        HTTPRequest request ->
          agent = lookupAgent(request)
          [put(state, request, agent), CallAgent agent request]
        AgentResponse request response ->
          [del(state, request), HTTPRespond request response]
      }
    }

Upgrading this is trivial, since the state (map of requests to outstanding calls to agents) is explicit. It also trivially handles concurrent requests.

I won't claim this is easier or harder to write than the monadic version, but it has the properties we need at this level of the system.

Userspace agents similarly are permanent entities that need to not lose data or get stuck. For this reason they’re structured as state machines.

A helpful comparison is that explicit state machines are basically Mealy machines, the kind you might have learned about in an introductory digital design class. This shouldn't be surprising; a digital circuit must always be consistent because it can't be manually "rebooted", and their input and output is highly formalized. By contrast, a Rube Goldberg machine doesn't have the same constraints; which is why they're a lot more fun!

It's notable also that explicit state machines are considerably more declarative than imperative or monadic IO. Not everyone thinks that's a good thing, but anyone who defends functional programming should see some advantages to that.

However, userspace sometimes needs to perform long sequences of IO. Let's look at an example where we want to fetch the front page of a site and the first couple comments on each story. HTTP is unreliable, so on failure we retry five times.

Monadic:

    topStories <- fetch(topStoriesUrl)
    loop(topStories)

    where:

    loop :: topStories -> IO Null
      if topStories is Null
        return Null
      comments <- retryLoop(5,head(topStories))
      otherComments <- loop(tail(topStories))
      append(comments,otherComments)

    retryLoop :: [n story] -> IO Comments
      comments <- fetchComments(story)
      if comments is HTTPError:
        if n == 0:
          bail
        else:
          retryLoop(n-1, story)

State machine:

    state :: Initial
           | FetchingTop
           | FetchingStory comments stories retries
           | Done comments

    main(state, event) {
      switch event {
        Initialize ->
          assert state == Initial
          [FetchingTop, Fetch topStoriesUrl]
        HttpResponse response ->
          switch state {
            FetchingTop ->
              [FetchingStory Null stories 5, FetchComments head(stories)]
            FetchingStory comments stories retries ->
              if response is HTTPError:
                if retries == 0:
                  [Initial, Null]
                else:
                  [FetchingStory comments stories retries-1,
                   FetchComments head(stories)]
              else:
                comments = append(response,comments)
                if tail(stories) is Null:
                  [Done comments, Null]
                else:
                  [FetchingStory append(comments,response) tail(stories) 5,
                   FetchComments head(tail(stories))]
          }
      }
    }

With practice, the state machine version of this can be written correctly. However, (1) it's verbose, (2) the control flow jumps all over the place, and (3) in practice it's challenging to get exactly right. This is still a small example, and it gets much worse as the length and complexity of the IO sequence grows.

The monadic version, on the other hand, flows cleanly down the page. We can factor out generic functionality like "retry this request n times" to make the essence of the computation clear.

Suppose you have to upgrade this. In the state machine, you can see exactly which stage of the computation you're in and write specific code to upgrade cleanly.

Threads, as we've discussed, can't be upgraded in-place. Let's be real though: we're downloading comment sections, not regulating a nuclear reactor. If we get a better version of this script, just kill the old one and start the new one from scratch. What's a couple extra HTTP requests?

This suggests a general division of workloads: code which needs to be permanent, upgradable, and concurrent should generally be a state machine. Code with long or complex sequences of IO and definite termination should generally be a thread.

These aren't completely mutually exclusive, but it's surprising how often they are.

### Jael: a case study

When you need to do something permanent and upgradable, but you also need to do long sequences of IO, the main trick is to factor your problem into both an agent and a thread (or several).

As a case study, consider Jael, one of our vanes. This maintains our PKI state, which it downloads over HTTP from an Ethereum node. Downloading from an Ethereum node is a complex sequence that starts with fetching its most recent block number, then fetching all the blocks we haven't seen and scanning for transactions we care about. We also maintain a map of block hashes to block number, and if we see that a block's parent doesn't have the hash we expect, that means a reorganization has occurred, so we must "rewind" one block at a time until we find where the fork happened, then restart going forward.

You don't have to understand this sequence of IO; it's sufficient to see that it's complex and must be exactly right. We used to do this in a state machine directly in Jael. This data is, of course, permanent and needs to be accessible to the rest of the system, so Jael must be a state machine.

However, we had many small mistakes in this sequence of IO, some of which only appeared during unusual events, such as when an HTTP request failed at the same time as a reorganization happened.

We're in a bit of a bind, though: Jael has to be a state machine. The solution is to factor out the act of getting updates into a thread while the main PKI state is stored in the state machine in Jael.

This thread has a definite purpose: given the most recent block number we already know about, fetch all the PKI transactions since then. The function signature is:

    syncEthereum oldBlockNumber -> IO [newBlockNumber, newTxs]

Jael runs this thread every five minutes and, if it succeeds, then we update our block number and PKI state. If the thread fails, gets stuck, or we need to upgrade it, we just kill the old thread and start a new one. Again, a few extra HTTP requests don’t matter.

From Jael's perspective, it looks something like:

    state :: State block txs outstandingThread
    main(state,event) {
      switch event {
        Initialize -> [State 0 Null Null, StartTimer (now + five minutes)]
        TimerFired ->
          effects = If outstandingThread is Null
                    then Null
                    else [Kill outstandingThread]
          newId = newThreadId()
          [State txs newId,
           append(effects,
                  StartThread newId syncEthereum(block),
                  StartTimer (now + five minutes))]
        ThreadFinished Failure -> [State block txs Null, Null]
        ThreadFinished Success newBlockNumber newTxs ->
          [State newBlockNumber append(txs,newTxs) Null, Null]
      }
    }

In other words, from Jael's perspective, it's just a single IO event that encapsulates arbitrarily complex IO in the thread. A single IO event is easy enough, and we can maintain all our permanency and robustness guarantees, because we know the thread will have one of three results: success, failure, or it hangs. If we set a timeout, hang becomes failure, so there's only two possible results: success or failure. If we handle both of those correctly, we've handled all the possible IO errors that could have occurred.

What about upgrading? We've already said we can handle the thread dying for arbitrary reasons, so if an upgrade comes in, we just kill it. We can upgrade Jael's state machine easily since its state is very simple.

## Recap

Let's recap what we've covered:

- There are three styles of IO: imperative, monadic, and explicit state machines.
- Urbit supports explicit state machines (agents) and monadic IO (threads).
- Explicit state machines are preferred for permanent, robust, concurrent code.
- Monadic IO is preferred for short-lived code with complex IO.
- If a state machine needs to perform complex IO, it should encapsulate it in a thread so that, from the perspective of the state machine, it's simple IO.

Hopefully it's fairly clear why Urbit uses explicit state machines in most situations. More than anything else, our goal is to build software that can last forever. Explicit state machines are a crucial tool for that.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Metaphase]]></title>
            <link>https://urbit.org/blog/metaphase</link>
            <guid>https://urbit.org/blog/metaphase</guid>
            <pubDate>Tue, 08 Dec 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![mitosis](https://media.urbit.org/site/posts/essays/metaphase.jpg)

<br>

_Previous versions of this essay specified the stream deploy date as December 11, 2020; then December 18, 2020. This has been amended to the actual date of release, with our sincere apologies. For new readers, you can opt into the dev stream by running:_

```
|ota ~hanruc-nalfus-nidsut-tomdun %kids
|merge %home ~hanruc-nalfus-nidsut-tomdun %kids, =gem %take-that
|merge %kids ~hanruc-nalfus-nidsut-tomdun %kids, =gem %take-that
```

_We will surface this option more broadly in a future settings overhaul._

A few weeks ago, the Landscape team — those of us building Tlon’s suite of userspace applications on top of Urbit— deployed our first over-the-air update for notifications. This is a big leap forward for us. Of course, getting notifications inside Landscape itself is a big deal, but getting a push notification on your phone, or an email digest based on activity inside Urbit is now just one step away, a weekend project for a hobby developer, not an indeterminate number of steps away.

After release, we received some feedback from users on the behaviour and design of this feature; beyond the obvious kinks that come from an initial release, it seemed to some like a minimum viable affordance pitched as a fully designed feature. This “bottom-up” development approach was, to us, fairly straightforward; to some of our users, it seemed that we had closed the door on the feature without even beginning to expose all its possibilities.

As I’ll describe, we haven’t just been iterating Landscape, but the way we develop Landscape, and the way we consider Landscape in relation to Arvo. Finally, we’ll discuss our upcoming two-stream release process: a “stable” release stream with updates every six weeks and a development stream, with ongoing changes continuously deployed on an opt-in basis.

To someone coming to Landscape for the first time, it is starting to look mature; and it is indeed maturing quickly. After all, these mismatches in expectations are pangs calling out for growth. Landscape truly has _users_, not just explorers, who are developing the same expectations they have with the other tools they use: predictability, reliability, and iterative improvements, not just leaps forward. So to meet those expectations, we’ve been working on the prerequisite work for a mature release schedule, with two different release streams for users and explorers: a lifecycle, with the cells, interlinked, dividing into a coherent higher being.

## Landscapers and lifecycles

For most of 2020, the core Landscape team has comprised of Liam (`~hastuc-dibtux`), Logan (`~tacryt-socryp`), and myself (`~haddef-sigwen`). Others at Tlon have rotated on and off, and some community members (`~radbur-sivmus` comes to mind) have also contributed a lot, but the three of us handle the core decisions and the entire stack for Landscape, working with designers, infrastructure, and third-party developers.

After OS1’s release in April 2020, Landscape’s back-end has changed quite a bit; the first rearchitecture we performed was in group-store, adding roles and simplifying quite a lot of the back-end logic at the same time.

Around May of this year, Logan flagged that our code surface was too large and had too much boilerplate by writing a set of bespoke full-stack applications when just one flexible userspace database would do. Our designers also had a vision of our interfaces being “modes and genres of the same data” that fit this vision as well; and so since then, we’ve put our resources into migrating all of Landscape to use graph-store (more information available in [this developer call](https://www.youtube.com/watch?v=E4DFuAZQ32Y)).

Obviously, developing userspace for distributed computing has some additional challenges that you don’t have to consider when writing software for a single server. Each ship interacting has to mutually coordinate the agents running and the events to be processed. If those fall out of synchronisation, the edge cases multiply.

We traditionally tended toward solving those problems by writing the simplest possible incarnation of an application or a solution first, triaging out additional complications until they can be most prudently addressed — usually when they are just one step away.

For most of its history, Landscape’s userspace suite had to be up-to-date on all ships to function at all, so multiple staging streams added quite a few complications. Since incompatible versions of applications on different ships would produce mutual fail states if they attempted to interact –and since each application had no sense of how to negotiate compatibility with older applications, each user had to keep up-to-date. Landscape was moving too fast, constantly reconfiguring (to give you a sense of this: we still refer to a month ago as “old”).

Historically, Arvo and Landscape were also considered just one object; changes in Landscape would often require refining the layers underneath it as well. We often aimed to use our interface’s requirements to refine Arvo in turn. But as Landscape’s cells continued to split, as it became a proper client _for_ Arvo rather than a subsection _of_ Arvo, it required its own planning and execution cycle that only came to fruition around April of this year.

The first thing we did was start recurring, six-week product backlogs with designers and engineers to occasionally reassess short-term priorities with a larger roadmap. Once we did that, we began working on opening our process to the public, migrating all tasks, priorities, and current decisions to a [product board](https://github.com/urbit/landscape). By doing this, community members could both suggest features _and_ contribute features, with a centralised, transparent process for getting designer input and Tlon engineer priorities. This has also been a successful effort.

By adjusting ourselves to a six week rhythm for execution, it’s clearly time to slow down our release schedule and dedicate design and QA time to each release.

Since Arvo is still quite young, we can’t quite get to all the thornier aspects of instituting a lifecycle. For example, we can’t tackle agent version negotiation in full yet; and mark versioning is still not present. This means modifying the validators for our graph modules (that is, validating the graph structure of a notebook vs. a collection) presents a deployment challenge in a two-stream lifecycle.

That said, our userspace infrastructure is maturing, so we could at least organise the APIs to those agents; and we could at least slow the development cycle on those agents in favour of the more flexible components of the stack. The front-end specific features, for example, can be deployed on different ships without side effects for other users.

So now, before we could launch a stable stream, we had some things to do first:

- **We wanted to provide assurance that the userspace suite is relatively stable.** All our remaining stores (invite-store, metadata-store, and contact-store) needed to be modernised to use the same libraries and utilities inside Arvo as newer userspace applications.
- **We wanted all our applications to be using graph-store.** If we were going to migrate the entire network to a new userspace model, we shouldn’t undermine the new release cycle process and make it more difficult to test and deploy to meet higher user expectations. We needed to migrate everything first.
- **We wanted to release the notification-store**. After the October 2020 groups release, Landscape simply wouldn’t be complete without it.
- Finally, **we wanted all of Landscape to use the [Indigo component library](https://github.com/urbit/indigo-react).** Landscape shipped with each application using its own build with handwritten, bespoke DOM components. Once we moved to a single-page application architecture in June 2020, we wanted the same guaranteed consistency for both back-end and front-end code.

Most of these are now accomplished; the remaining tasks are awaiting some final tests and UX work. We’re aiming for a stable stream of Landscape to deploy by **January 5, 2021**.

What does this mean? For everyday users, you can expect Landscape releases every six weeks; the slate of features and any breaking changes will be flagged well in advance for third-party developers; and you can expect a more thoroughly considered user experience with notes and copy for each new release.

And for intrepid users, you can opt-in to a development stream and help us find and eliminate bugs before release to the wider public. This development stream is much like how we've been deploying Landscape up until now — but now it's optional.

## Mitosis

Describing our progress so candidly can feel strange — after all, it sounds so _early_. But to me, it’s exciting. It’s mitosis.

Take another example. For all of Urbit’s history — all until now — Tlon was playing the role of both parents to the project when it was really just an embryonic corporate vehicle itself, fated to become twins. But in the past few months the burgeoning Urbit Foundation’s interim Director, Josh Lehman (`~wolref-podlex`), has begun to ramp up responsibility, taking increasing stewardship over urbit.org and giving it a physical voice, an Otherness, apart from Tlon’s own goals.

Now, each day, we stray a little closer to these entities splitting apart, a step closer to the Urbit Foundation and the Tlon Corporation being completely different entities with completely different concerns.

The same has occurred with Landscape. Previously Landscape was “_the_ interface to Urbit,” the proof that there was more to the project than a Unix executable. And slowly to those of us at Tlon, it became obvious what it was destined to become: a flagship client for an entire network, a tree branch rooting a world beneath clearnet, the first cell by which other clients might be born. Mitosis can be clumsy to watch; it can be nauseating to experience; it can be difficult to make out what will arrive where.

But this is, after all, how a body forms.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Security and Continuity]]></title>
            <link>https://urbit.org/blog/security-and-continuity</link>
            <guid>https://urbit.org/blog/security-and-continuity</guid>
            <pubDate>Mon, 30 Nov 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![Security and Continuity](https://media.urbit.org/site/posts/essays/land4.jpg)

## Security and Continuity

In 2018, when we launched the Urbit ID contracts (also called ‘Azimuth’), we committed to yearly infrastructure goals for 2019 and 2020. This wasn’t an informal commitment — it’s part of the contracts that were published to the blockchain, which you can read [here](https://raw.githubusercontent.com/urbit/azimuth/edf68b8da04806dd5b95994daf14cf1e7e226829/proposals/0xcb1f81e42b5e75f000f94fc71a3ea70cab4bfc6f236b91e717f1b9516e5596b5.txt). At the end of each year, we ratify our accomplishment of these goals with a galaxy vote.

Since the year is coming close to an end, and this year’s vote is on the horizon, it’s time for an update on our progress.

For this year, we committed to completing two things: passing a third-party security audit of our networking protocol (Ames) and getting Urbit OS (both Arvo and the interpreter) to the point where we can reasonably expect the Urbit network to continue without any hard forks (which we call ‘breaches’). A world with no network breaches is one where the network should be able to run indefinitely without any interruption. We also call this ‘continuity’.

We’ve been steadily making progress on these two fronts, and I’m happy to report both are nearly complete. We’ll walk through some of the details here and then follow up in another post soon to report on how the final work turned out.

## Ames Audit

Urbit OS is an ‘overlay OS’: it runs on top of (pretty much) any flavor of Unix. Each Urbit OS node communicates with other nodes over UDP using Ames, the Urbit-specific networking protocol.

There are two things worth worrying about when it comes to Urbit OS security: someone breaking into Urbit from the machine it’s running on, and someone compromising the network protocol itself. As to the first, there are probably ways that we can harden the OS sandbox, but if the machine it’s running on is secure we can feel reasonably safe. Since there’s lots of prior art on how to secure a Unix machine, we can leave hardening the runtime for later and simply encourage everyone to secure the boxes they run their Urbit nodes on.

Assuming each node on the network can run on a locked-down machine, it’s really important that the protocol for communicating between these nodes is secure. Also, since Ames uses other Urbit nodes for peer discovery, we want to make sure no ‘relay node’ can inspect data not meant for them.

The question “Is Ames secure?” is too vague for an auditor, of course. The audit was scoped to determine that the following three criteria are met:

- No one can impersonate another ship on the network
- No one (including relays) can intercept and decrypt messages not meant for them
- Ames messages don’t leak keys that could endanger the sender’s data

Our goal with this scope is to focus exclusively on the design and implementation of Ames itself. Basically, the crypto should be correct and there should be no flaws in either the protocol design or its implementation. Our interpreter can still be hardened against other potential attacks, which is work we’ll undertake in the future. We asked our auditors to flag all of these potential issues, so we know what needs to be addressed in the future.

The good thing about an audit scoped in this way is that we can trust the protocol to authenticate people and shuttle packets back and forth safely. We’ve always been reasonably confident about Ames, but having an external stamp of approval will be great.

As of the end of November 2020, the audit is very nearly complete, and we’ve handled all the important issues that were brought up. We’ll post the results and talk about our mitigation strategies in a future writeup.

## Continuity

Urbit is designed to last a long time. What’s the use of a personal computer if it’s gonna disappear along with all the data you put in it? Ideally, you can put your Urbit on a USB stick, forget about it for ten years and have it work again when you plug it in. It’ll need to update for a while, but once our work on continuity is complete, your urbit should be able to upgrade itself through ten years of updates, all over the air.

While Urbit is designed to upgrade seamlessly over the network we have occasionally run into issues that have caused us to reboot the entire network. Most of the time this is when some incompatibility between the interpreter and the kernel means we have to force everyone to do a hard reset to ensure compatibility between the two. Our current work on continuity addresses this. Soon, your urbit will tell you when your interpreter needs to be upgraded. At first this won’t be that different from an application notifying you to download an update. Eventually, we think we can make this a lot smoother.

A network reboot isn’t the only way that we can break continuity. Urbit is a general-purpose computer — which means you’re free to attempt to destroy it. If, for any reason, you do manage to screw the system up we want you to be able to get your data out and effectively reset continuity on a single node. We built the affordance for that a while ago, but before the end of the year we’ll also distribute tooling to migrate userspace data between hard resets.

The combination of version negotiation and data migration should afford us the ability to run the network indefinitely into the future. Unfortunately, to get this change in, we’ll need to reset the network. We’re optimistic that this will be the last time we ever do it. And, given our data migration tooling, this breach won’t involve losing data.

## Status + conclusion

We have been working with auditors since this summer and should have a report ready to publish in the next few weeks. Both version negotiation and data migration are in testing and are ready to be deployed.

Our goal is to have all of this work complete by `~2020.12.10`. This means we should be able to start a galaxy vote right around that time. Galaxy votes (as specified in the contracts) run for a month, which should have this whole process ending on `~2021.1.10`.

It's going to be an exciting couple of weeks!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[An Email from the Archive]]></title>
            <link>https://urbit.org/blog/an-email</link>
            <guid>https://urbit.org/blog/an-email</guid>
            <pubDate>Sun, 29 Nov 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![An email from the archive](https://media.urbit.org/site/posts/essays/moon.jpg)

I found this email in my archives recently and thought it might be fun to share publicly.

```
From: Galen Wolfe-Pauly <galen@tlon.io>
Date: Thu, Jul 2, 2020 at 9:50 AM
Subject: Continuing
To: XXXXXXXXXXXXX
```

Here are a few things I was thinking about after we chatted. It may be that I'm just reiterating things I already said — but perhaps it's useful:

1 -

Our collective desire to depend on digital communication tools vastly exceeds what I would have ever guessed. Even if you somehow factor out what’s addictive about the platforms we use today: they serve a real need. The crux of the problem with our current platforms is that they don’t actually serve the need that we want them to serve. They’re not tools in the way we expect tools to be. For the most part, the platforms we depend on serve the needs of their shareholders or some graph or another that needs to go ‘up’, which makes them compromised in a very deep way.

In the pre-digital world we enjoyed a few things about the way we communicated, collaborated and did business that are dwindling: simplicity, durability and ownership. I’ll try to give some straightforward examples of what I mean:

A - When I talk to someone directly, I’m not worried that someone else is listening in. If they go tell someone else what I said to them, that’s something for us to work out between us — they’re not _always_ reporting our conversations back to a third party. The constraints of the interaction and the privacy implications are _simple_ — I don’t think about them at all. Good privacy guarantees flow from a strict focus on simplicity. When two people want to talk to each other: give them a secure channel to talk. Putting a centrally-controlled service between them is just an interim solution because no one could figure out a better way to do it.

B - When I write something down on paper, or type into a typewriter, I have an intuitive sense of the durability of what I’ve made. I have notes on my shelf I took ten years ago. I don’t worry about them disappearing. This means I can have a very direct, high-resolution relationship with the medium. I can pour myself into my physically-written notes in a way I would never pour myself into a Google Doc. Our digital tools are deeply untrustworthy because we know they can disappear, that they won’t actually last forever.

C - Around 2008 I started limiting myself to a few specific drawing and writing tools. I use them all the time and can actually refine my relationship to them since I know they’re not going to change out from under me. Perhaps at some point these pens wont be made anymore, but the ones I have are actually _mine_. Similarly, the things I make with them actually belong to me in a way that doesn’t require some ridiculous terms of service. A sense of ownership, when it comes to the medium of communication, determines our level of trust and commitment.

Our digital tools have to achieve the same level of simplicity, durability and ownership that our pre-digital tools did. Until they do, we’re always going to be in conflict with them, full stop.

The main thing is that exactly none of our present platform-centric world can survive when you see things this way. The digital world we live in is composed of an insanely complicated, ephemeral set of tools that distinctly _do not_ belong to the people that use them.

We’re going to be in a constant struggle with technology until it conforms to these three very basic expectations. These are the expectations we try to get Urbit to fall in-line with, of course. Something else could also succeed by satisfying them. But I also don’t really see anything else, aside from Bitcoin and maybe Ethereum, falling in line with these core principles.

So: while I wish that Urbit was more mature and ready to capture those that are being purged from mainstream social media, are bored with it or are frustrated with the constraints of ‘productivity software’ — I think this conflict is going to drag on until people realize that what we’re in conflict with is the structure of the software we use. Using software that’s managed by other people is always going to cause serious problems all the way up at the user level. For more speculation on how this might play out, watch Black Mirror.

2 -

(1) is, in a way, a long-winded way of saying that the state of the world hasn’t changed our direction all that much. In order for Urbit to be approachable to use, it has to be very nicely made and that takes time and iteration. As the system stabilizes, Urbit can evolve in a more traditional way: we, along with others in the ecosystem, release stuff, observe how people use it, and try to make it better. We’re at the point where we’re nearly ready to get into that feedback loop, and we very much need to get there. We’re close.

Urbit is a distinctly different _kind_ of software than anything we have now. Your Urbit is something you actually own and can do whatever you want with: not unlike your furniture or your kitchen tools. An Urbit is a tool for individual, human-scale computing and our whole approach to designing and making things is completely different. Most computing is about industrial-scale computing: where the software system stores everyone’s data and is managed by the people who build it.

Urbit is the opposite of industrial-scale. Urbit is much more like something that’s carefully crafted and delivered to you directly. This craftsman-like approach to building software really isn’t a part of most modern software engineering.

When I think about this from the standpoint of the person using what we make, it’s especially important. Urbit should feel like something that’s purposefully made by hand — not something you picked off the shelf at Wal-Mart. Some of this ethos was present in the early PC movement, but it’s mostly lost today. The care and attention that goes into building the system is also exactly what we make money on. People pay us to own a piece of it, to use it. We’re incentivized to make nice things, in the Urbit model, and we take that responsibility seriously.

3 -

Networks are a really important social form that’s only just beginning to come into existence. A network is neither a state nor a company, but something in-between. Bitcoin is a network, Ethereum is network (but it’s still far too centralized). Urbit is a young network.

(In my view, a real network is always decentralized. Centralized networks are basically just companies.)

Urbit is controlled by the collective of people who use it — in varying degrees, of course. The main thing is that this collective is bound together only by private keys and a blockchain, not a set of legal documents. The agreements between everyone on the network are in some cases more formalized (in terms of ownership) and looser (in terms of content moderation) than what we’re used to in either a state controlled or company controlled model. This is a very unusual kind of institution.

On a successful Urbit network, Facebook, Airtable, and Signal are just successful applications. You could probably build companies around them that ship software to Urbit — but they’re more like 5 - 10 people instead of thousands.

Urbit doesn’t aim to eat away at the government per se. Instead, it’s an important communication tool for institutions of any scale to actually take control of their means of collaboration. The efficiency of inter-government communication and government to populace communication can clearly be improved by _a whole lot_.

4 -

The most important thing is that people can generate a vision of the future. This can only emerge from a small collective of motivated people. Our public life is overwhelmed by people shooting from the hip, aiming for likes.

There are difficult, infrastructural problems _all over the place_ that desperately need the considerate attention of small groups of people. Urbit, as communication tooling, is aimed at improving the quality of the fabric that binds these groups together. Or, to put it another way, before you can solve any specific problem you have to improve the problem solving process overall. Everything is gated on solving the process.

5 -

Christopher Alexander is, indeed, probably the biggest influence on my thinking when it comes to paying close attention to making things that both generate a deep sense of connection and are shaped by the people who inhabit them.

[http://en.bp.ntu.edu.tw/wp-content/uploads/2011/12/06-Alexander-A-city-is-not-a-tree.pdf](http://en.bp.ntu.edu.tw/wp-content/uploads/2011/12/06-Alexander-A-city-is-not-a-tree.pdf) is one of his early, well known essays that’s easy to find online. I think ‘The Nature of Order’ is the thing that had the biggest impact on me, but it’s harder to find. There’s probably a PDF floating around on the internet somewhere. It's also a beautiful (four volume) book. The first volume kind of nails it. This talk is also great: [https://twitter.com/urbit/status/1148030042846326784](https://twitter.com/urbit/status/1148030042846326784)

The thing that comes to mind lately is Hejduk. He had passed away by the time I was at Cooper, but I feel like I was educated in the ghost of his work. This documentary gives a good impression of his thinking: [https://www.amazon.com/John-Hejduk-Builder-Worlds/dp/B07NKQ72C8](https://www.amazon.com/John-Hejduk-Builder-Worlds/dp/B07NKQ72C8)

Hejduk was able to see that architecture isn’t about building buildings per se, but something else. That was always quite obvious to me.

Talk soon!  
G
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Models of Society]]></title>
            <link>https://urbit.org/blog/20201119-models-of-society</link>
            <guid>https://urbit.org/blog/20201119-models-of-society</guid>
            <pubDate>Wed, 18 Nov 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
_I had used Facebook and Google for my entire adult life. I knew they were toxic but I didn't know why. For a few weeks I tried to create a website that would scrape data from Facebook’s API and push data back, puppetting it from my own server. But as I stared headlong into the ever-shifting darkness of the modern web, I despaired and abandoned my attempt. Less than a year later I heard about Urbit. Technically, it went way over my head&mdash;but socially I knew exactly what it was, what it always had to be, why it was a discovery and not an invention, a place and not a product. I've watched the settlers there for four years, only just now using the opportunity of the pandemic to swim to this new landscape and gaze upon this young nation, this digital city, this urbis ec bit. I do not work for Tlon. I just live here._

<hr>

All people like to talk. Society is built by talking. In this&mdash;the year of our Lord two thousand and twenty&mdash;for many (maybe most) talking means typing on computers: handheld, laptop, or desktop. Computers can do all sorts of interesting things, like aid in designing buildings or simulate protein folding&mdash;fundamentally, a computer is a machine for doing math really fast. But computers can be networked, which turns them into tools for communication. Because society runs on talking and because computers enable us to do that, the most common thing that computers end up doing is to transmit human thoughts in text. Normal people call this writing, which is a kind of talking. Let’s call it messaging. When we think about building a good computer&mdash;and computer network&mdash;one that serves society in the best ways needs to do messaging well. Only a small percentage of people will regularly do anything else. (Urbit does serve those needs but I will leave that explanation to more capable minds.)

## Modes of Messaging

<br>

![Ludovic Maclellan Mann examining the Cochno Stone](https://media.urbit.org/site/posts/essays/cochno-stone.png)

<br>

In general, technology serves humanity as a kind of appendage&mdash;instead of thinking new thoughts or acting on its own, it does what we command. Technology never creates new social structures&mdash;it merely makes existing ones easier, or it facilitates the creation of new ones. We use our tools to expand our capacities, and once we are capable of doing more, we can imagine new things to do. Inventing the wheel did not invent motorized transportation&mdash;but it did facilitate it and it was a necessary step, even an inspirational one. Similarly, the invention of writing made new forms of human interaction and new tools for organization possible.

Consider the following conversational conventions, or modes of messaging: a letter; a dialogue; a book; a meeting; minutes of that meeting. These are each pieces of technology: finely constrained solutions to human problems. Now, we have digital forms of each of these which diverge variously from the original. A letter becomes an email. A dialogue becomes a chat room, or a series of blog posts, or a twitter spat. A book becomes a website or an ebook. Meetings in 2020 have virtually been replaced by their virtual counterparts. Minutes become recordings or transcripts.

Although we do not have a clear picture of how humanity developed the technology of writing out of the basic capacity for speech, we can imagine that the computerization of writing has many parallels. It does not make the old tools obsolete, nor does it immediately introduce new social structures. It does create the potential, however. On the timeline of human existence, we have only had digitized text for a relatively short time. Because we want to understand how to best use these new forms, we should look at their underlying structure.

In order to digitize messages well, computers need to reconcile two facts about all modes of messaging. They have:

1. One basic shape, and
2. An infinite variety of forms.

1 &mdash; The basic shape: all these modes have one common substance: human language. Any conversation is made of words. At first we only had spoken language. Then we discovered writing. Writing allows us to encode our words as glyphs to transmit them over time or distance. The internet extends this capacity. We called this "hypertext"&mdash;like good old fashioned text, but one level up. A staggering amount of messaging now takes place over this hypertext transfer protocol (http). In the process of digitizing language, we have learned the basic shape of a message. We can see this in how every social network shares messages in basically the same shape: an author, some content, references, an audience. We can confirm this basic shape by comparing it against our experience of the real world, and the previous comparison between speech and writing. Speech and writing both use the same substance, and take the same basic shape. They all have an author, content, references, and an audience.

2 &mdash; Our experience of this one basic shape takes an infinite number of forms. The examples above (letter, meeting, &c) are just a few. These forms depend on the content of the message, the people involved, and the place they occur. All three aspects contribute significantly to its form, but the one that computerized messaging has not adequately compensated for is the place. Content depends only on the author and their intent. Getting certain people to view that content might be more difficult but most know how to use a computer. The place however, has not yet been adequately compensated for, and I think that has contributed seriously to our lack of civil and serious discourse over the internet. A president would not give an address in a bar, and a prospective lover would not utter his advances on stage. In writing, we can use the different physical forms to distinguish place. You shouldn’t read a book by the pool. You might not read a letter in public. You wouldn’t put a billboard in your bedroom.

Furthermore, it seems possible that in our eagerness to "connect the world," we focused injudiciously on creating communities around "interests." Evidence suggests that unless the interest has a highly refined focus, these communities devolve into pandering, self-reference, and exploitation. In this way, the internet is something like a convention of conventions, where you wander in a sea of foreigners loosely affiliated by interest and surrounded by advertising booths. In physical space, people do gather by interest but they also gather by physical proximity&mdash;they are grounded and bound in place.

Having an indistinct sense of place makes the form of conversation ambiguous and the participants of the conversation disconnected. Consequently, people are unsure how to interact. One need only know the term "comments section" to understand that.

## People in Places

<br>

![Halle Saale Marktplatz](https://media.urbit.org/site/posts/essays/halle-saale-marktplatz.jpg)

<br>

As the internet grew to accommodate new conversation forms using the basic substrate of hypertext, web developers began to conceive of "digital spaces" through analogy&mdash;chat "rooms" and "forums,” or the "silo" and the "walled garden." Today, most of our conversation takes place in these walled gardens&mdash;privately-owned places which may be beautiful on the inside, but inaccessible from elsewhere. While some of these walled gardens are very large, our conversation is essentially confined to them. There is no roaming from one space to another while keeping one’s identity. We create new identities for new spaces both because we must and because we are afraid of repercussions on one platform for what we say on another. This is because we do not own our identity; we merely have a key&mdash;our password. The owners of the walled garden still own the artifacts of our tenure there, and can revoke our access to them at any time.

The concept of identity and the concept of place are fundamentally linked. We imagine the prince who travels overseas where no one knows his name, or we imagine the old prospect of traveling to a new world to make a fortune. While those both exemplify a dramatic change in identity and place, we usually want to keep our identity consistent. We want to be recognized by friends whichever place we go, and we all strive toward having a good reputation, which is a consistent identity across places. This consistent identity also allows control of that reputation per place. A man is not judged in public by the words he says among friends. And there is no way to search what someone has said except by asking him. With our current system of identity providers (an absurd term, but a real one), we surrender our rights to selectively expose our thoughts, regardless of the place they have been uttered. A data breach or a weak password might lay bare our most private thoughts. We run the real risk of being confronted by an old conversation presented out of context or after we have learned better.

People need distinct spaces to form conversations in distinct modes, and they need to have a consistent identity that controls how public their words are.

In theory, we would have a digital city with unique regions, public fora, and sovereign parcels, into which one person might travel at will. In practice, we see this pattern: an app emerges to facilitate a mode of conversation. It gains popularity. Facebook (or Google, or Microsoft) buys and absorbs it. As monolithic empires, they can use the same format for all their messages. This gives them a great amount of power. They use this power to create things like "Sign in with Facebook" (or Google, or Microsoft) that benefit the user by consolidating their identity, but fail to solve the underlying problem. Their problem is that in order to allow people to communicate using the current technology stack, they need to be in control of everything.

## Urbis ec Bit

<br>

![View of Florence from San Miniato](https://media.urbit.org/site/posts/essays/view-of-florence.jpg)

<br>

Urbit does solve this underlying problem. At this point the explanation goes so far down the stack that you could spend years tracing it all, but the relevant part is this: Urbit is not an empire; it’s a territory. An empire is an entangling of land and rule: within the bounds of said empire, you agree to be bound by its laws and the penalties for transgression. The laws exist at the whim of a despot or cabal. Your standing as a Roman citizen buys you no favors in Persia. In contrast, a territory imposes only physical laws. For example, in the desert, you will die faster. The only way to change that is to alter the desert. Urbit imposes nothing but the digital equivalent of physical laws. You have an identity which can be said to be truly yours, and you have a piece of software that runs on whatever computer you choose and can do anything you want with the messages sent to your identity. There are no social protocols enforced, because no one can control what software you run on your computer. As long as you agree to communicate using the same basic substrate, you can communicate with anyone using Urbit. This is the digital equivalent of speaking the same language. Whether or not others will accept you into their coalitions is not the technology's concern.

In the same way that the land provides clay and timber, Urbit also provides the tools and material for building places both public and private. These include the aforementioned consistent message substrate (content), as well as tools for organizing people/audiences, structure for referencing other content, and an identity system that is owned only by you while being verified by all. The places are being built&mdash;private rooms with just a few people, meeting halls, club houses, huge public spaces, and countless personal encounters, the contents of which are known to none but the participants.

The default tools work with messages in a few of the ways with which we've grown familiar: chat, direct messaging, publishing, link-sharing. They map onto existing forms of messaging because as I said earlier, the technology does not create new social structures; it just facilitates them. We have only seen the beginning of what the internet is capable of doing. Within a few decades it replaced the majority of letters, phone calls, and text dissemination&mdash;that was just the first phase of getting up to parity with what written text and speech could already do. In order to get to the next phase of creating new social processes, we need our technology to be organic and democratic, in the sense that everyone can participate and shape it. It needs to have a consensual foundation&mdash;a common substrate&mdash;and infinite possibility for expression. Urbit provides both of those.

Similar to working undeveloped land, it takes a lot of hard work, which is why Urbit is not ready for mainstream adoption yet, and why I alluded to the idea of settlers in my opening paragraph. Traveling to the new world is not for everyone, but everyone is welcome.

_How could one do other than submit to Tlön, to the minute and vast evidence of an orderly plant? It is useless to answer that reality is also orderly. Perhaps it is, but in accordance with divine laws&mdash;I translate: inhuman laws&mdash;which we never quite grasp. Tlön is surely a labyrinth, but it is a labyrinth devised by men, a labyrinth destined to be deciphered by men._
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Aesthetic Culture #1]]></title>
            <link>https://urbit.org/blog/aesthetic-culture-1</link>
            <guid>https://urbit.org/blog/aesthetic-culture-1</guid>
            <pubDate>Wed, 11 Nov 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![A set of four sigils arranged & coloured to appear as various natural forms, above the ~sorwet sigil & the text "help the environment and help yourself"](https://media.urbit.org/site/posts/essays/help-the-environment.jpg)

<br>

_This post is the first in a series of digests centered on art produced within and about Urbit by a member of the community, ~nartes-fasrum. Monthly digests will be available within the Urbit Community group in Landscape, and will occasionally be compiled here on the blog to give you a sneak peek at some of what’s happening on the network. Enjoy! ~wolref-podlex_

One of the most exciting things about Urbit is the aesthetic and design around it, developed partly by Tlon (through the design of Urbit itself) and partly by the community (by producing great Urbit art). As the community grows, it creates more art, and we have the opportunity to showcase some of the pieces we love. These works can draw curious new users in, and they give existing users ways to communicate their excitement to friends.

To that end, I wrote [the Art by Urbit proposal](https://grants.urbit.org/proposals/636838408-art-by-urbit), a regular digest for the dissemination of Urbit art and propaganda. We'll bring you the works of both familiar faces and new users, in a variety of media types from image manipulation to 3D models and physical pieces. This first digest will cover some of the art produced in the past year, but will have a focus on the last two months. Future digests will be incremental updates summarizing the artworks of the prior month.

## ~datnut-pollen

~datnut- made a physical representation of their sigil from maple wood & epoxy resin, and mentioned the potential to use an Arduino to cause different lighting effects for different statuses of an urbit.

![The sigil of ~datnut-pollen glowing yellow on a black background](https://i.imgur.com/GxmO6sT.jpg)

## ~lagrev-nocfep

~lagrev- [made a thread of Dinosaur Comics](https://twitter.com/sigilante/status/1299101593997127680), using the Urbit Whitepaper as the seed text.

![A Dinosaur Comics comic, with text pulled from the Urbit Whitepaper](https://pbs.twimg.com/media/EgdUaoKWoAAl6A3.jpg)

A sweet poem about the potential for Martian felines is theirs as well:

![A brief poem regarding cats on Mars](https://pbs.twimg.com/media/Ef_KTbqWAAAHN-k.jpg)

## ~litmus-ritten

~litmus- produces art full of glowing gases and colourful curves:

![A hand holding a glowing orb, underneath the text: "Urbit - Lunar Operations"](https://i.imgur.com/fRbFIpj.png)

~litmus- also drew Urbitan for the release of OS1:

![An cartoon-type female character holding an orb, standing in front of a fan of Urbit sigils](https://i.imgur.com/vGqVmNM.png)

More of their work is available in the notebooks of the Internet Weirdness Research Unit.

## ~minder-folden

~minder- stylistically ranges from retrofuturistic memes to flat-out classic 50s retro:

![An image of a meteor shaped like ~minder-folden's sigil in front of Mr. Clean, with the text "Soon it will all be clean"](https://pbs.twimg.com/media/Eggk0CGU8AAJC-W.jpg)

![A Popular Science cover advertising "Video-Disc Players", with ~minder-folden's sigil present on a television](https://minderimages.nyc3.digitaloceanspaces.com/1ib61l8ugy451.jpg)

More of ~minder-’s work is available in his The New Era notebook.

## ~naltyc-wornes

~naltyc-, & by extension ~dasfeb industries, produces content related to the exploration of Urbit on small & unique computers:

![An image of five astronauts wearing Urbit badges strapped into a spaceship cockpit, with the ~dasfeb logo & a Raspberry Pi on the wall behind them](https://pbs.twimg.com/media/EkiyfGbVgAAp8wm.jpg)

![An image of a large, early computer control panel with the ~dasfeb sigil on the upper wall and a number of planet sigils on display readouts](https://pbs.twimg.com/media/Ejap_knXgAARo38.png)

More of their work is available in the smol computers group.

## ~nartes-fasrum

I use GIMP to edit images I pull off various social media platforms, and usually post the results on Twitter at [@nartesfasrum](https://twitter.com/nartesfasrum).

![A set of four sigils arranged & coloured to appear as various natural forms, above the ~sorwet sigil & the text "help the environment and help yourself"](https://pbs.twimg.com/media/EjuuJjTXsAIcfU9.jpg)

## ~norsyr-torryn

No discussion of Urbit art would be complete without mentioning [~norsyr-'s Canvas app](https://github.com/yosoyubik/canvas), which won first place in the [Hackathon 2020](https://urbit.org/blog/hackathon-results/) event.

![A demo image of the Canvas app, with various drawn characters](https://i.imgur.com/zpm3dYX.png)

## ~radbur-sivmus

~radbur- writes poetry on a range of subjects, one of which could be Urbit. Interpretation of ["A Weaver's Regard"](https://t.fust.us/writing/poetry/weavers-regard) and ["Internet Absurdities"](https://t.fust.us/writing/poetry/internet-absurdities) is left as an exercise to the reader.

## ~sitful-hatred

~sitful- has a Martian Meme Depository chat in the Networked Subject group, which catalogs a number of the Urbit memes that have been created so far.

![An image of a Connect-Four type game box, edited to read “Connect ~zod: The Classic Network Connectivity Game](https://i.postimg.cc/d1yH7PHL/connect.png)

## ~tocrex-holpen

~tocrex- has been drawing the galaxies of Urbit, and uploading results to Twitter at [@tocrexholpen](https://twitter.com/tocrexholpen). Each galaxy has a unique design and outfit, with the galactic sigil proudly displayed as its face.

![An image of the ~feb galaxy wearing elaborately embossed armor.](https://pbs.twimg.com/media/ENeLOb4WkAApDu2.jpg)

## Landscape

Something that's become quickly evident with the addition of background images to Landscape is that people love to customize their ship's appearance and make it feel more like home. To close things out, we're providing a pair of backgrounds — one darker, one lighter — for use on your ship (or your desktop, should you so desire).

![A moody Martian city](https://i.imgur.com/7Ot9Hcu.jpg)

![A bright outing in a young ship](https://i.imgur.com/wFKt2EW.jpg)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit Events Series]]></title>
            <link>https://urbit.org/blog/events-series</link>
            <guid>https://urbit.org/blog/events-series</guid>
            <pubDate>Thu, 29 Oct 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![people gathered](https://media.urbit.org/site/posts/essays/bau.jpg)

<br>

_TL;DR: Urbit is launching a series of community events, the first of which is a developer call taking place on Thursday, November 5 at 9am PT. [Sign up here](https://www.meetup.com/urbit-sf/events/274279522/), and read on for all of the details._

--

If you’re familiar with the project, you’ve probably noticed that Urbit folks talk a lot about the fact that [Urbit is for communities](https://urbit.org/blog/urbit-is-for-communities/). This is central to what Urbiteers believe: Urbit is a platform that any group of people should be able to use to build, communicate, and transact in precisely the way that makes sense to them. Today, Urbit is already capable of facilitating many of these activities, and it’s already a big part of the daily workflow for many people. I think we’re off to a pretty good start, and over time Urbit will become accessible to more communities.

Something we tend to talk less about is the fact that Urbit itself is also a community. If you’ve spent any amount of time hanging out in Landscape in the Urbit Community group, you already know this—but getting to know the community takes time and effort.

One of the reasons you don’t hear about the Urbit community as much is that community is difficult to pin down: you'd be hard-pressed to put "the community" into a room together. It's a weird, fuzzy notion and doesn't have clear boundaries.

Other parts of Urbit do have clear boundaries. If you decided to learn more about Urbit, chances are you started by reading the docs. You might learn about [Nock](https://urbit.org/docs/tutorials/nock/), [Hoon](https://urbit.org/docs/glossary/hoon/), and [Arvo](https://urbit.org/docs/glossary/arvo/). You might get an [Urbit ID](https://urbit.org/understanding-urbit/urbit-id/) and [launch your own ship](https://urbit.org/getting-started/). These things are all pretty well documented and, while not necessarily easy, their respective processes are relatively straightforward and [getting easier](https://urbit.org/blog/hosting-the-future/) every day. Community is less well documented. It’s more difficult to document—it’s something you just have to experience.

We lead with technology because it’s what we’re good at and because it’s easier to write about. But the social side of Urbit is no less important. Since so many of us are working on and contributing to Urbit in order to solve our own problems, and since we’re dogfooding as we go, you could define Urbit as the minimal technological infrastructure needed to sustain the Urbit community. It’s circular, but it’s as good a definition of Urbit as you’re likely to find. For this reason, you can’t really understand Urbit without some degree of exposure to the cultural knowledge of its community. When the Urbit community did fit in a single room together, transmitting cultural knowledge was easy and happened over pizza and beer. As the number and diversity of Urbit stakeholders continue to grow, we need to find ways to scale the transmission of this cultural knowledge.

One way that seems to work well is getting everyone together once in a while for events. Over the last few years, I and others in the community have collectively attended hundreds of community events, virtually and in person around the world, from small developer chats to massive, global developer conferences with thousands of attendees. Urbit has even hosted [a few of our own](https://www.meetup.com/urbit-sf/).

As a newcomer to the Urbit community I recently found myself seeking exposure to cultural knowledge. I know from experience attending and organizing events in other communities that regular events are a good way of making this knowledge more accessible, and of helping newcomers like myself onboard. I applied for [a grant](https://grants.urbit.org/proposals/1751024973) to bootstrap a new event series, and I’m excited to announce that this series is launching next week with the support of [urbit.org and the grants program](https://urbit.org/blog/first-steps-towards-urbit-org/).

The event series has three components. The first is a series of developer calls. These will be shorter and more narrowly focused on the technologies that underpin Urbit, from the top of the stack to the very bottom. They’re an opportunity for the people developing and contributing to Urbit to share their knowledge and expertise, including things that typically don’t make it into the docs, such as how and why Urbit works the way it does. It’s recently become much easier to build applications on top of Urbit, so I hope these events will help developers see what sort of things they can already use Urbit to build, and how to get started. These events are also an opportunity for Urbit contributors to share real-time updates that don’t make it into this blog, and for the community to get to know the contributors (and one another!).

The first developer call will take place on Thursday, November 5 at 9am PT, and you can [sign up to attend here](https://www.meetup.com/urbit-sf/events/274279522/). The second call will take place two weeks later on Thursday, November 19, and we’ll continue holding these calls about every two weeks.

The second component is a larger Town Hall event to take place on Thursday, December 17. The Town Hall will feature multiple speakers and will cover topics including technology but also design, community, and our overall progress towards our vision for Urbit. You can think of it as part show and tell, part “State of the Network,” part meet-and-greet.

The third component is a larger conference, tentatively called UrbitCon, to take place early next year. This event is still in a conceptual phase. It’ll be an opportunity for the global Urbit community to celebrate how far the project has come, to share technical as well as cultural knowledge, and, maybe most importantly, to hang out together and have some fun as well. Watch this space for more information on the Town Hall and UrbitCon.

Collectively, these events allow the community to achieve several goals. Firstly, they’re a great way for community members to meet one another, exchange cultural knowledge, and share what they’re working on. Events provide excellent motivation to get something that’s a work-in-progress to a state where you can share it with others!

Secondly, the content from these events will be recorded and published, and will form the cornerstone of a new knowledge base on urbit.org that will augment existing documentation. This will make it much easier for newcomers, even those that can’t attend the events live, to benefit from the wealth of knowledge and expertise of the Urbit community.

Finally, these events are a great opportunity for community members to contribute things other than code. While Tlon will provide speakers for the first few events of the series, it’s important to emphasize that the initiative is entirely community-led and that we’ll need lots of help to organize and host events. If you’re interested in helping out with any of the events in the series, please find me and others helping out with events on Landscape in the Urbit Community group (the channels called “Events Series”).

They say that a project’s community has reached critical mass when new things are happening that even the project’s earliest and most active contributors aren’t aware of. By this standard, the Urbit community reached critical mass sometime in the past few months, as even core team members tell me they’re regularly surprised to learn of another new project or initiative launched by a community member.

Tlon could no longer catalog the Urbit community even if it wanted to. This is a good thing. As Tlon [has also said](https://urbit.org/blog/hosting-the-future/), it’s natural that Tlon and Urbit drift apart a bit over time. Just as Urbit itself is self-hosted, so the community, over time, should become self-hosting: it should play a more active role in shaping the future of the project. A community-run event series can be an important catalyst for this trend. I’m looking forward to the first event, and I hope to see you there, and at many events to come.

--

_Sign up to attend [the first event](https://www.meetup.com/urbit-sf/), and join the channels called “Events Series” on Landscape in the Urbit Community group to get involved._
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from Tlon + urbit.org]]></title>
            <link>https://urbit.org/updates/2020-10-29-update</link>
            <guid>https://urbit.org/updates/2020-10-29-update</guid>
            <pubDate>Wed, 28 Oct 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Hello!

We’ve quite a few updates for you this month which are covered in detail below—that said, it’s important that you know that our newsletters are splitting in two: one will continue to come from Urbit, and another from Tlon. Practically, that means that you’ll get another email from Tlon in about two weeks. Read on for more details!

1 - Developer Calls

Developer calls are coming (back)! A member of our community, ~naplet-hildec, is leading the charge to reintroduce regular calls for Urbit developers to gather and learn from one another. Each call will feature a different speaker that will present on a specific topic, followed by a Q&A. Calls will last an hour and will be held roughly every two weeks.

Expect a detailed overview on our blog (https://urbit.org/blog), announcements on https://twitter.com/urbit, and within Urbit Community soon! For now, save the date: the first developer call is on Thursday, November 5th (12PM ET, 9AM PT, 5PM UTC), and will feature a discussion about graph-store by Tlon developer ~tacryt-socryp.

2 - Weekly Design Streams

Tlon’s design team will stream for an hour every Friday (5PM ET, 2PM PT, 9PM UTC). Expect discussions on current projects, thoughts on Urbit interface design, live QA sessions, and more.

Tune in here: https://www.youtube.com/channel/UCyBGqTPD2uj9kbEJsxWnRxQ

3 - Hoon School

If you’re interested in learning hoon, check out Hooniversity—the home of Hoon School—at https://hooniversity.org/. If you’re ready to enroll, join the Hooniverse group via public channel ~hiddev-dannut/new-hooniverse. You can also find them on Twitter as hooniversity1 or via email at join@hooniversity.org.

4 - Tlon + urbit.org Newsletters

“Ultimately, Urbit presents more possibilities than any one organization can manage.”
~wolref-podlex

If you’ve been following along with our recent dispatches, you probably know that there are some exciting changes afoot. Tlon, the company building Urbit, has been developing a plan to separate itself from the governance of urbit.org (https://urbit.org/blog/governance-of-urbit/) for quite some time. Over the past few months, we have taken concrete steps to make this separation real. It might be a good idea to revisit ~wolref-podlex’s post (https://urbit.org/blog/first-steps-towards-urbit-org/) from this summer, where he discusses what led us here and why we’re doing this now.

Urbit has matured to the point that Tlon can become just another entity in the Urbit ecosystem, so we need to separate the updates about Tlon-specific things from Urbit-specific things. Going forward, communications from Tlon and urbit.org will be issued as separate newsletters, with Tlon’s focusing on Landscape and the communities that form there, and urbit.org’s centered on Urbit’s infrastructure and community-led initiatives.

Thus, this marks the last urbit.org + Tlon newsletter—in a couple of weeks, you will receive a newsletter from Tlon. You can manage your preferences for both of these newsletters independently by unsubscribing with the footer links.

Getting on Urbit is now a lot simpler: Tlon’s hosting service is live. Join the waitlist at https://tlon.io.

That’s it for now. See you on the network!

~roslet-tanner and ~wolref-podlex

https://twitter.com/urbit
https://github.com/urbit/urbit
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from urbit.org]]></title>
            <link>https://urbit.org/updates/2020-12-01-update</link>
            <guid>https://urbit.org/updates/2020-12-01-update</guid>
            <pubDate>Wed, 28 Oct 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Hello!

As the year of “but wait, there’s more!” draws to a close, we have some big news of our own to share:

1 - Network Breach

Easily the biggest and most important news this month is that another network breach is coming at the beginning of next week. For the unfamiliar, this is when the entire network is effectively reset in order to apply a more foundational change than can be done with an OTA. The specific update in question that’s going out is Arvo/Vere version negotiation. This is a big milestone that enables Vere and Arvo to be updated independently without worrying about version incompatibilities.

Any form of breach, network or personal, means that your ship will be reset to a blank slate. In the past this meant that all of your data would be lost, which usually wasn’t an issue due to the immaturity of user space software.

Fortunately, big changes in Urbit are becoming less and less catastrophic in 2020: Tlon will be providing a special tool (called “flagday”) that can be used to back up your ship, export your data, and re-import everything into your fresh ship.

The folks at Tlon are pretty sure that this will be the last time we have to deal with one of these, but it’s hard to say. What’s clear is that the impact of a network breach on the community is being taken seriously, given the work put into tooling for the preservation of user space data.

Make sure to read the full FAQ here on https://urbit.org/breach, which will be kept updated throughout.

2 - Urbit Events Series

In our last newsletter we announced the return of developer calls, and I’m pleased to say that we’ve done two over the past month, both of which have gone very well. Our first call featured Tlon engineer Logan Allen (~tacryt-socryp), with a discussion about graph-store, and our second call featured Mark Staarink (~palfun-foslup), who discussed the BitTorrent tracker and corresponding CLI he built.

You can find both of the recordings on our YouTube channel at: https://www.youtube.com/channel/UCNYIS9_SktINCC9yqO4CFZw/featured.

The next developer call (and last of 2020) will be held on Thursday December 10th, which will feature a discussion by ~timluc-miptev, a member of our community who will be discussing the Bitcoin system he’s built to enable ship-to-ship payments within Urbit.

In January of 2021 we’ll be putting on our first Town Hall. This will be a three hour event with multiple talks that aren’t solely development focused, a keynote presentation, and some other fun stuff. If you’ve got a talk you’d like to give, a project to show off, or something you’d like to see discussed, please reach out to ~wolref-podlex in Urbit or via email at josh@urbit.org.

3 - Community Content on the Blog

“In order to get to the next phase of creating new social processes, we need our technology to be organic and democratic, in the sense that everyone can participate and shape it.”
~radbur-sivmus

In November we saw two posts on the blog from community members.

Aesthetic Culture (https://urbit.org/blog/aesthetic-culture-1/) was posted by ~nartes-fasrum, who compiled art from all over Landscape into a digest. This is the first in a series, many of which will be exclusive to the Urbit Community group in Landscape.

Models of Society (https://urbit.org/blog/20201119-models-of-society), an essay by ~radbur-sivmus, explores modes of messaging, the importance of a sense of place in communication, and how Urbit provides the fundamental substrate for facilitating new forms of societal processes.

Our blog will continue to feature regular updates from the folks at Tlon, but it’s exciting to be able to feature content from our growing community about a broader range of topics.

4 - Hoon School Hiatus

Hoon school is going on temporary pause after the conclusion of the current batch.

I’ll be working with our instructors, ~risruc-habteb and ~rabsef-bicrym, to synthesize their learnings from the many classes given in 2020 and design a new curriculum for 2021.

We’re pretty excited about what an updated course will look like. I can’t go into details yet, but at a high level we’ll be looking to give a more holistic overview of the system through development of practical, full-stack Urbit applications.

--

You would think that a network breach would be a worrisome event. With so much effort having gone into creating groups and the content within them, it’s easy to imagine that a network breach, even with flagday, would pose a serious threat to community engagement.

Personally, I’m not worried at all. The vibe in the room over at Urbit Community is, as usual, calm. From my perspective the greater Urbit Community is more engaged than it ever has been: between the degree of engagement throughout Landscape groups, the steady stream of new projects being undertaken, to the ongoing commitment shown by many community members to continue building on Urbit, it has become clear that Urbit is indispensable to lots of people.

That’s all for now. See you on the network!
Josh / ~wolref-podlex

https://twitter.com/urbit
https://github.com/urbit/urbit
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hosting the Future]]></title>
            <link>https://urbit.org/blog/hosting-the-future</link>
            <guid>https://urbit.org/blog/hosting-the-future</guid>
            <pubDate>Wed, 30 Sep 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![Ocean](https://storage.googleapis.com/media.urbit.org/site/posts/essays/200930-hosting-by-tlon.jpg)

<br>

Urbit users tend to be interesting, creative, and capable people; we’re genuinely impressed with the communities that have formed on the network, and with the quality of discourse there. But for the number of communities to continue to grow, getting on the network has to become dramatically easier. It’s not realistic to expect most people to configure their own Urbit OS node in the command line.

At the moment, the biggest lever we have here is to help ordinary users get online, so they can participate in communities inside Urbit, and eventually form their own. This means hosting their Urbit nodes and showing them around the network when they first arrive. There are already several businesses overlapping with this space to varying degrees: [planet.market](https://planet.market/), [urth.systems](https://urth.systems/), and [geturbitid](https://www.geturbitid.com/). Now, Tlon is releasing its own hosting offering. For the uninitiated, “Hosting” just means that we run your urbit ship for you, making it easier for you to get onto the network. We’ve been testing our hosting service with friends and family for the past few months, and now we’re ready to bring it to the rest of the world.

To learn more about Tlon hosting and sign up for the waiting list, check out the new [tlon.io](https://tlon.io/) website. We are officially launching the service on October 9th, with a virtual event and demo; we’ll also show off some of the new features and improvements to Landscape, the Urbit web client.

To be very clear, hosting isn’t for everyone; if you’re deeply security-conscious or privacy-oriented, you’ll still want to self-host so that nobody else needs to touch your keys. That said, hosting isn’t a walled garden; you’ll get a planet when you sign up for hosting, which you will own 100% and forever. You’ll also always have the option to roll up your data and take it with you if you choose to stop using our service. Your Urbit data is just a single file, and we’ll happily hand it back to you if you ever decide to leave. Nothing will ever stop you from self-hosting.

We’ve talked for a while about how the ultimate destiny of Urbit is to escape the control of Tlon. For Urbit to really succeed, it has to be managed by its own community. We started Tlon in order to solidify the foundation of this young platform. Now that Urbit is starting to grow up, Tlon and Urbit will naturally drift apart a bit.

Urbit is meant to be universal, ubiquitous infrastructure. Tlon exists to make that infrastructure useful and usable. We expect Urbit, as a platform, to be cared for by the community in collaboration with the emerging [Urbit Foundation](https://urbit.org/blog/first-steps-towards-urbit-org/). We intend Tlon to become increasingly focussed on providing a great user experience for anyone interested in this new network, so the network can continue to grow and thrive.

The way we see it, hosting is the most important thing, next to Landscape, that Tlon can do to help Urbit continue toward widespread adoption. We don’t expect to be the only ones providing this service—and look forward to including more contributions from the community here on urbit.org as they continue to mature.

If you’re curious to keep up with what Tlon is doing here, head to [tlon.io](https://tlon.io) and join the waiting list. We’ll be posting updates to that list as well as to the Tlon Transmissions notebook in the Urbit Community group. Going forward we’ll do our best to keep urbit.org neutral and focussed on the technology itself.

See you all on the network!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from Tlon]]></title>
            <link>https://urbit.org/updates/2020-09-30-update</link>
            <guid>https://urbit.org/updates/2020-09-30-update</guid>
            <pubDate>Tue, 29 Sep 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Hello!

And just like that, it’s Autumn. We’ve disappeared into Urbit these past few months and have been hard at work, building great things:

1 - Tlon Hosting

Tlon, the company we started to get Urbit off the ground, is now offering hosting. This makes using Urbit about as easy as using any mainstream app. We’ve been enjoying using Urbit ourselves quite a bit, and we’re really excited to be able to more easily invite our friends.

Sign up for the waitlist: https://tlon.io.

There’s a secret to moving ahead in the line: reply ‘as if in a still pool’ to the question ‘How’s your day going?’ in our questionnaire. We’d like to make sure everyone on this list can get access as soon as possible.

We’re going to run a live demo showing off how our hosting service works on the 9th. You can sign up for the event here: https://www.meetup.com/urbit-sf/events/273439025/

2 - Providers

We’re not the first ones to offer hosting, it turns out. People in the community have been busy building out the first onramps into Urbit. We heard https://www.geturbitid.com, https://planet.market and https://urth.systems are all starting to come online. It’s still early, but what they have in the works is really cool to see.

We also caught wind of https://urbit.me the other day, a nice little tool for finding specific sigils.

(And we can’t forget about https://urbit.live, the first ones to get into this arena.)

I wrote a little bit about how I see the future of Urbit Providers here: https://urbit.org/blog/providers/

3 - Update + updates

There’s too much to cover in a single email, so I wrote a little post about what we’ve been working on over the past few months. Check it out on the blog: https://urbit.org/blog/20200929-state-of-urbit/

We also updated our roadmap in Understanding Urbit: https://urbit.org/understanding-urbit/roadmap/

4 - The beginning of urbit.org

We’re very happy that ~wolref-podlex has formally joined the community as Interim Director of the Urbit Foundation. We expect the foundation to become a separate entity soon, but for now we’re incubating it inside of Tlon.

Last month he wrote about how we are working to separate the governance of urbit.org from Tlon: https://urbit.org/blog/first-steps-towards-urbit-org/

Just recently, he announced the recipients of our biannual Gifts program: https://urbit.org/blog/gifts-q3-2020/

5 - Hooniversity

If you’re interested in learning Hoon, the next session of the community-run Hooniversity is set to start on October 12th.

For more information about the course, head over to the Hooniversity site: https://hooniversity.org/ and sign up for the session here: https://hooniversity.org/enroll/.

If you can't wait for the 12th, join the Hooniverse group on Urbit in advance by joining the ~hiddev-dannut/new-hooniverse group on Urbit or at https://twitter.com/hooniversity1

We’ve been pretty much living on Urbit as of late. If you’re curious to connect with us (and are up for running your own Urbit node) you can always find us in the Urbit Community group: ~bitbet-bolbel/urbit-community. Instructions on how to install and set up Urbit are here: https://urbit.org/using/install/

We love getting questions, comments, and replies to these newsletters. One thing we heard loud and clear last time around is that you want to hear more from the team. So much happened in the past few months that we have a glut of things to talk about in the coming weeks. Expect more dispatches in the near future. For the meantime, feel free to reach out via email (support@urbit.org) any time.

See you on the network,
Galen / ~ravmel-ropdyl

https://twitter.com/urbit
https://github.com/urbit/urbit
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Late 2020 Progress Update: OS 1 -> OS 1.N]]></title>
            <link>https://urbit.org/blog/20200929-state-of-urbit</link>
            <guid>https://urbit.org/blog/20200929-state-of-urbit</guid>
            <pubDate>Mon, 28 Sep 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![Grassy Knoll](https://storage.googleapis.com/media.urbit.org/site/posts/essays/state-of-urbit-1.jpg)

<br>

When we announced OS 1, in April, we started to disappear into Urbit. Since then, we’ve been living on Urbit like we never have before. This has been our goal for years: to mature the system we’re building by becoming its first committed users. We knew that critical step toward Urbit’s maturity was being able to depend on it ourselves, but the system itself had to mature to the point that we could do that practically.

We’ve done this in fits and starts. We’ve _tried_ and failed a few times over the years. We’ve always _used_ Urbit to some extent, but we’ve never _relied_ on it. These past six months have been different. I can’t tell whether it was out of sheer determination and commitment, or that the system was just genuinely ‘there’. Either way, both Tlon and the Urbit Community genuinely live on Urbit now.

In a way, our ability to use Urbit day to day doesn’t make sense. When we shipped OS 1, it was full of holes. There were serious performance, stability, and reliability issues. Plenty of people showed up and thought, ‘I don’t understand why you think this is useful.’ But, it was good enough that we wanted to use it. And since we wanted to use it, we put our energy into making it better like we hadn’t ever before. Being able to use a system that you can really trust is a wonderful feeling. It’s Computing Without Compromises.

All of the sudden, it’s Fall. We never found the time to name any of our releases or write announcements. We’ve just been making the system better in every way we can find. We’ve got a lot of exciting things planned for the last few months of the year — but I wanted to recap the progress we’ve made for those following along from the outside. If you haven’t been on the network, it’d be impossible to see.

The tl;dr is that Urbit is much faster, more reliable, and nicer to use than it was six months ago. Things have gotten much better, across the board. We threw ourselves into OS 1 admittedly underprepared, but we’ve learned a lot and matured the system a lot along the way.

Anyway, let’s walk through the details. We’ll talk about our infrastructure and interface work independently, since that’s how we organize things internally. Then we’ll talk a bit about what’s going on on the network.

### Infrastructure

![Debugging Interface](https://storage.googleapis.com/media.urbit.org/site/posts/essays/state-of-urbit-2.png)

In April, Urbit was slow, fragile, and didn’t always update itself properly. We made enormous progress on all of these.

First off, Urbit is about 10x faster for most users. With some careful debugging, we were able to locate a few really [high](https://github.com/urbit/urbit/pull/3029) [impact](https://github.com/urbit/urbit/pull/3054) [improvements](https://twitter.com/pcmonk/status/1276327036722704385). There’s still performance work to do, but the effects of this work are widespread. Boot times are faster, local compute is faster, the network is faster. It’s a huge improvement.

Second, we got our memory usage under control. Urbit still uses a 2GB memory arena. If the state of your Urbit grows to over 2GB things, uh, fall apart. This used to happen regularly, and now it’s pretty much unheard of. We implemented [tooling](https://github.com/urbit/urbit/pull/3235) to compact and deduplicate the memory image when it’s growing too large. We brought the memory usage of the compiler [down ~90%](https://github.com/urbit/urbit/pull/3041). There are areas where we can be more disciplined about how we use memory, but this is more or less a solved problem for the near term.

Third, we implemented a completely new build system. Well, we actually [got rid of the build system](https://urbit.org/blog/ford-fusion/) altogether and [made it a part of the filesystem](https://github.com/urbit/urbit/pull/3060). This made it possible for us to fix our over the air (OTA) updates and make them both fast and reliable. In April, an OTA could bring down your node and would take hours or even days to apply. Today, we regularly deploy OTAs with no fear of them breaking any nodes — they often go from galaxy → planet in a minute or less.

We also rewrote a large part of our runtime in Haskell and made overall progress on [network scaling](https://github.com/urbit/urbit/pull/3174). And: we implemented a [principled approach](https://github.com/urbit/urbit/pull/2366) to [error handling](https://github.com/urbit/urbit/pull/3064), making nodes much less likely to become unrecoverable.

The network is stable, fast, and safe from day to day. We’re pretty confident it can grow quite a bit without serious issues. When we shipped OS 1 we really weren’t sure what we could handle. Now we’re standing on much more solid ground.

### Interface

![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/state-of-urbit-3.jpg)

When we shipped OS 1 it was a bunch of separate pages (that were slow to load), all with separate ways of storing and processing data. Our interface work over the past six months is all about unification and simplification.

First, we pulled OS 1 together as a [single page app](https://github.com/urbit/urbit/pull/3025). Using OS 1 involves a good amount of moving around and refreshing the page each time was pretty painful. Now it’s snappy to move between pages and keep up with what’s going on. In tandem, we started using our own component library, [Indigo](https://github.com/urbit/indigo-react). This makes frontend development much cleaner and more efficient.

Next, we unified the way we store data and compute. It used to be that each individual module (chat, publish, and links) used their own ‘agents’ to store and process data on the Urbit side. (An agent is the Urbit equivalent of a datastore + business logic.) With a lot of moving parts, this approach caused all kinds of synchronization challenges. Rather than a module-per-agent model we’ve started to move toward a type-of-data-per-agent model. The first of these is [graph store](https://github.com/urbit/urbit/pull/3110). We’re presently in the process of migrating all our modules to graph store.

Those two are by far the most significant, but there’s so much more. We [rewrote](https://github.com/urbit/urbit/pull/2937) the `group-store`, allowing for different roles (admin, moderators, and so on) in a group. We shipped better debugging tools, automatic reconnection, a settings panel, and overall visual polish and refinement.

![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/state-of-urbit-4.jpg)

And I almost forgot [Leap](https://github.com/urbit/urbit/pull/3231): an omnibox for navigating around OS 1 with the keyboard. We have plans to make Leap much more powerful — but it’s a great first start toward making OS 1 keyboard accessible. I almost exclusively use [Leap](https://upload.wikimedia.org/wikipedia/commons/0/06/Canon_Cat_keyboard.jpg) to get around OS 1 these days.

### Community + network

![Fishing Village](https://storage.googleapis.com/media.urbit.org/site/posts/essays/state-of-urbit-5.png)

Our primary goal with OS 1 was to get both Tlon and the Urbit Community living entirely on Urbit. We did that, and in doing so we’ve seen how nice it is to grow a community in a calm, non-invasive environment. We started doing regular [Urbit](https://twitter.com/urbit/status/1308875082312364048) [Dialogues](https://twitter.com/urbit/status/1304139629948329985) with friends and peers in the absence of physical meetups, which have been fun.

Getting onto Urbit is still relatively challenging. By the standards of software you run yourself, it’s not so bad at all. But by comparison to ordinary consumer software, it’s way too hard. Tlon is [working on that](https://tlon.io) — but these last six months have been only for the brave. That is, those that want to host their own nodes.

Turns out, there are plenty of people who are up for running Urbit themselves and quite a few small communities have sprouted around the network. Overall the network has a fun, cozy feeling. It’s nice.

### What’s next

We’re still more or less flat-out, full speed ahead into an even better Urbit-world. The seeds of change were planted when we made Josh the [interim technical director of urbit.org](https://urbit.org/blog/first-steps-towards-urbit-org/). Urbit itself is getting close to the point where the separation between Urbit and Tlon has to become more real. Urbit is aimed at being an ubiquitous platform, Tlon is aimed at making it as usable and useful as possible.

We’ll talk about some of this on [October 9th](https://www.meetup.com/urbit-sf/events/273439025/), and you can see a bit of what’s coming on [tlon.io](https://tlon.io) today. If you tried booting Urbit in April and it was tough, try again. We’re easy to find on the network, and we’d love to get reacquainted.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Gifts Q3 2020]]></title>
            <link>https://urbit.org/blog/gifts-q3-2020</link>
            <guid>https://urbit.org/blog/gifts-q3-2020</guid>
            <pubDate>Tue, 22 Sep 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/gifts.png">

<br>

Twice a year we distribute address space to those that have made valuable contributions to Urbit. Now called our _Gifts_ program, the gifting of address space has been part of Urbit long before we had a grants program.

I'm happy to announce that urbit.org has a record number of gifts to distribute to community contributors for the period from February to August of 2020. Because the gifting of address space is an old tradition, and the last several months have seen an unprecedented amount of user growth, let’s talk about why we do this.

## Why gifts?

One way to think about Urbit is as _infrastructure for powering digital communities._ We’ve talked about this before in [some detail](https://urbit.org/blog/urbit-is-for-communities/), so while I won’t rehash the “why” of that here, I’ll reiterate that what we really want is a digital world that's generated by the communities that inhabit it.

We know that digital communities need better technology with which to generate their world; just as importantly though, they need _people_ to inhabit and develop them.

Tlon and urbit.org can’t bring the world into Urbit alone—we need community members to help us. By distributing address space to a variety of people that can invite their friends and families, the network can grow faster, more organically, and with a wider range of diversity.

Currently, the majority of available address space is owned by Tlon and urbit.org, but it won’t stay that way. Instead, we want to give address space to folks that want Urbit to succeed. Because we’re custodians of something valuable it’s important that we are intentional about how we handle it. We treat that responsibility seriously.

Gifts are one of the ways we invest in the future of the network. We look for others that see Urbit’s value and engage in building the digital home that they want to live in. They ease the learning curve for people new to Urbit, contribute to the technology, and create thriving communities.

## Recipients

Gifts are being awarded for a variety of reasons this quarter. As usual, there have been plenty of code and documentation contributions, but this time around we’re also recognizing those who have evangelized Urbit, been active in guiding newcomers to the system, and developed thriving communities within Landscape.

Gifts are being awarded using the following criteria:

**Bronze**: one star for continuous contributions over the last six months in at least one of the above areas.

**Silver**: two stars for creation of something exceptional and/or contributing across many categories.

**Gold**: three stars awarded to one contributor who has contributed at a volume that indicates a high degree of care and ownership.

Without further ado, here are the recipients:

### Gold

[`~radbur-sivmus`](https://github.com/tylershuster) has more or less become an unofficial member of the interface team by tackling an absolutely [immense](https://github.com/urbit/urbit/pulls?q=is%3Apr+author%3Atylershuster+) amount of Landscape-related work.

### Silver

- [`~littel-wolfur`](https://github.com/ryjm): Jake maintains the premier development group in Urbit, The Forge, and has led the way for other developers by authoring [srrs](https://github.com/ryjm/srrs), one of the more popular community-developed applications on Urbit.
- [`~botter-nidnul`](https://github.com/botter-nidnul): `~botter` has been instrumental in furthering [Urbit on ARM](https://botter-nidnul.github.io/), has made contributions across Vere and our documentation, and been highly active in onboarding newcomers on our Discord server.
- [`~timluc-miptev`](https://github.com/timlucmiptev): `~timluc` is highly engaged in many groups and the maintainer of some, wrote the [Nock for Everyday Coders](https://blog.timlucmiptev.space/part1.html) guide, and has gone far above and beyond in teaching the community about developing Landscape applications.
- [`~lanrus-rinfep`](https://github.com/dclelland): Daniel has done extensive development on iOS by writing Swift libraries for interacting with Urbit, and employed all of these towards the development of an [iOS client for chat](https://github.com/dclelland/UrsusChat).
- [`~minder-folden`](https://twitter.com/the_pritchard): Jonathan is a prolific member of the community. His group _The Sanctorium_ is always active, he's always around to help newcomers to the system, is an active evangelist on Twitter, and a creator of much excellent content.

### Bronze

- [`~watter-parter`](https://github.com/lukechampine): Luke has made a number of [contributions](https://github.com/urbit/urbit/pulls?q=is%3Apr+is%3Aclosed+author%3Alukechampine) to Arvo, and wrote a great [introductory guide](https://github.com/lukechampine/rote) to developing Gall agents.
- [`~naltyc-wornes`](https://github.com/JohnELester): `~naltyc` runs the popular group “Smol Computers” both inside and outside of Urbit where discussions ensue about various forms of computing on small devices like Android and ARM, and actively evangelizes the project.
- [`~nartes-fasrum`](https://twitter.com/nartesfasrum): `~nartes` evangelizes Urbit on Twitter by creating artwork, and maintains the popular food-centric group “Urbytes.”
- [`~fonnyx-nopmer`](https://twitter.com/fonnyx_nopmer): `~fonnyx` maintains an active presence throughout many groups on Urbit and runs the first Urbit-centric podcast, [Hooked on fonnyx](https://www.twitch.tv/fonnyx).
- `~libhut-samwes`: `~libhut` started and maintains one of the most popular groups on Urbit centered on crypto and investing, and contributes to conversations throughout Urbit.
- `~salmus-master`: In addition to embodying the quality of high-level, respectful debate we like to see, `~salmus` created the group: “The Tribal Network,” where he maintains one of the most active long-form notebooks on Urbit.
- [`~fostyr-solfyr`](https://github.com/cmarcelo): `~fostyr` has submitted a number of PRs against Arvo, including a much-requested feature to reset the web login code.
- [`~sarpen-laplux`](https://github.com/xiphiness): `~sarpen` has done a significant amount of research and work on Ethereum ABI parsing and other Ethereum-related topics in addition to being an active participant in dialogues throughout Urbit.
- `~mister-todteg`: `~mister` is a top evangelist of Urbit on Twitter, has brought many newcomers onto the network, and has even made several hires for his company from within the network.

Thank you to all who contributed to making Urbit what it is today!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Providers]]></title>
            <link>https://urbit.org/blog/providers</link>
            <guid>https://urbit.org/blog/providers</guid>
            <pubDate>Mon, 17 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://storage.googleapis.com/media.urbit.org/site/posts/essays/providers.png">

<br>

We look forward to a future where your Urbit is an always-on, always-available service. You should be able to pick up any device and conjure up your whole digital life immediately.

Sounds good—but how does this actually come to pass? Urbit has to be technically robust and have a nice interface. Assuming we can deliver both of those things, your Urbit node also has to be safe, secure, and running somewhere with a network connection.

Urbit has been getting nicer to use and more stable every day. We use it constantly, both as a company (Tlon) and for the broader Urbit community. From what we can tell, people are using Urbit to start communities of their own here and there. The problem is: to use our platform, you’ve got to run it yourself. This limits our audience _a lot_. Setting up a VPS and running an Urbit OS node is pretty easy if you’re comfortable in the command line, which makes it completely impossible for most people.

We hear from people regularly who want to be able to sign up for Urbit like it was any cloud service. What they want is what we’ve been calling a _provider_: a service to provide easy onboarding and hosting. Given a good provider, we’d be pretty close to our long-term vision: Urbit would feel like a ubiquitous, easily accessible service.

We’ve always assumed that providers would have to come into existence sooner or later. By the look of it, that time is now. Tlon and a few others have provider-like services in the works. We’ll talk about the specifics of what Tlon is planning to do in a future post. In this one, we’ll talk about what a provider is, why anyone would start one, and give a few examples of what they might look like.

## What is a provider?

A provider is anyone (company, DAO, a group of friends) that provides easy onboarding and hosting.

From a user perspective, signing up with a provider should be as simple as picking a planet and hosting plan, paying, and getting connected to a running Urbit OS node. This should be able to be done entirely in a browser or a standalone app and feel more or less like signing up for a conventional service.

From a technical perspective, this means a provider needs to create an Ethereum wallet for the user (client-side, of course), deliver an Urbit ID to it, and boot an Urbit OS node for them. And, at some point in the process, collect payment.

As a user, your provider is somewhere between your ISP and your WordPress host. Your provider both runs the star that sponsors your planet (and provides peer discovery) as well as potentially providing both access to communities and even provider-specific software. We don’t really expect providers to be terribly generic—quite the opposite. Providers are likely to differentiate themselves on price, available software, and available communities. We’ll get into some examples later.

The utility that a provider offers involves quite a lot of trust on behalf of the user. While the provider never actually holds the keys to your Urbit ID, they do run your node and, in turn, can access its contents. Unlike giant cloud services, your data isn’t in an easily searchable database. Inspecting your data should be something explicitly protected by a good provider ToS.

If a strongly worded ToS isn’t enough for you, you can always host yourself. And, given the way Urbit works, downloading your Urbit from a provider and running it elsewhere should be both really simple and something a provider will _always_ let you do. It’s perfectly fine to run Urbit in your closet—which means that providers are really competing on ease of use and price.

Let’s move on and talk a bit about why starting a provider makes sense to begin with.

## Why would anyone start a provider?

Our aim is to make Urbit OS so obviously nice to use that it’s well worth paying for. Today, a planet goes for about $10–$20 and, once you buy one, you’ve got to figure out how to really put it to use. Which takes some work.

Any large holder of address space should immediately see the opportunity here: the more useful Urbit is, the more value can be captured by starting a provider. Providers make it possible to actually capture the value in address space, both by selling it and by operating nodes.

Let’s say the base cost of running an Urbit OS node, in a hosted environment, is $10 / node / month. If you can sell hosting for $200 / year, you’re making back the ‘cost’ of the planet when someone signs up. Given that it’s more desirable to buy a planet when you know the star is online and you can put it to good use, this seems like a pretty good proposition: both for the provider and the customer.

Starting a provider doesn’t _have_ to be done by address-space holders. You could start a provider with no address space of your own by custodying the address space of others. Then, you could take a cut of the address space sales and all of the hosting revenue. With a market of people looking to use Urbit, the crux of success with this approach is simply whether you can compete on user experience.

Providers are, in a way, like the miners of Urbit. They’re incentivized to run fleets of very specific VMs for profit. The profit motive, in Urbit’s case, is just a bit more conventional than a bitcoin miner. An Urbit provider is just offering a service in exchange for money.

## What are some examples of providers?

If you think of a provider simply as a business, its most basic incentive is to attract as many customers as possible. You can do that by competing on price or performance, or by competing on aesthetics and community—there are lots of ways that providers can compete.

As a roughly similar ecosystem, the world of webhosting is a great comparison. There are lots of small webhosts that all have very specific services: Dreamhost, MediaTemple, prgmr.com, and Linode all come to mind. Then there are the more generic, large-scale, performance-oriented options: AWS, GCP, Azure. It’s not quite time for an AWS-scale Urbit provider, but perhaps the AWS of Urbit will start as something much smaller.

Let’s walk through a few examples to get a feel for what’s possible:

Communities -

A provider could easily curate community content like news, events, and discussion that it only delivers to its customers. Think of it as a bit like the days of sharing a server among friends—only in this case it could be hundreds or thousands of people who form a collective to run infrastructure and share information.

Custom software -

There are so many ways that providers can offer custom software. Urbit isn’t ready for third party software distribution. When it is, subscribers to a specific provider could get unique modules and applications synced directly to their Urbit nodes along with their membership.

Aside from Urbit-specific software, providers could provide custom software services to their subscribers. A straightforward example of this could come in the form of Bitcoin or Ethereum nodes for processing transactions. Sign up with a provider and get the ability to send transactions to the chain quickly and reliably.

Security -

Let’s say our base cost of $10 / month / planet from above is correct (it’s probably high, but it’s a simple number). Would someone pay $100 / month for a planet hosted in a bunker or in the pylon of an abandoned oil rig? Maybe.

## What about Tlon?

Before there can be an ecosystem of providers, there has to be _one_ provider. While we’ve heard of a few other people working on things, we expect Tlon to be the first to try to really get into the provider business in earnest.

I’ll save the details of what we’re going to do for a future post. Launching Tlon as a separate business will be the beginning of the separation of Tlon and Urbit. I’m really quite excited about it. Tlon is only able to consider becoming a business of its own because Urbit is mature enough that we can actually do it.

For now, I’ll just say that Tlon will pick the low-hanging fruit first. Our goal is to make onboarding a group into Urbit incredibly simple. We want people to be able to go from email invite to running Urbit in a few minutes without ever knowing anything about Ethereum, Unix, or what a private key is.

Once we’ve laid the groundwork with something that _just works_, we plan to open-source some of our components. Scaling up Urbit isn’t going to be easy. We hope that others will help us, and will help explore what’s possible in supporting Urbit users in the future.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[First Steps Towards urbit.org]]></title>
            <link>https://urbit.org/blog/first-steps-towards-urbit-org</link>
            <guid>https://urbit.org/blog/first-steps-towards-urbit-org</guid>
            <pubDate>Tue, 11 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img src="https://media.urbit.org/site/posts/essays/first-steps.png">

## Summary

It’s been a long time since we last discussed separating the [governance of urbit.org](https://urbit.org/blog/governance-of-urbit/) from Tlon. In the last few weeks, we’ve taken steps to make such a separation real. In this update we’ll discuss the background that led us here, why we’re doing this now, and what this means for Urbit.

## Background

At present Urbit is an open-source project developed primarily by the company Tlon. Urbit is an ambitious project with a long roadmap, which has required both careful guidance and resources to sustain its development. These resources have been Urbit’s address space, which have value in direct proportion to the value of Urbit as a platform. Naturally, Tlon has been focused thus far on making Urbit into a platform that people want to use.

Ultimately, Urbit presents more possibilities than any one organization can manage. We anticipated this, and set aside address space for urbit.org, which we’ve often thought of as some type of software foundation. As Urbit matures to the point where Tlon can shift from developing the platform to developing products _on_ the platform, urbit.org is meant to continue to improve and maintain the parts of Urbit that many will come to rely upon.

When we last discussed this, in early 2019, we weren’t quite ready to pull the trigger on setting up urbit.org. We weren’t sure if a software foundation would be the right structure, didn’t have the resources to tackle the overhead, and Urbit wasn’t yet stable enough for Tlon to focus on anything _but_ platform development.

## The Present

Urbit is really starting to look like a platform. Tlon has put tons of work into making Urbit stable and performant, we’ve launched OS1, and hosting services are on the horizon. Meanwhile, the grants program and Hoon School were initiated, and community members have been [contributing](https://github.com/natareo/hooncard/blob/master/hooncard.pdf) [learning](https://github.com/timlucmiptev/gall-guide/blob/master/guide-docs/overview.md) [materials](https://github.com/lukechampine/rote/blob/master/urbit/app/rote.hoon), [issuing](https://github.com/urbit/urbit/pull/2885) [patches](https://github.com/urbit/urbit/pull/3202) [to](https://github.com/urbit/urbit/pull/3238) [Urbit](https://github.com/urbit/urbit/pull/2867), and [building](https://github.com/ryjm/srrs) [new](https://github.com/dclelland/UrsusChat) [applications](https://github.com/yosoyubik/canvas) [in](https://github.com/yosoyubik/urbitcoin) [userspace](https://github.com/taalhavras/ucal).

With a stable platform taking shape and a strong community forming that wants to help build Urbit, it’s time to make urbit.org real. We’ve had plenty of time to think about what it should look like, how it should work, and who should lead it.

Our plan is to run urbit.org as a protocol—we’ll treat it like a real entity, but instead of dealing with the administrative details of setting up such an organization, we’ll incubate it within Tlon and give it a mandate: To competently distribute address space as a means of improving Urbit.

## Moving Forward

On that note, allow me to introduce myself: I’m Josh[^1], the new Interim Director of urbit.org. I’ve been a follower of this project for several years now and more recently a fairly active community member. I first became fascinated by Urbit as a programmer that saw the potential in a clean-slate OS; I later became compelled by a future in which social computing becomes small, friendly, and human-scale again.

My background is predominantly in building software, companies, and teams—most notably [Starcity](https://starcity.com), where I am a co-founder and CTO. Starcity[^2], like Tlon, is focused on enabling communities to flourish. While the approaches couldn’t be more different, the goal of bringing people together in fundamentally human ways is shared.

My goal is to leverage urbit.org to ensure Urbit’s success. I want to see a world in which Urbit is used by my friends, family, colleagues, everyone I know. To get there, much is left to build.

To that end, the first objective of urbit.org is to recruit builders and give them the tools to succeed. I’ll be focusing heavily on providing technical support to developers that engage with us via Grants, outreach to the wider developer community, supporting the efforts of those that are creating educational courses and documentation, and enlarging the contribution surface by exposing it to other programming languages[^3].

The product work that Tlon is doing is crucial to Urbit’s long-term success, so I’ll also be leveraging bounties to more directly accelerate their development efforts. Landscape represents the clearest example of a cohesive vision for Urbit’s use. The existence of a polished product built on Urbit demonstrates to the world that the platform is robust and capable, and the growing community seems eager to help. You can expect more bounties very soon that provide a direct connection to the Landscape roadmap.

As I’m only just getting started, I’d love to hear your thoughts. If you’re working on any grants you’ll hear from me soon, and if you have an idea that you want to pursue, I’m here to help you make it happen. You can reach me directly via Urbit as `~wolref-podlex` or by email at josh@urbit.org.

I look forward to working with you.

[^1]: But my friends call me ~wolref-podlex.
[^2]: We’re also really into the idea of being the first builder of housing on Mars. Just saying...
[^3]: We call this project Airlock. You’ll hear more about it soon.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A brief update from Tlon]]></title>
            <link>https://urbit.org/updates/2020-07-27-update</link>
            <guid>https://urbit.org/updates/2020-07-27-update</guid>
            <pubDate>Sun, 26 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2020.07.27-update.jpg)

Hello, friends. Today we’re highlighting an update on Landscape from `~haddef-sigwen`:

In the past few months Landscape has gotten a lot of upgrades for users and developers: it now functions as a single-page application instead of a bunch of separate applications, which lets us start to tackle previously trickier features, like notifications, while also being much, much faster to use and navigate. It also allowed us to reinvent the build process to be much simpler.

We’ve started deploying Landscape using a content-delivery network; each OTA, your ship will now receive a hash, and with it download and store Landscape. We want to prioritise, in the mid-term, the ability to move quickly to patch issues and provide a better experience using Urbit, while still leaving the door open for improving the system in the longer term. For now this should help improve performance and stability considerably, as previously the Landscape delivery over the air could easily lead to memory problems and sink ships.

Last week we wrapped up our current slate of work by shipping a new Groups experience: including publicly joinable groups, multiple admins and moderators, and a simplified back-end for developers. This update also included some user experience changes:

- All publicly joinable chats will instead be joined via publicly available groups
- All other chats are direct messages between ships, and invite-only

This means instead of using paths to join chats, or notebooks, you will use paths to join groups. This also lets us restore the feature to easily create linkable paths to your public groups inside any chat. The labyrinth returns.

We’re also working on delivering a new, keyboard-oriented, searchable navigation bar -- alongside new controls and settings for Landscape users. With both improvements we want to provide the ability to use Landscape primarily by keyboard if you so choose.

We’re also beginning to plan our next slate of work: we are preparing to make the leap to the OS2 codebase, and it involves quite a bit of research, but it’ll arrive sooner than you think…

<br>

Reminder: Hoon School begins August 1

[Hooniversity](https://hooniversity.org/) is the new home of Hoon School run by `~rabsef-bicrym` and `~risruc-habteb`. To enroll, visit hooniversity.org or email join@hooniversity.org

You can also join the Hooniverse group via public channel `~/~hiddev-dannut/hooniverse`and follow them on Twitter @hooniversity1

That’s all for now!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Ford Fusion]]></title>
            <link>https://urbit.org/blog/ford-fusion</link>
            <guid>https://urbit.org/blog/ford-fusion</guid>
            <pubDate>Tue, 14 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/ford-fusion.png">

<br>

## Overview and Rationale

Ford Fusion was an overhaul of Urbit's over-the-air upgrade process and a rewrite of its build system. The new update system corrects a few long-standing bugs with the previous one, and the new build system is simpler, smaller (by around 5,000 lines), and easier to manage.

Since deployment of Ford Fusion to the livenet in late June, over-the-air updates (OTAs) have been much smoother. Before Ford Fusion, it was common for an OTA to take several hours, use too much memory, and leave ships in inconsistent states. After Ford Fusion, multiple OTAs have been pushed out, including kernelspace changes, and most users didn't even notice.

Urbit has always been able to update itself OTA, but this process has often been rocky. Updating an operating system kernel on-the-fly is a difficult problem in general, like performing heart replacement surgery on yourself while running a marathon. Code that allows Linux to update its kernel in this way became a startup called Ksplice, won multiple awards, and sold to Oracle. Even that, as impressive as it is, and as brilliant as its [programmers](https://nelhage.com) are, can only perform certain limited kinds of patches to the kernel.

Urbit isn't exactly a traditional operating system, so the comparison is somewhat unfair, but the purpose of better architecture is to create unfair comparisons. In this case, because the Nock layer is frozen, upgrading everything above that layer is easier. Upgrades are also facilitated by pure-functional semantics, transactional event processing, a type system oriented toward concrete data, and orthogonal persistence. These features make it feasible for Urbit to upgrade
itself in the general case, not just some special cases.

Ford Fusion has fixed the major upgrade issues of the past by guaranteeing three properties that in retrospect are obvious requirements, but, like much of Urbit, took many years and rewrites to identify as such:

- Atomic: the update should complete or fail in one transaction. If it
  fails, the system shouldn't get stuck.
- Self-contained: there must be no implicit dependencies or hysteresis
  (dependence on previous system states) when building the new software
  from source.
- Ordered: updates must be monotonically sequenced from the system's
  lowest layer to highest.

Let’s walk through them one by one.

### Atomic

In previous versions of Urbit, updates failed atomicity by deferring parts of the update to later events, which are separate transactions that can fail independently. Generally, each deferral causes an exponential increase in the number of failure states that needed to be handled.

We've learned that asynchronicity is an entropic state. A system will tend toward more asynchronicity over time unless effort is put into keeping it synchronous. [As Jonathan Blow has noted](https://youtu.be/pW-SOdj4Kkk?t=2547), the language server protocol has turned every editor plugin into a distributed system, since now it has to communicate asynchronously with the main editor process.

Consider an update system that took multiple Arvo events to complete. An ad-hoc higher-level transaction system would need to be built to roll back the effects of the first few events in case of failure. It’s important for various parts of the system to be able to emit effects on upgrade; since those effects would need to be rolled back if a later event in this upgrade fails, the system would need to maintain a queue of those events and only apply them once all the other upgrade events have completed.

Note that the asynchronicity has now spread. Some effects that would normally be guaranteed to be processed synchronously might now be asynchronous. Entropy has begun to take hold, chipping away at the set of invariants the system is capable of guaranteeing.

This observation is not purely theoretical. False modularity was the cause of internal asynchronicity in Clay where it had to wait for responses in a complex dance with Ford, which was another vane (Arvo kernel module); moving Ford into Clay allowed function calls that were synchronous from Clay’s perspective, which allowed further simplifications, culminating in about a twenty percent reduction of source code size of the Arvo kernelspace.

[Steve Yegge's "platform
rant"](https://gist.github.com/chitchcock/1281611) describes a Bezosian
edict prohibiting synchronous communication among modules through direct
linking. This can be seen as an acknowledgment of the difficulty Amazon
was going to have when it needed to turn internal services external. If
your software needs to run in hell, build it that way from the start.

An Urbit ship is not an enterprise SaaS product and does not need to run in this hell; it exists for just one person, with natural pressure pushing it in the opposite direction from Amazon’s web services. Instead of needing a ship’s state and functionality sharded into microservices strewn across multiple clusters, an Urbit instance is easiest to manage as a single server with all its state unified into one data structure and its event log stored as one totally ordered sequence of state updates -- the antithesis of a distributed system.

### Self-Contained

Before Ford Fusion, each commit to the Clay filesystem validated its files using filetypes (called “marks”) defined by files in the previous commit. This could cause bugs if the filetype definitions had changed in a backward-incompatible manner. It also meant a commit could not add both a new filetype and new files of that type; instead, you needed two commits: one to define the filetypes, and a second to add files of that new type. More theoretically, it caused history-dependence. The validated contents of files in a commit could vary based on the history of commits that led to this one.

Another way source code failed to be self-contained was that it had access to symmetry-breaking information at build-time, namely ship, desk (Urbit's answer to a git branch), and (faked) date. A build recipe should be able to shared, cached, and rerun without dependence on local conditions, so user code now no longer learns its ship, desk, or date until runtime.

Source code also had build-time access to Urbit's immutable global namespace, called the “scry namespace”, which the kernel makes available as an implicit argument to userspace Hoon code. The scry namespace is immutable and referentially transparent, i.e. a request must always yield the same result for all time, but if an agent asks the kernel for a resource that’s from the future, hosted on another ship, or to which that agent doesn’t have permission, the kernel will deny the request.

If the kernel denies a scry request that user code made during the build process, the build system has no choice but to treat it as a nondeterministic error. Nondeterministic errors can never be fully eradicated, if for no other reason than that the user always has the option to defenestrate the machine—there's nothing deterministic about that. But we try to minimize them, and especially to minimize uncertainty as to under what conditions they might occur.

No build should be killed by the absence of files outside the desk, so as of this update, user code can no longer scry at build time. Once built, userspace programs can scry if run in a context with a scry handler; a Gall agent's runtime scry requests still work just fine.

### Ordered

The final kind of failure fixed by Ford Fusion was the lack of ordered layering during a software update. The most common form of this failure was that old Ford had a tendency to try to build userspace code using the previous version's standard library. This didn't work too well, unsurprisingly.

Emerging from this underworld required making a number of changes to the Arvo kernel, Clay, Gall, and the procedure for kernel updates. To avoid turning into a pillar of salt, I'll skip the details of how the old system worked and instead describe the new update procedure.

## How Updates Work Now

These are the layers of the stack that update themselves on the fly, from lowest to highest:

- hoon: the hoon language definition and compiler, defined in `/sys/hoon/hoon`
- arvo: the arvo kernel proper and related type definitions, in `/sys/arvo/hoon`
- zuse: the standard library, in `/sys/zuse/hoon`
- vanes: arvo kernel modules, including clay itself, in folder `/sys/vane`
- userspace: apps, marks, ancillary source code like libraries, and user data

An update to one layer necessitates a reload of all layers above it; e.g. a change to Zuse should trigger updates to the vanes and userspace. Conversely, an update to a higher layer should not cause a spurious reload of lower layers, which should not be affected by the change; for example, an update to just userspace should not cause any reloads of system code.

Clay is responsible for enforcing the layering of updates. An update to a module is triggered when an attempt is made to commit a change to Clay that affects one or more files needed to build the module. For example, if the 'foo' agent's source, defined in `/app/foo/hoon`, imports the 'bar' library from `/lib/bar/hoon`, then a modification to `/lib/bar/hoon` triggers an update to the 'foo' agent. All vanes and userspace files depend on Zuse, which depends on the Arvo and Hoon sources, so a change to the Hoon, Arvo, or Zuse sources will trigger updates to all vanes and userspace files.

When asked to perform a commit, Clay determines which layers need to be updated based on which files have changed and which modules depend on those files. For now, all running programs load their source from the `%home` desk, so only changes to `%home` trigger stateful updates. Files in other desks can be built, but not installed into the system. This might be relaxed in the future.

The process of updating varies by layer. The Hoon and Zuse layers are stateless, so their newly rebuilt cores (Nock executables) must be stored (somewhere in the system’s Nock tree, in memory; remember, Urbit is a single-level store), but they have no state that would need to be migrated. The Arvo kernel, vanes, and userspace agents are all live, stateful programs, so in order to update one of those, the system must extract the state from the old program, pass that data into the newly built program, then discard the old program and store the new one. Arvo and agent state injection routines can emit effects, but vane updates cannot.

To work around this limitation, Gall has a two-phase update process. First it enters a dormant “pupal” phase that stores not running agent cores, but only the agent states that the old Gall had extracted from its agents. When Clay notifies Gall that its agents have been rebuilt, Gall “molts” back into normal functionality by loading the agent cores from Clay and then running their `+on-load` routines to inject the old state.

If there's a change to files in `/sys` on the `%home` desk, Clay asks Arvo to update kernelspace. Clay sends a sequence of moves (effects) to Arvo to ask Arvo to perform any necessary updates to hoon, the kernel, Zuse, and vanes. This sequence is terminated by an extra move back to Clay itself, which will be received by the updated version of Clay after migrating its state. The rebuilt Clay can then use the newly rebuilt version of Zuse to rebuild userspace and notify clients of the update. One client is Gall, which molts when Clay notifies it.

Clay triggers updates, but the Arvo kernel is responsible for performing updates to all kernelspace layers, and Gall is responsible for updating userspace agents. Agents are stored in Gall's state, but all other layers are stored directly in the Arvo core's state, so the Arvo kernel contains the routines that reload Hoon, the kernel itself, Zuse, and the vanes.

The Arvo kernel reloads itself by receiving its new source code as a `%lyra` move from Clay, compiling this source into a core with empty state, then calling the new core's `+load` routine with the relevant parts of the old state. The state passed to the new Arvo now includes not just the vane cores and their states, but also the Arvo "duct" call `stack`, which maintains a stack of queues of moves to be passed from one vane to another, and a list of effects to emit to Unix at the end of the current Arvo event. If needed, Arvo could migrate the outstanding moves themselves -- if, say, the duct datatype changes.

Passing the Arvo call stack state to new Arvo allows a kernel update to happen in the middle of a more complex event without disturbing other sequences of processing steps happening concurrently in the vanes.

This entire update process happens in one Arvo event and doesn’t break event-dispatching semantics. This not only provides atomic rollback, but allows the update to be combined with other actions into a larger transaction -- for example, to stage complex changes, user code could trigger two kernel updates in a row, both in the same event.

Note that this is the opposite situation from the entropically leaking asynchronicity described earlier. Now the guarantees don’t deteriorate; they can be composed into stronger guarantees.

## How Clay Validates a Desk

A desk is Urbit's answer to a git branch. It's almost identical, except all files are typed and validated, and whenever a commit becomes the equivalent of git’s ‘HEAD’, it’s assigned a semantically meaningful revision number, and all files are typed and validated.

If Clay has been asked to perform a commit, it needs to validate all the files in this desk and notify all subscribers to live queries of this desk's data. Gall, for example, maintains live queries on builds of its live agents. Validation uses the Ford build system, which as of this update is no longer a standalone vane but a core within Clay.

A Clay commit, like a git commit, is specified as the current value of all its changed files (and, separately, references its parent commits by hash), not as the diff from a parent commit. Unlike git, Clay is typed, and every file must be validated according to its "mark". A mark is named like a file extension, e.g. `%txt`, `%png`, or `%noun`, and Clay maintains a mapping from that name to behaviors of values of that type under various operations. The last segment of any Clay path specifies the mark to use for operations on that file, including validation.

Mark operations include conversion to and from other marks (such as converting `%json` to `%txt`), revision control operations (diff, patch, and merge), and validating an untyped noun. Operations for mark `%foo-bar` are defined by a core built using the source code at `/mar/foo-bar/hoon`, or if that doesn't exist, at `/mar/foo/bar/hoon`.

Consider a file at `/web/foo/json`. In order to validate this file, Clay must load the mark definition core and use its validation routine to ensure the untyped value of `/web/foo/json` is in fact valid JSON. To obtain this core, Clay must build the file at `/mar/json/hoon` from source and then process the resulting raw mark core using some mild metaprogramming to get a standard interface core for dealing with marks, called a `$dais`, whose type is defined in Zuse.

Since building a source file only makes sense if the file has been validated as a `%hoon` file, but mark definitions themselves must be built from source, there's a logical dependency cycle -- who validates the validators? To break this cycle, Clay hard-codes the validation of `%hoon` files. This allows mark definitions to be built from source, and in fact any file can depend on any other file of any mark as long as there are no cycles. As of Ford Fusion, Ford performs a cycle check to ensure acyclicity.

Since building a file is a pure function, Clay memoizes the results of all builds, including builds of marks, mark conversions, and hoon source files. These memoization results are stored along with the desk and are used by later revisions of that desk. Future work should allow merge commits to pull memoized builds from all parents, but for now only the previous revision of the current desk is used. This is a major simplification of previous Ford architectures, which maintained much more complex caches with less clear eviction semantics. Now on every commit, we just throw away any unused memoized builds from the previous revision's Ford cache.

Once Clay has validated every file in this new revision of a desk, it constructs and sends updates to any subscriptions that other vanes or agents have requested. More Ford builds may be run to fulfill these requests, including builds for any running agents whose dependencies changed in this commit.

When Gall receives a newly rebuilt agent from Clay, it calls the gate produced by the `+on-load` arm of the new agent with the state extracted from the old agent. If there is a crash in any `+on-load` calls or in the handling of any effects they emit (which can include more agent activations), then the whole event crashes, canceling the commit. This effectively gives any agent the ability to abort a commit by crashing.

It is a bit counterintuitive that an app reload failure could prevent a kernel update. The reason is that we don't want the system to update itself into a broken state. An Urbit can be rendered practically unusable by the presence of broken agents, even if the kernel hasn't lost integrity,
so it's kinder to the user not to break their agents by installing an incompatible kernel update. This also puts virtuous pressure on kernel developers not to "break userspace", the importance of which has been insisted on for decades by Linus Torvalds, among others.

If an agent does crash a commit event that included a kernel update, the attempted commit is now trivially rolled back, and the system can deliver an error message to the user. This does not leave the system in an inconsistent or stuck state, so the user could modify the failing agent and try the kernel update again later. Supporting better workflows for keeping third-party agents up-to-date will be an important aspect of Urbit’s upcoming software distribution work.

## Ford Build Semantics

### The Three Types of Ford Builds: Files, Marks, and Casts

The Ford build semantics have been simplified. There are now three kinds of builds that Ford can perform: files, marks, and casts, all of which happen synchronously as function calls inside Clay and are available (without memoization) as scry interfaces.

#### File Builds

A file build takes in a filepath containing Ford runes and Hoon source, runs the Ford runes to perform imports, and then compiles the source, producing a `$vase`, a noun tagged with its Hoon type.

Clay exposes file builds into the scry namespace with `%ca`: as an example, `.^(vase %ca /~zod/home/3/lib/sole/hoon)` will build the `sole` library.

#### Mark Builds

A mark build produces a `$dais` mark-interface core. It first performs a file build on the Hoon file in `/mar` that defines the mark core, then it does some metaprogramming to make the operations more convenient to use. If the raw mark core delegated revision control operations to another mark core, the mark build will also load the delegate mark core and resolve the result into the `$dais`.

Clay exposes mark builds into the scry namespace with `%cb`: as an example, `.^(dais:clay %cb /~zod/home/3/mar/foo/hoon)` builds a `$dais` for the `%foo` mark.

#### Cast Builds

A cast build produces a `$tube`: a gate that takes a value of one mark as input and converts it to a valid value of another mark or crashes. To convert from mark `%foo` to mark `%bar`, Clay tries the following operations, in order:

- direct grow from `%foo`
- direct grab from `%bar`
- indirect jump from `%foo` through `%qux`
- indirect grab from `%bar` through `%qux`

The `%foo` mark can “grow to” `%bar` by providing an arm in its `+grow` core named `+bar`. `%bar` can convert from `%foo` using a `+foo` arm in its `+grab` core. `%foo` can also chain a conversion through an intermediary using an arm in its `+jump` core, and `%bar` can specify an “indirect grab” by having a `+grab` arm produce a delegate mark instead of directly defining a conversion gate.

Clay exposes cast builds into the scry namespace with `%cc`: as an example, `.^(tube:clay %cc /~zod/home/3/foo/bar)` builds a `$tube` conversion gate from `%foo` to `%bar`.

### Ford Runes

There are now only four Ford runes. A file can contain zero, one, or many of each, but each Ford expression can only be one line, and they must be in the standard order of `/-`s, `/+`s, `/=`s, and then `/*`s.

```
/-  foo, *bar, baz=qux
```

The `/-` rune imports a structures file from `/sur`. You can import it as just `foo`, in which case the build result of that file (usually a core with mold definitions) will be pinned into the compilation subject with the face `foo`. If you prefix it with a `*` as in `*bar`, the result will be pinned into the subject with no face; if the structures file compiled to a core, this exposes all the arms into the namespace of the compilation subject. Finally, if you import it as `baz=qux`, the `baz` face will be applied instead of `qux`. This is similar to "import as" in other languages.

```
/+  foo, *bar, baz=qux
```

The `/+` rune imports a library file from `/lib`. Aside from the different source folder, the syntax and semantics are the same as for `/-`.

```
/=  clay-raw  /sys/vane/clay
```

The `/=` rune imports the result of building a hoon file from a user-specified path (the second argument), wrapping it in a face specified by the first argument. The final `/hoon` at the end of the path must be omitted. This is mostly useful for importing a file for testing. The file at the specified path will be built as a normal userspace hoon file; i.e. its compilation subject will be Zuse augmented with the results of any Ford runes it has at the top of the file.

```
/*  hello-gen  %hoon  /gen/hello/hoon
```

The `/*` rune imports the contents of a file in the desk, specified as the third argument with the full path including the trailing mark, converted to the mark specified by the second argument, and pinned into the compilation subject wrapped in the face specified by the first argument. This can be used to import static data at build-time, such as a data file, a media file, or, in the case of this example, a hoon file as source text rather than already built.

A valid userspace hoon file must contain a nonempty list of hoons (hoon source expressions) below the Ford runes, separated by gap (more than one space, or at least one newline). The system wraps this list of hoons in a `=~` expression so that the result of the previous hoon is used as the subject of the next hoon. The result of the Ford runes is used as the compilation subject for this `=~` hoon; informally, the shape of the compilation subject can be thought of as:

```
:*  fastar-2  fastar-1
    fastis-2  fastis-1
    faslus-2  faslus-1
    fashep-2  fashep-1
    <zuse>
==
```

## Future Work

Urbit still needs to make better use of desks other than `%home` and the development process should be adjusted given the tighter coupling between source code and kernel and tighter criteria for accepting an update.

This work also hopefully provides a good foundation of a package management and software distribution system for Urbit. As `~wicdev-wisryt` has said, a user should be able to run `|install ~norsyr-torryn/canvas` to load and build remote source. No one should experience dependency hell on Urbit, but we're not there yet.

At least now, building a desk has no dependencies, other than a Ford with a compatible Hoon compiler. No decisions have been made on this yet, but
Ford might get moved to inside the desk, possibly by making Zuse callable. This could allow a desk to expose a Nock interface in addition to a typed Hoon interface, which could even let a desk be used as a "pill" bootloader.

## Conclusion

`~littel-ponnys` and I spent most of 2018 rewriting Ford with the intent of improving its performance. Compared to its predecessor, its result was better in some ways but worse in others. The caching system was labyrinthine and poorly factored, making the system difficult to debug or prove correct, even informally. Some things were faster, but the caching and dependency tracking were actually complex enough that a number of common operations, like mark conversion, were too slow.

In early 2020, `~master-morzod` suggested moving Ford into Clay to reduce asynchronicity. It seemed absurd at first, but at some point I realized I could combine that idea with a simpler build-caching scheme and self-contained desk builds, and `~wicdev-wisryt` realized he could use that to further simplify Clay’s commit and merge code, which he did as part of this project.

The first time I rewrote Ford, it took me six months, with help from `~littel-ponnys`, and it weighed in at 6,000 lines of code. The second time, in late 2018, took a few weeks. The third time, in January 2020, took a week. I wrote `+ford` in Ford Fusion in one long day, and it’s about 500 lines of synchronous, functional code.

It has taken me two or three years to understand this problem as well as I do, and I expect there are parts of it I still don’t understand. The code itself isn’t the issue; it’s finding the right answer to ontological and teleological questions. What _is_ Ford? What will it be in a hundred years? I’m confident Ford Fusion is more similar than its predecessor to the Ford of 2120, because it’s smaller, more functional, and easier to understand and administer.

As an engineering discipline and organizational practice, working on a system intended to be frozen yields surprising simplifications like this every so often. Urbit is now reaching the point where we’re starting to see more of the obsidian edges of the frozen future system emerge from the lava.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Value of Urbit Address Space (3 of 3)]]></title>
            <link>https://urbit.org/blog/value-of-address-space-pt3</link>
            <guid>https://urbit.org/blog/value-of-address-space-pt3</guid>
            <pubDate>Thu, 09 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt3.jpg)

_This is the third in a series of three posts on Urbit address space. See also [part 1](https://urbit.org/blog/value-of-address-space-pt1/) and [part 2](https://urbit.org/blog/value-of-address-space-pt2/)._

It has been some time since we revisited this series of posts, so let’s start with a summary.

Our framework for understanding the value of Urbit address space is that it’s useful, it’s rare, it’s easy to exchange, and the more that people use it, the more useful it becomes. Let’s briefly review each concept in a little more detail.

First, utility. Urbit address space was designed for logging into Urbit OS, but Urbit ID can be used as an identity primitive for any internet service. That means it’s vastly extensible. Perhaps more importantly, because Urbit IDs at the star and galaxy level represent network infrastructure for the Urbit network, users have already begun to build a range of business models upon them, from hosting providers to community hubs. We explored several of these possibilities in detail in the [first post](https://urbit.org/blog/value-of-address-space-pt1/) in the series, and we also provide a primer on Urbit ID itself.

Second, Urbit address space is finite, and that means it’s scarce. This design, which we explained in more detail in the [second post](https://urbit.org/blog/value-of-address-space-pt2/) in the series, was intended to promote good behavior and to limit spam. So far, that has worked. Scarcity is also impacted by availability of supply, which we’ll explore in this post.

Third, network effects, also described in the second post in this series, have the potential to build upon themselves quite rapidly within the Urbit ecosystem. Urbit is essentially a network of other networks, each owned and controlled by their individual users. For this reason, Urbit’s network effect is best described by Reed’s law, which argues that the value of a network increases with the number of groups that can be built on the network. In Urbit’s case, this number is essentially bounded only by the amount of data that can be stored in Urbit itself, which today is 2GB. That size is already enough to support vastly more groups than anyone has tried to launch, and we plan to grow beyond that limit in the coming year.

Also in Part 2, we explored trading of Urbit address space. We look at the current price of stars and planets as denominated in both BTC, and USD, and we see that the price of Urbit address space has remained fairly constant since its launch on-chain, while volume has been steadily increasing. The market is continually developing, with more ways to buy and sell Urbit address space cropping up.

So, to recap: our view is that the value of Urbit address space is a function of its utility, scarcity, network effects, and ease of trade.

In this post, we don’t expand that framework, but rather explore two elements that are important to actually using the framework. We’ll explain lockups, since they impact scarcity, and we’ll discuss usage metrics — including why we don’t (and in most cases can’t) track them.

## Lockups and spawning limits

One way to think about galaxies, stars, and planets is that they’re different-sized buckets of Urbit IDs. A star contains 2<sup>16</sup> (~65K) planets, a galaxy contains 2<sup>8</sup> (256) stars and, in turn, 2<sup>24</sup> planets (16,777,216). Beyond this nesting pattern, there are three further considerations to note: booted versus unbooted addresses, locked versus unlocked addresses, and planet spawning limits.

Booted and Unbooted Addresses –

A booted address is one that has actually been used to boot Urbit OS. By convention, booted addresses are expected to have some existing reputation outside of their name alone, since they’ve been used on the network. Reputation, good and bad, comes in many forms. Did the address operate any useful infrastructure? Did it get placed on any blacklists for spam or abuse? Did it simply send and receive messages? The ability to programatically track reputation is still in its infancy, but we expect the tooling to develop as Urbit grows.

Unbooted addresses, on the other hand, have no reputation. Both booted and unbooted addresses can be transferred between owners, but booted addresses will likely vary widely in price depending on the reputation each of them has acquired, and how they’ve been used.

For the purposes of this discussion, we’re primarily referring to unbooted addresses, as they have no reputation, and so are more similar to one another. We anticipate that booted addresses will trade infrequently — and likely via broker or auction, since users will prefer to control the reputation of the ID they’ve developed, rather than transfer that reputation to another.

Locked vs. Unlocked Addresses –

At present, the majority of Urbit address space is locked by smart contracts. When Urbit address space was first registered on the Ethereum blockchain, this unlocking mechanism was put in place to prevent the network from being flooded with users. A young Urbit network in which all of the address space had been unlocked would be exposed to attacks by bots and spammers. Scarcity, on the other hand, encourages good behavior as it increases the cost to spam.

A locked star is held in a contract and can neither be booted nor issue planets. The lockup contracts can be examined on [GitHub](https://github.com/urbit/azimuth).

In practice, the only Urbit IDs that are ‘locked’ are stars. A galaxy that is said to be locked is simply a galaxy whose stars are currently held by a lockup contract. A locked galaxy can be transferred (i.e. sold or simply moved to a new key) and booted (importantly, any galaxy—booted or not—can vote), but it can’t issue stars until the lockup contract expires.

![Star Unlocking Schedule](https://media.urbit.org/site/posts/essays/value-of-address-space-pt3-graph1.png)

![Total Urbit IDs Spawned and Activated](https://media.urbit.org/site/posts/essays/value-of-address-space-pt3-graph2.png)

These lockups all began to release at varying linear rates in January 2019 (specifically on Tue Jan 08 23:34:41 2019 UTC).

The various linear unlocking schedules are grouped as follows:

- The urbit.org addresses, and early prize winners unlock linearly from 2019-2021.
- Tlon, its founders, employees, and most purchasers from Tlon were frozen for a year, and now unlock linearly from 2020-2024.
- 2018 private buyers were frozen for a year, and then began to unlock linearly over the course of one or three years, depending on the terms of their respective contracts.
- Earlier private buyer addresses—including those in our first two crowdsales—were unlocked right away.

As of January 2020, 17,283 stars were unlocked and tradeable. By January 2021, 33,355 will be available. On January 9, 2024, all 65,536 stars will be unlocked and available for trading.

Being unlocked does not necessarily mean that a star can spawn all of its planets. For that calculation, we must turn to spawning limits.

Spawning Limits –

Unlocked stars are further gated by the number of planets they’re able to spawn. Every unlocked star was immediately able to spawn 1024 planets from the moment Urbit went live on the blockchain in January 2019—we wanted everyone to be able to invite some friends to their communities right away. From that date forward, the spawnable amount doubles every year (365 days), maxing out at 65,535 spawnable planets after 6 years.

![Total Spawnable Planets and Spawnable Planets per Star](https://media.urbit.org/site/posts/essays/value-of-address-space-pt3-graph3.png)

When we layer the spawning limits over the various lockup contracts, we find that all Urbit address space is both unlocked and spawnable by January 9, 2025.

## Address space distribution

Address space has continued to change hands since we put Urbit on-chain in January 2019. At that time, we had a fairly granular understanding of who owned what. Today we only have precise numbers for the Tlon and urbit.org owned address space. Galaxies change hands quite infrequently, so we know more about that ownership than stars and planets. We know next to nothing about the distribution of planets.

We consider the opacity of our understanding about transactions on the network to be a privacy feature rather than a bug. To be specific about the information we can collect here: first, we don’t know anything about users beyond their ETH address, and second, we can’t tell the difference between a transfer of an address, and the re-keying of an address. This means we’re never entirely sure if a transfer has in fact occurred; we only know that the address has changed.

The chart below is an estimate (as of January 2020) based on our general understanding of how galaxies are distributed. Much of this is anecdotal, and it’s largely based on the very few transactions we’ve observed within the galaxy table since Urbit went on chain in 2019. This chart should therefore be understood as incomplete, and an estimate only.

![Estimated Galaxy Distribution](https://media.urbit.org/site/posts/essays/value-of-address-space-pt3-graph4.png)

Address space distribution is best understood in terms of galaxies and stars independently, as they’re distinct assets. The chart above only illustrates galaxy distribution, but describes Tlon’s “naked” galaxy holdings, which are galaxies empty of their stars. These galaxies are empty because the stars they once contained have been distributed, primarily to Tlon contractors, employees, and to certain private buyers.

We believe that wide distribution is important to the health of the network and the growth of Urbit as a whole. Our own distribution efforts are focused on disbursing Urbit address space ownership as broadly as possible to those interested in using and developing the network.

We intend to further distribute Tlon’s address space over the coming years through private sales, employee compensation, grants, bounties, and gifts. It’s worth noting that the grants and bounties program specifically is set to increase in coming years. We’re very much interested in putting address space in the hands of people interested in helping develop the network; we see grants as the perfect mechanism for doing so.

## Usage data and composition

Usage data is an obvious missing piece of the puzzle in this discussion. We understand this, and yet we don’t actively capture usage data, for two important reasons: it’s premature, and Urbit is privacy-focused by design.

First, it’s too early. Urbit’s current users are a fanbase of pioneers who are willing to put up with the challenges of a young network. This fanbase grows on its own, but Tlon doesn’t actively encourage that growth yet. For the vast majority of potential users, the barriers to entry are still high enough that an invitation would risk losing them permanently. You can think of Urbit today as being a developer alpha.

We’re laying the groundwork so that we can, in earnest, invite our friends and communities to a network they will love. That means we’re designing smooth onboarding, an elegant user interface, and increasing the stability of both the system and network. Tlon’s forthcoming hosting services will vastly reduce barriers to entry, and will be our first major push into the public sphere.

Second, and perhaps more importantly, capturing data about traction on the network is difficult by design. Due to Urbit's privacy-forward architecture, there’s quite a lot we will never know. Once an Urbit ID is up and running, we don’t know how often it operates, where it’s hosted, or what it’s doing. This makes capturing usage metrics challenging, but we think this is the right problem to have.

The Network Explorer –

In the next several months we plan to roll out the first iteration of a network explorer that will allow users to visualize the structure and composition of the network as well as some basic activity data. Our first version of the network explorer will include representations of how the various layers of address space fit together, the finiteness of address space, historical uptime for nodes, and the various unlocking schedules.
The network explorer will also allow users to zoom in on various nodes to learn more about them and what they offer.
Urbit’s privacy-forward design makes collection of data appropriately impossible in many cases. That said, the network explorer should begin to collect all the elements of the value framework we’ve laid out here in one dynamic visualization.

Closing –

We have long said that Urbit address space had value because it was both useful and scarce. Taking a deeper look, we found that some limited liquidity, and network effect also play an important role in the value framework.

All of the factors that make up our framework are, in turn, impacted by availability of supply and by user growth. In the Urbit ecosystem, supply is effectively gated—as described above—in order to prevent flooding of the network.

User growth, on the other hand, is something we simply have not yet pursued in earnest. Instead, our development efforts have been focused on enhancing usability and stability of the platform. Our focus on user growth will begin as we roll out hosting. Once that happens, usage metrics will become both more interesting and more relevant.

This concludes the final installment of our series on the value of Urbit address space. Though the explanation was long, the framework is quite simple: value in Urbit is derived from its use, scarcity, some liquidity, and network effect. Let us know if you’d like us to dig deeper into any of these elements—we’re always happy to opine about Urbit.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2020.6.15 Update]]></title>
            <link>https://urbit.org/updates/2020-06-15-update</link>
            <guid>https://urbit.org/updates/2020-06-15-update</guid>
            <pubDate>Sun, 14 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2020.06.15-update.jpg)

Hello, friends. I hope you’re all staying safe and healthy. We at Tlon are still working from home, and we have a lot to report. Here’s a brief update:

1 -

The results of the first-ever Urbit Hackathon are in and we’re really excited about them. You can read more about the winning projects [on the blog](https://urbit.org/blog/hackathon-results/).

We decided to keep this first one just to Hoon School graduates, but we’re already planning another one that will be open to everyone later this year.

2 -

We’ve got two exciting lines of work coming together right now. The first is “Ford Fusion,” the next step in the evolution of our build system. This new design will alleviate a lot of the pain around OTAs (over the air updates), allowing us to upgrade ships more seamlessly. The second is a new version of our runtime daemon, this time implemented in Haskell. Moving to Haskell will create more surface area for contributions (versus our current, idiosyncratic C implementation). Shipping along with this latter will be improvements to our IPC protocol, the cause of many subtle runtime headaches.

3 -

The Urbit Community group has been fun and engaging lately. If you’ve booted your Urbit and haven’t joined, we encourage it. We’re there talking about the future of Urbit, core development, and all things Urbit adjacent and related. Ask for an invite in /urbit-help once you’ve gotten [set up](https://urbit.org/getting-started).

4 -

The Hoon School project is now in the capable hands of Urbit community members and they’re doing a fantastic job.

[Hooniversity](https://hooniversity.org/), the new home of Hoon School, is run by `~rabsef-bicrym` and `~risruc-habteb`. Session 5 is now underway and session 6 is set to begin on August 1.

If you’re interested in learning more and enrolling in the course, join the Hooniverse group via public channel `~/~hiddev-dannut/hooniverse`. You can also find them on Twitter as [hooniversity1](https://twitter.com/hooniversity1) or via email at join@hooniversity.org.

5 -

In case you missed it, we’ve been writing quite a bit in the past few months. Here’s the latest collection of posts:

- `~fabled-faster`’s [meditation](https://urbit.org/blog/infrastructural/) on OS1’s form development.
- `~haddef-sigwen` asked what it means to shape one’s own [digital environment](https://urbit.org/blog/tools-of-our-own/).
- `~simfur-ritwed` discussed [platform decay](https://urbit.org/blog/platform-decay/) and explored how Urbit stars can facilitate a [flexible continuum](https://urbit.org/blog/the-missing-middle/) of community norms.
- `~patnes-rigtyn` and `~ravmel-ropdyl` are writing a three-part series on the value of Urbit address space. Parts [1](https://urbit.org/blog/value-of-address-space-pt1/) and [2](https://urbit.org/blog/value-of-address-space-pt2/) are available now.

6 -

We’re always happy to give contributors address space to work on Urbit projects. Find a [Bounty](https://grants.urbit.org/bounties) to claim, or pitch a [Proposal](https://grants.urbit.org/proposals) of your own.

Until next time!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hackathon Results]]></title>
            <link>https://urbit.org/blog/hackathon-results</link>
            <guid>https://urbit.org/blog/hackathon-results</guid>
            <pubDate>Thu, 11 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/hackathon-results.png">

<br>

Results of the Urbit Hackathon

We recently held an invite-only Urbit Hackathon for graduates of our Hoon School program, and the submissions really impressed us across the board. Submissions were judged on several criteria: creativity, usefulness, and code quality.

Congratulations to all the participants, especially the winners—their projects are seriously impressive.

### First Place: Eight Stars

Jose’s `~norsyr-torryn` Canvas is a peer-to-peer, collaborative drawing app that comes in the form of a Landscape tile. It’s kind of like a multiplayer MS Paint, but better.

Canvas uses Urbit in a way that we think it’s supposed to be used: the stuff that doesn’t require peer-to-peer or storage heavy lifting, such as the actual “drawing” component of the app, is done outside of Urbit.

In addition to a freehand template for the classic Paint experience, you can choose from a number of templates to work with, such as a grid of fillable hexagons, or maps of parts of the world and of continents with fillable country divisions. Have you ever wanted to compare which countries you visited, color-coded for how much you liked them? Canvas has a built-in feature for sharing your work on chats in Landscape.

Check out a video [demonstration](https://www.youtube.com/watch?v=S6DySv730Hw) of Canvas, and view [the code](https://github.com/yosoyubik/canvas).

Jose wins eight stars, and he also wins [le internet for the day](https://news.ycombinator.com/item?id=23228058). Bravo!

### Second Place: Four Stars Each

Luke Champine’s (`~watter-parter`) flashcard app for Landscape, Rote, has been awarded one of two second-place prizes.

Rote users write decks in udon, review them, and share them with other ships. His immaculate backend code-style and documentation secured his high placement in the Hackathon—his Hoon code also functions as a full-blown walkthrough. If you’re a Gall novice and you’re looking to learn, take a look at his [code](https://github.com/lukechampine/rote). Luke also kept a Notebook documenting his experience at `~watter-parter/hackathon`.

Luke also included example decks for flashcards on Hoon runes and their irregular forms. So, all said and done, everything about Rote is an excellent resource to the eager Hoon neophyte.

Pyry Kovanen (`~dinleb-rambep`) was also awarded second prize for his reading-list-sharing app, Books. Also a Landscape tile, and it’s pretty darn useful, with the ability to import books from Goodreads. Check out [the code](https://github.com/pkova/urbit/tree/books/pkg/interface/books) and the [video demo](https://youtu.be/Spy7FoPdfx8).

### Third Place: Two Stars Each

N E Davis (`~lagrev-nocfep`) brought the heavy infrastructural artillery with Roessler, and won third prize. Roessler is actually three related Hoon tools:
`roessler` proper, a library for solving the differential equations producing the [Roessler attractor](https://en.wikipedia.org/wiki/R%C3%B6ssler_attractor).
`lazytrig`, a library for transcendental functions.
`proj-3d`, a generator that takes the 3D coordinates produced by `Roessler`.

The Roessler project is full of cool, novel features. You might enjoy taking a look at the [GitHub repo](https://github.com/sigilante/roessler) ...if your brain is big enough.

John Franklin (`~dirwex-dosrev`) also secured third place for his Notes application. True to its name, it’s a Landscape tile that allows the user to create and search notes by keyword. Look at the [code](https://github.com/jfranklin9000/notes/) and the [demo video](https://www.youtube.com/watch?v=7DurNjCFOmA).

Jon (`~ribnes-fonbex`) was awarded third prize for his Quadratic Voting project. It implements for Urbit ships a [quadratic voting system](https://en.wikipedia.org/wiki/Quadratic_voting), which is sort of like ranked-choice voting but allows people to express their stronger preferences.

Congratulations to the winners and to everyone who submitted—nice work!

### The Future

We were thoroughly impressed with all of the projects from this inaugural Hackathon. Not only did this Hackathon demonstrate the talent and dedication of our community members, it’s an encouraging sign about the maturity of the Urbit system. We’re going to hold more Hackathons in the future, with one big change: they will be open to anyone who applies.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Missing Middle]]></title>
            <link>https://urbit.org/blog/the-missing-middle</link>
            <guid>https://urbit.org/blog/the-missing-middle</guid>
            <pubDate>Mon, 25 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/missing-middle.png">

<br>

The promise of social technology is that we can discover more friends; _specifically, people more similar to us_ than we previously had access to. The means by which we do so, the methods of collaboration, the quality of connected experiences; these factors matter, but they are marginal considerations compared to the basic offering of an expanded choice of connections.

The wilder-eyed, utopian end of early computing drew greatly from this promise; such unprecedented connection could bring about world peace, intellectual serendipity, higher consciousness. We didn’t get world peace, but we did get a genuine revolution in collaborative information-sharing and rapid communication. That ability to refactor our social preferences gave birth to an uncountable universe of online communities and subcultures that would be unimaginable to anyone who didn’t see it happen.

We didn’t get a million friends either. Dunbar’s number, which posits an upper bound of ~150 trusted relationships per person, put the lie to dreams of a ‘global community.’ Better social tools give us more choice in who to fill those slots with, but not the ability to expand the personal spheres where we actually spend most of our time and forge most of our familiarity and trust with others.

We know this, and the social networks know it. To combat a slump in user activity, Facebook jettisoned promises of boundless discovery and started promoting Groups. The success of Discord and Slack happened precisely because they promised tools for gated communities, not open commons.

One of those early promises came true in spades, though: while we still live in Dunbar communities, we’ve sped up the sorting process. We can find people like us at astonishing speed, and the diversity of options for what ‘people like us’ means has expanded exponentially. The ‘Big Sort’ of modern society is rapid, unprecedented, and utterly reliant on social technology. The problem is that for all of our freedom to find each other and make mutual agreements, the underlying technologies used for all of this sorting and trusting don’t actually reflect the diversity of expectations, norms, or approaches we might want to try. One major reason for this status quo is the underlying structure of the client-server Internet. Unlike in the physical world, where cities, religious groups, and professional associations both own real assets and collectively determine rules and norms, there is no median level of civic compromise on the Internet; just massive technical providers and platform companies, and dispossessed Dunbar communities and individuals unable to determine such rules and norms for themselves.

Both internal norms (‘how do we act’) and external perceptions (‘who are we?’) get yanked around by the dictates of platform owners, routing infrastructure providers, and the societal consensus that governs both, at levels far above our Dunbar phyles. Privacy is contradicted by the need to surveil internal activity in order to target ads. The current model of social connection technology sets the bar for self-determination so high as to prevent it from adapting to external circumstances. The technical realities of the situation are due to client-server technology and its institutional history. The social aspect is a holdover from the 20th-century media paradigm of mass consensus cultures.

The ‘long 20th century’ of mass institutions and broad consensus realities is over. Contrary to impressions, it was not the inevitable or final result of moral and civil progress. Rather, it arose from pragmatic external incentives of mass advertising and great-power ideological rivalries.

The assumption that we must inevitably play by the same rules of discourse, given the autonomy granted by wealth, technology, and knowledge, is rapidly degrading. This status quo is a leftover from a time when mass education prepared workers for mass jobs, where mass communication hammered the same messages over the factory loudspeaker and advertised the same small number of products over the few television channels available. Yet we still assume that the shape and function of the tools and spaces for dialogue we inherited from that era are immutable and inevitable; this outdated belief cuts us off from new methods of choice and collaboration.

Without the external political and economic pressures which created our mass culture, inclusion in or acceptance by it becomes just another sinecure for sale, the outcome of a zero-sum auction to benefit from and utilize for further gain, the power accumulated by the legacy institutions safeguarding it. The ‘objective’ model has become a straightjacket on human ingenuity and community self-determination. The fact that it is ‘supposed to exist’ means that it is the ultimate prize. Inclusion in the mainstream Discourse grants scalable exploitation of any idea and prestige to its proponents. But it is a booby prize. No serious and nuanced idea, no dedicated community can withstand its flattening effects or the ways that it commercializes and cargo-cults its subject into an artificial shape. The resulting conversations are lackluster in form as well as subject.

The stiffer the Discourse is; the less input it deems useful, the more fragile it becomes. The inside becomes a stultifying garden party of outdated, anodyne official narratives; the outside a stew of paranoid, enraged rump factions shut out of any path to respectability or good-faith engagement with their perspective.

The same dynamic wreaks havoc inside Dunbar groups as well; when there are fewer gradations of acceptable difference, internal schisms take on a stark tinge of zero-sum loyalty versus betrayal, rather than consensual drift. Savvy users, knowing the stakes, migrate quickly, leaving behind wastelands of the obstinate and clueless, who are in turn preyed upon by grifters and demagogues. Only when external events force a ‘tectonic shift’ in official understanding do these standards change. The problem is that the usual result of a ‘tectonic shift’ is a sudden, destructive earthquake. If networked culture is going to survive dramatic events out in the real world, we’re going to need a middle structural layer that allows norms and agreements to shift and negotiate based on observed reality and the wishes of ordinary participants.

This omission of a ‘middle layer’ of technical governance directly informs our vision for the Urbit network. In an Urbit-based world, we envision stars will be consensus hubs. There are 256 Urbit galaxies, each able to spawn 255 stars for a total of 65,280 potential stars. Each star, in turn, can spawn 65,535 planets—far above the Dunbar number of an intimate community, but also far below the ratios of authoritarian control under which current platform regimes operate. Stars and galaxies perform the essential routing and peer discovery functions of the Urbit network; planets represent distinct individual identities.

Although every star is spawned by a particular galaxy, it can move to any other galaxy which agrees to host it. Similarly, planets may migrate between stars. Many imagine the extreme ramifications of such a system, projecting a Darwinian competition of starkly diverse political models encoded in governance. When we think about the future of Urbit, though, we don’t see a chaotic universe of iconoclastic outposts. We don’t doubt there will be diversity among stars (driven by the wishes of their owners and resident planet users/customers), but the real value is in the antifragility allowed by far more subtle gradations of difference in rules and structures decided upon by stars. Each star will have much, but not all, in common with its immediate neighbors, across a constellation which contains a great overall diversity of norms. Changes in policy or alignment will resemble ripples across a pond more than a buildup of tectonic force against a brittle fault.

Stars are Schelling points for such gradations precisely because they are discrete cogs in the overall technical infrastructure of Urbit. Technical responsibility and any bounds of ownership will always mark such points. Their designation in the case of Urbit or any other system is necessarily somewhat arbitrary. Our vision is orders of magnitude less centralized than the status quo, but not devolved so far towards the individual that community formation demands massive amounts of _individual_ technical knowledge and maintenance tasks. There will always be a need for routing infrastructure, ergo power (the power to set community norms and external relations) will always accrue to the points of control over that infrastructure.

Urbit simplifies much of this infrastructure but, just as importantly, it makes those technical locations, and the conditions of ownership and control, explicit. It allows for them to be owned and controlled by anyone who purchases them, rather than controlled by network-level overlords and unelected government regulators. Stars are somewhere between ISPs and consumer hosting platforms (like Geocities an eon ago, or Wordpress today); independent enough to set their own policies, but generally subject to the realities of running a profitable business. The decisions made by service providers inevitably have a great influence on the norms of any network, and Urbit is no different. The advantage of the Urbit model is that there are far more stars than ISPs, they are easier to run, they are fungible properties with clear ownership, and they are not burdened with technical and regulatory debt which ties them to the status quo. These qualities allow them to be purchased and maintained by a far wider range of people than might be able to control an ISP today; the massive decentralization of routing infrastructure also seems a likely antidote to the current state of regulatory overreach and centralized snooping which ISPs are subject to.

The Internet gave us an unprecedented flowering of diverse cultures; it gave communities the option to pursue a vast number of paths and goals. And we _should_ have the ability, granted by wealth, free time, and communications technology, to arrange the rules of our collaboration as we wish. The structural design of the Urbit network is an effort to provide that power, encoded in a digital asset with private keys that can be held both by individuals and (via multisig arrangements) by groups. The lower price and complexity of stars compared to current ISPs also makes a lot more room for innovation in business models; star owners can make their own judgments about how to prioritize commercial revenue versus cooperative ownership, anonymity versus identity, short-term versus long-term contracts.

We see stars as an opportunity to incubate community hubs, to plant a flag in the wilderness, declare values and alignments, and see who shows up. This process can be varied; some stars might advertise widely, others might quietly and slowly invite other communities on board. That’s the point. There’s a nice juxtaposition between first mover-effect and overall availability here; early adopters will have an opportunity to shape discourse, but the supply is not so constrained that they’ll capture all of it. Early adopters will likely have an immense and permanent value of voice, infrastructural ownership, and ongoing revenue over their shorter-term speculative one.

The diversity and non-discoverability of Urbit are already showing themselves: we hear whisperings of insular communities that we not only _don’t_ know about but by our express intentions _can’t_ know about unless they make themselves known.

Regardless of whether we or anyone else know about them, star owners already possess legible chunks of the ‘missing middle’’—large enough to affect the map of the Urbit universe, small enough to allow a wide array of voices—in a way that the ownership models of the current Internet can’t come anywhere close to providing. Not every neighborhood poker club needs an Urbit star. But the institution-founders, tastemakers, and social connectors of today and tomorrow, those who want to build opera houses on the digital prairie, should consider the advantages of building on a star.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Tools of Our Own]]></title>
            <link>https://urbit.org/blog/tools-of-our-own</link>
            <guid>https://urbit.org/blog/tools-of-our-own</guid>
            <pubDate>Tue, 12 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/tools-of-our-own-1.png">

<br>

> People need only not to obtain things, they need above all the freedom to make things among which they can live, or give shape to them according to their own tastes, and to put them to use in caring for and about others.
>
> <cite>Ivan Illich, <em>Tools for Conviviality</em></cite>

One of the recent ways we've come to describe the mission of the Urbit project is to give communities [the power to shape, or evolve, their digital environments](https://urbit.org/blog/urbit-is-for-communities/). Of course, like many of our definitions, it requires some background to really contextualize the claim. When I describe this particular statement to people, they often ask, "What does that _mean_, though? What is a digital environment, and why would I need Urbit to do it?"

After all, we think of our slate of tools as our entire toolbox. This makes sense for physical tools. And for a lot of people in the real world (at least, I think), their tools remain physical notebooks and paper. I, however, left those tools behind ages ago, and found myself in a world that used my habits, my memory, to loosely organize a wide array of online tools, that were themselves shaped according to the values of their creators.

The [Rube Goldberg machine](https://en.wikipedia.org/wiki/Rube_Goldberg_machine) made out of aligning these tools in increasingly virtuosic, but also increasingly restrained and mechanical ways, felt like constructing an exoskeleton out of prefab parts. The person in my social group closest to constructing the full range of human movement became a legend. But let's be honest: none of us came even close.

And it's nobody's distinct fault that the experience of aligning all these disparate services into a workflow is a skill in itself. It's a collective restriction that comes from the systems beneath.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/tools-of-our-own-2.png">

### Systems as masters

> If you don't understand a system you're using, you don't control it. If nobody understands the system, the system is in control.
>
> <cite>Philip Monk, <a href="https://urbit.org/blog/precepts/">Precepts</a></cite>

If you asked any of the creators of the social tools we use today what their mission was, it would seem neutral, a public good. To "bring the world closer," to "make a more open and connected world," to "easily see what's happening in the world." Ignore the fact that the net effects of their products are far more mixed than their mission suggests: for many users, the tools themselves come second to the power the tools have in capturing their social graph.

We just want to be where our friends are, to see who knows whom, to see a new friend vouched for by our common connections.

Why is the social graph even a consideration when choosing a tool? Why do I have to know who has accounts where, how they choose to assemble their digital body, so that I can see that it exists?

For a tool like a microblog—a bunch of entries in a database with metadata, usually threaded—the attachment of the social graph capture becomes not only an underlying appeal to us when choosing to use it, but also to the tool’s creators when trying to justify its existence.

In this example, you could say that every social Internet product is trying to make up for its missing ability to connect coherent identities underneath. The battle becomes a matter between the stagnant empire of who owns the graph versus the various attempts to create a secure identity primitive as a layer of the Internet.

But this is crazy: for decades, an aspect of the Internet stack that necessitated the creation of platforms—the ability to talk to other computers directly and to, privately, opt in, organize an array of devices as belonging to an identity—has driven not only the financial incentives of every product, but the use case for every person in the equation. A practically unrelated problem emerged that was too hard to wrangle and solve, and so it became the master.

And for productivity tools—for the personal activities we do every day—the same problem ultimately applies. Either you wrangle more and more single-use "products" into a framework, wrangling combinatorial explosion, or you punt the problem to the user's brain, remembering the relation between tools.

This is why hybrid products are born _and_ why massive enterprises are shifting toward subscription models for office software. With the [clearnet](<https://en.wikipedia.org/wiki/Clearnet_(networking)>), using our own computers for everyday tasks that extend outside themselves is not easy. It's way easier to sign into an enterprise's server farm for your persistent data storage and manipulation. In 2020, the prefab parts for the exoskeleton only come in "left arm, right leg" pairs, or you can just give up and plug straight into SkyNet.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/tools-of-our-own-3.png">

### The collective body

> “Autonomy” means that we make the **worlds that we are** grow.
>
> <cite>Tiqqun, <em>The Cybernetic Hypothesis</em>

So why does this matter for us? Me and you and everyone we know? We put up with the cost all the time. But the limitations of our tools—on the vulnerable side of a power dynamic that, unbeknownst to everyone involved, functions as a catalyzed and increasingly accelerated system bringing out the worst in all of us—range from the everyday annoyances to a pervasive alienation, an information malaise.

You have to ask yourself, "Why are we doing this again?"

These days I find myself away from broadcast tools and more in the insular channels of my friend groups. What I want from technology is to share life with my friends; to be given the opportunity, and the power, to share that life, and all it includes… showing them care, or sharing the bits of knowledge that seem important to us as a group.

To reinforce the fulfilment of collective potential in whatever direction our groups take off in. Some of my friends watch stuff together; some of my friends remark on goings-on; some of my friends research together; all communicate entirely differently. Not all of them belong on "IRC, but for gamers," or "IRC, but for highly productive and extremely important teams." And yet, that's where we are.

Forget the prefab parts: a proper exoskeleton for our collective body evaporates; and we face the sunlight in whatever direction we choose. The ability to extend our shared spaces collectively, with each of our groups of friends and collaborators, using our own computers: that's Urbit.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Platform Decay, Decentralized Marketplaces, and Urbit]]></title>
            <link>https://urbit.org/blog/platform-decay</link>
            <guid>https://urbit.org/blog/platform-decay</guid>
            <pubDate>Thu, 07 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/platform-decay.png">

## Platform decay, decentralized marketplaces, and Urbit

The current model followed by almost all social media services is one of easy and free participation in exchange for advertising and data collection. If you’re a fan of decentralized projects like Urbit, or just someone who pays attention to the ongoing debate over social media incentives, you’re likely to be familiar by now with a central critique of this model. There are historical reasons for why we ended up here: ad-serving and user-tracking technology outpaced subscription and micro-payment models because of recalcitrance by banks and regulatory hassles that prevented ‘real money’ from easily integrating into websites. Instead, we pay in eyeballs and analytical data.

When we take a moment to think about possible alternatives, we usually fixate on that original bad bargain—’free’ in exchange for ads—before lamenting that first-mover advantage, critical masses of users, and sophisticated algorithms have made it very hard to see successful challenges to the reign of sites like Facebook and Twitter. We’d be happy to pay a few pennies to have an ad-free, data-secure alternative. But this critique misses something larger. There are, in fact, plenty of colossal Internet businesses that actually do charge people money to participate: e-commerce platforms. Some of these enable the sale of virtual goods and content (Steam, Patreon, Spotify), some physical goods (eBay, Etsy), and some both (Amazon, Kickstarter). Because these commercial platforms had to figure out how to make online payments easy and secure for mass audiences for their core business to work, they avoided the total dependency on ad revenue that social media sites have always had. Unfortunately, several factors have conspired to push e-commerce platforms closer and closer to a social media–style business model—by manipulating user behavior and prioritizing ad revenue and branding deals over providing a fair marketplace for ordinary buyers and sellers.

E-commerce platforms, as generally perceived by the public, operate on a simple ‘deal’: users (small or large, individual or corporate) can buy and sell goods and services on the platform, facilitated by search engines and payment processors, and augmented by reputation systems and safeguards for buyers and sellers. In exchange, the platform takes a small cut of the revenue that passes through. E-commerce platforms were a key part of the genuinely revolutionary effects of ‘Web 2.0’. As software ate the world, it uncovered siloed value that had been previously inaccessible. This was particularly true for items with a high potential value, but a small market-base. Just as social connection technologies—from Usenet to Facebook—enabled people with niche interests to find each other, mass-platform e-commerce sites allowed buyers and sellers of niche goods—physical or virtual—to find each other and transact, thus granting those goods actual value, and their owners revenue.

The ‘deal’ that eBay, Amazon, and the others made with millions of buyers and sellers was a great business proposition for over twenty years. They could take advantage of centuries worth of asymmetrically siloed value, now searchable worldwide, and take a ~10% cut. Their moat was in sophisticated search algorithms, network effects, and, as time went on, finding ways to make online payments as easy and secure as possible—the road not taken by early social media companies like Myspace that decided in favor of reliance on ad revenues. Crowdfunding sites like GoFundMe and Kickstarter reduced friction in online fundraising in exchange for a cut. Patreon applied a similar approach to regular support of individual content creators; Spotify, Soundcloud, and Pandora made it easier to legally stream music. All took advantage of the same ability to extract value from widely distributed niche products. All offered their vendor-users a version of the same deal: facilitation of niche broadcasting in exchange for a visibility and transaction fee.

The problem is that the deal is now decaying rapidly, without any prospect of recovery. The behavior of every mature e-commerce vendor platform clearly shows an accelerating trend towards exploiting user data, serving ads, pushing exploitative auxiliary services like high-interest loans, and taking advantage of vendor lock-in and near monopolies on customer attention to warp marketplaces for the benefit of large brands. In other words, they’re all double-dipping.

Clicking through normal transactions on PayPal, for example, invariably produces ads for subprime credit cards; similarly, Patreon users can now borrow against their (expected) future earnings. Spotify has reinvented pay-to-play for artists and labels; eBay has leaned hard on promoted listings, with extra fees, in order for vendor offerings to show up in search results. Amazon has increasingly ‘gated’ third-party offerings in categories and brands in which not only their own ‘store brand’ products, but those of large brands with which they have struck external deals, compete. A growing number of consumer products have essentially been prevented from being resold on Amazon or eBay by the threat of spurious, but expensive, anti-counterfeiting lawsuits by major brands, thus buoying new sales by effectively eliminating resale value.

There are several key reasons for this. One is simply that as the initial burst of siloed value being accessed, revalued, and bought and sold subsides, the number of transactions plateaus and e-commerce platform revenue with it. The traditional model of venture capital funding for platform businesses, however, demands an exponential growth in profits; the exploitation of customers and vendors becomes irresistible in order to maintain these profit trajectories. Another reason is that as e-commerce platforms accrued large userbases of both buyers and sellers, they began to act like other online platform businesses—distorting marketplaces and shaping user behavior to maximize retention and profit, rather than offering a straightforward service.

Platforms exploit user data because they can. Their ownership of your data is baked into the client–server architecture on which their businesses run, and the system cannot correct itself. Chris Dixon, in his prescient [essay](https://onezero.medium.com/why-decentralization-matters-5e3f79f7638e) about the future of decentralized commercial protocols, presents an S-curve whereby a platform business transitions between serving its users in order to grow and achieve market dominance, and eventually exploiting those users once it has achieved that dominance. In particular, early-stage e-commerce platforms do anything they can to benefit vendors willing to sell on their platform. Vendor presence is vital to attracting customers, but once those customers have been captured, the vendors become the [competition](https://www.wsj.com/articles/amazon-scooped-up-data-from-its-own-sellers-to-launch-competing-products-11587650015?mod=searchresults&page=1&pos=1). Customer eyeballs and dollars are a finite resource, and platforms carefully calculate the potential profit to be made from showing customers one product or another. The lack of platform-agnostic reputation systems also aids vendor capture by platforms. Rather than optimize for a system in which any buyer or seller with good external credibility (measured by, for example, credit scores or relevant business licenses) can use their platforms as a commercial intermediary, eBay and Amazon use seniority and internal transaction records to determine vendor permissions. Since sui generis internal reputation scores can’t be taken to other platforms, these policies create a sunk cost of effort and reputation which traps vendors within specific marketplaces, without an easy exit.

Market consolidation and bureaucratic pressures for legibility also work against maintaining a square deal with vendors and users. The midpoint on Dixon’s S-curve, when exploitation of vendors begins to occur, can also be seen as the point where a customer base is solid enough to be marketed to advertisers and major brands who can pay for favorable search placement. Such large, legible deals are easier to negotiate, easier for individual executives to take credit for, and are useful in meeting arbitrary investor benchmarks and buoying quarterly revenue statistics; but they privilege larger brands with larger ad budgets over ordinary sellers in a niche. Another major downside of large, centralized e-commerce platforms is that, like any large bureaucracy, they have PR and regulatory concerns that provide an attack surface for regulators, activists, litigious brands, and monopolists seeking to crush competition—almost invariably at the expense of vendors and customers.

Even more subtle and worrying effects come when e-commerce platforms realize that the actual products being shown do not have equal chances of being purchased, therefore delivering revenue to the platform itself. This applies even when the products being compared have nothing in common: apples to oranges; cat food to hiking boots. Accuracy of internal search engine results, and a comprehensive spread of offerings, are regularly sacrificed to the aim of placing a ‘sticky,’ lowest-common-denominator product in front of the customer. I recently ordered vegetable seeds on Amazon; after a few searches for different kinds of seeds, I started having to wade through ‘premium placement’ ads for farmer-themed romance novels before I could view, and choose from, the actual seeds on offer. This deprecation of niche products is ongoing and makes the interface of such platforms less and less navigable. It’s also worth mentioning that, frequently, such deprecation has very little to do with durable consumer interest or a free-market determination of product value. Rather, they come from a ‘thumb on the scale’ of large advertising campaigns that seek to convert a wide range of consumer curiosity into sales for a particular product at a particular time.

The manufacturing of consumer desire in this way feels creepy. It’s frustrating to have your tastes dictated to you by whoever has the biggest ad spend. It also spells the end of small business on the Internet—you can spend years mastering knowledge of a profitable niche, but if Amazon profiles your customers and decides they’re more likely to spend their money on the latest Pixar DVD, your listings will be shoved below the fold. Pixar paid for placement and you didn’t; the Pixar ad placement deal made a splash in the quarterly report, your fees didn’t. In cultural terms, this threatens to create a winner-take-all situation that will prevent new and niche artists and thinkers from gaining attention at the expense of explicitly placed, ‘premium’ content.

Again, this is all accelerated by the way that ad sales function; platforms like broadly popular content and products because the larger number of customers searching for and purchasing them creates more granular data and increased opportunities for micro-targeting ads. This incentive leads to the increasing invisibility of long-tail, niche content or products whose appeal has less to do with lowest-common-denominator addictive virality, whether it’s the repair manual for your ‘85 Toyota or a copy of Plato’s _Republic_. It also accelerates the stampede toward a ‘sharing’ and ‘renting’ economy; when ad impressions are a sizable part of company revenue, forcing customers to return to ad-infested platforms to continue renting objects or content, rather than making one-time purchases, is a no-brainer.

There’s a nightmare scenario here, a kind of hybrid, zombie brainchild of Jean Baudrillard’s concerns about the simulation of common meaning and Peter Thiel’s arguments about the stealthy hollowing-out of industrial capacity. In this nightmare future, financial and legal regulation strangle the viability of anything like a real industry, and we’re left with a handful of incumbent platforms which have concluded that the smartest move is to just sell vaporware ‘content,’ collectible bobbleheads, and sugar water. The supposed niche of any platform business is academic at this level; Amazon, Spotify, and Patreon are simply machines for converting user attention into the highest-margin purchases possible. The ‘high-velocity trash economy’ (h/t Pierre Rochard) increasingly shows itself as a network of funnels by which insider prognostications about government and central bank policy are turned into profits, with the illusion of productive activity serving only as window dressing. This deforming process extends all the way down to the vagaries of the consumer economy. If there is no financial reason for available consumer offerings to be anything we actually need, they can and will be deprecated and displaced; useful goods and services will be sidelined by literal trash that has the ‘financial’ logic of maintaining an unbroken, upward metric by virtue of direct parasitism upon the human brainstem.

The implications are obvious: if we can’t make markets obey a representation of factual reality, we won’t be able to build stuff we need in the factual world. The damage which has been done by our replacement of infrastructural capacity with nebulous thematic concerns that happen to feed our dopamine receptors is becoming rapidly apparent to anyone paying attention. If our search results for ‘hammer’ algorithmically default to pro wrestling merchandise, that changes our real, physical lives. Our ability to go out and build things with a hammer is diminished, and so is, implicitly, the importance placed on that act of building by the culture that surrounds us. The physical world of technology, no less than the informational, is a slippery pile of patches and detours. When JPL scientists reestablished contact with an early satellite after decades of inactivity, they relied on vintage computer parts from eBay to communicate with it. In some areas (cars, hand tools, some analog electronics) the present consumer offerings have generally declined, in terms of reliability and user serviceability, from a zenith some twenty or forty years ago. Forty-year-old Toyota trucks often fetch more, in equivalent value, than they did when new, because regulations and planned obsolescence have prevented the ongoing production of trucks that meet the same standards of reliability and fuel economy. The failings of our just-in-time supply chain have likewise been made blatantly obvious by the disruptions of COVID-19. Both argue in the strongest terms against allowing consumer-facing e-commerce to be captured by what are rapidly becoming payola-driven entertainment platforms rather than marketplaces for essential goods, whether car parts, beef jerky, or N95 masks.

So what’s the solution? Many prescient observers envision decentralized protocols to safeguard the data of vendors and buyers, and algorithmic representation of their offerings. Any new ‘deal’ between vendors, buyers, and platforms must be rooted in data ownership and neutral code if it is to avoid a repeat of the current paradigm. Personal ownership of browsing, buying, and selling data is necessary so that search results and boosted listings aren’t distorted for each customer in order to ‘nudge’ them into consumptive patterns, and so that value is retained in useful, niche items which don’t lend themselves to dopamine addiction and manipulative marketing campaigns. The hope is that widespread personal control of data would lead to the emergence of protocols and marketplaces which have realistic economic models based on fees; the ‘square deal’ originally promised by ‘Web 2.0’ platforms. Such marketplace businesses wouldn’t be exponential unicorns; they’d be steady, stable infrastructure companies like those that built the foundational technologies of the 20th century and made a secure, middle-class lifestyle possible for millions of people. Data ownership wouldn’t prevent platforms from incorporating advertising, but it would shift the balance of power to an opt-in basis. By reducing the ability to target such ads, it would prevent the lopsided reliance on ad revenue which leads to smaller vendors being neglected. Big companies wouldn’t go away; they’d make their margins by focusing on economies of scale in the real world: logistics, fulfillment, and redundant inventory for commodity goods.

We need decentralized, robust reputation systems to combat monopolistic platform lock-in and its attendant abuses, but also so that smaller, more private marketplaces can create their own rules, and still be functional and secure. Right now, reputation data is siloed by the same companies that built large marketplace platforms, which means that anyone who moves outside of their walls loses access to it, and thus loses protection from bad actors. The ability of users to run their own reputation scans, or to pay for a separate layer of reputation data which is marketplace-agnostic, is essential to breaking the hold that large marketplaces currently have on e-commerce. If a local community wanted to trade in homegrown food, for example, they could restrict access, while also making sure that their members didn’t have a previous, external track record of fraud in other markets.

Where does Urbit fit into this? We think that the basic infrastructure and alignment of the Urbit system has two major advantages to offer those who will build these new protocols. The first is the simplicity of running one’s personal server of data and locally hosted processes. Any attempt to reimagine privacy-focused e-commerce under current client–server models quickly runs into complexity problems—Web 2.0 platforms require reams of legacy code and armies of SREs to keep them running. The second is the ability to maintain a semi-private but reliable digital identity among different platforms and communities, including commercial ones. Most current conceptions of autonomous marketplaces rightly focus on the potential of cryptocurrency as a decentralized payment system. But wallet and exchange problems, the work-in-progress state of micropayment infrastructure, and price fluctuations among different currencies (crypto or fiat) clearly show the need for a decentralized reputation system which is not simply a crypto wallet address, but is likewise more secure than a PHP forum profile. We think that Urbit ID can provide such a holistic, yet pseudonymous, reputation system without being tied to a particular currency, wallet, or commerce platform.

Right now, Urbit is a communication system for communities and individuals. We aim to create spaces where human conversations can take place with a minimum of distractions. We believe that commerce, too, is best achieved in such a space; think of your local hardware store rather than a carnival with barkers at every turn. We also see this as a priority deeply in keeping with the underlying ethos of Urbit. We frequently speak of Urbit as a tool, and reference classic principles of tool design when considering how to expand it. The test of any tool is in its ability to shape the world; if that function isn’t well matched to both the actual world, and the hands and desires of those who will wield it, usability will suffer. Open marketplaces should function as magnifying glasses, to hand buyers and sellers a tool to see the shape of supply and demand, rather than distorting the actual terrain of the marketplace in order to create its own desires. Soon we’ll have BTC integration tied to Urbit ID, and independent security audits of the Urbit system. We want Urbit to become the foundation on which users can build simple, decentralized protocols that enable us to safely and easily buy and sell goods and content that we actually want and need. Urbit is calm computing. Calm commerce follows naturally.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Introducing OS 1]]></title>
            <link>https://urbit.org/blog/introducing-os1</link>
            <guid>https://urbit.org/blog/introducing-os1</guid>
            <pubDate>Wed, 29 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<video class="ba w-100" autoplay loop src="https://media.urbit.org/site/posts/essays/intro-os1.mov"></video>

## Introducing OS 1

OS 1 is a simple, unified system for building digital communities. OS 1 is for groups of people sharing messages, links, and notes on Urbit.

We designed and built OS 1 for ourselves, and we’re really enjoying using it every day. Instead of figuring out how to duct tape together apps and services, we use a single system to stay connected with the company and broader Urbit community that we really trust. OS 1 makes it feel like our company and community has a place in the digital world to call home.

Most groups of friends and collaborators juggle apps and services to stay connected in the digital world today. We think OS 1 is a much better model. It’s still too early to ask the whole world to switch over to it — but we’re ready to help onboard our friends and adjacent communities into Urbit to have them try it out and get their feedback.

First, let’s walk through what OS 1 is and how we’ve been using it. Then, if OS 1 is interesting to you, we’ll tell you how to apply for a community grant.

Here we go:

## What is OS 1?

OS 1 is a very simple, integrated tool for messaging, sharing links, and writing with a group of people. OS 1 is somewhere between ‘productivity software’ and a ‘social network’. We think it’s the beginning of an altogether new breed of social computing.

OS 1 isn’t our first attempt to build an interface for Urbit, but it’s certainly the most complete. OS 1 is the first Urbit interface that doesn’t feel like an experiment.

Today, when you boot Arvo (the Urbit OS kernel) and connect your browser to it, you’ll see OS 1. OS 1 isn’t the only possible client for Arvo, though. Anyone could build their own client or, since it’s completely open source, modify OS 1 however they like.

For most people, out of the box, OS 1 feels like an app. Given that it’s running on Urbit OS — it’s much more than that. It’s a full-fledged general purpose virtual computer that’s secure and private to you. We’ll come back to what that means at the end.

Let’s walk through the features of OS 1 one by one to see what it’s like.

### Groups

<img class="ba" src="https://media.urbit.org/site/posts/essays/intro-os1-groups.png">

The group is the main building block in OS 1. A group is simply a list of people that share a set of chat, links, and publish channels. A group is sort of like a super powerful group chat.

A group of friends might just share a few chat channels. A reading group might just share a publish channel for discussion of what they’re reading and a links channel for upcoming books. As a company, we share a variety of chat, publish, and links channels to get things done and communicate. There are chats for each area of work, publish channels for digests and feature discussion, and links channels for music, influences and references, for example.

Each person in a group is identified by their [Urbit ID](https://urbit.org/understanding-urbit/urbit-id/): a short, memorable name that you own with a private key (and belongs to you completely). Each group is private and requires an invite. Groups aren’t discoverable. They’re meant to be high-trust communities of people. More like a commune than a public event.

Let’s walk through each module and talk about what they can do.

### Chat

<img class="ba" src="https://media.urbit.org/site/posts/essays/intro-os1-chat.png">

Chat is chat: a sequential list of messages meant for synchronous communication. There are already a million ways to chat — but Urbit chat differs in a few important ways.

First, each chat channel is only shared between the host and the members of a chat. When you DM with people, messages are sent peer to peer. The system is, in fact, decentralized and pseudonymous by default. No one knows anything about you outside of your Urbit ID.

Second, each chat message is encrypted and signed by your Urbit ID. Again, we don’t call Urbit ‘secure’ yet since it’s unaudited — but we’re working to have Urbit audited this year.

Third, chat in Urbit OS is a protocol for sending messages between computers on the network (known as “[ships](https://urbit.org/docs/glossary/ship/)” and identified by their Urbit IDs). It’s easy to imagine extending chat in all kinds of fun and interesting directions: chats that only accept certain message types, chats that have disappearing history, chats that you can only post to during certain times of day, and so on.

(If you’re curious to try one of these things, or have an idea about something you’d like to experiment with — consider submitting a proposal in our [grants program](https://grants.urbit.org/). We regularly reward contributor work with address space.)

We think of chat as a primitive, not simply a ‘better IRC’. But even in the rudimentary form it’s in today, chat is essential to delivering a feeling of being at home. There’s no way to deliver a complete interface for groups without chat.

Anyway, not everything can happen in a chat. Let’s keep moving.

### Links

<img class="ba" src="https://media.urbit.org/site/posts/essays/intro-os1-links.png">

Links is a bit like Hacker News or Reddit. It’s just a collection of links with comments. There’s no upvoting or sorting. We decided that with a small group it’s more about collecting references than deciding what’s most exciting — but permutations of Links could be a great area for contributors to experiment with.

We use links to collect external references and track things we’re thinking about. We’re always looking at things going on outside our small digital universe and talking about them. Links lets us keep an archive of those discussions.

We originally imagined links as evolving into more of a general-purpose ‘collection creation’ interface. One where you can pull together images, video, URLs, maybe even runnable code and so on into a single channel. We’ll get there.

### Publishing

<img class="ba" src="https://media.urbit.org/site/posts/essays/intro-os1-publish1.png">

Publishing is somewhere between a blog and a note-taking system. A Publish notebook is a list of markdown files with optional comments. A private Publish notebook is like a journal, a group notebook can be like a forum (with comments on) or a collaborative blog.

We use publish for both long-form discussion and one-way communication about what we’re working on in its current form. The editor is calm and simple. In distraction-free mode, it’s a nice place to put a note together.

Publish, like all our other modules, is an interface to a generalized protocol for storing text. We have high hopes for how Publish can evolve into a flexible tool for notetaking and discussion with richer content types and better controls over structuring discussion.

### Modules

<img class="ba" src="https://media.urbit.org/site/posts/essays/intro-os1-home.png">

You’ll find a few other things on the home screen: a clock, the weather, and a simple command-line that we call the Dojo. These are system-wide utilities that aren’t group-specific.

The clock and weather tiles are simple indications of the state of the outside world. We built them because they’re things we wanted to be able to check in on often. When you’re spending much of the day in front of a computer, it’s nice to know if you have enough daylight left to get some exercise in.

### Dojo

<img class="ba" src="https://media.urbit.org/site/posts/essays/intro-os1-dojo.png">

The Dojo gives you a quick way to see that, under the hood, Urbit OS is a powerful general-purpose system. The system hasn’t evolved to the point that our libraries, frameworks, and modules are polished to our standards. Since it’s still early, we can’t claim that it’s easy to develop on top of this platform. But we want it to become much easier.

## Why we made OS 1

We made OS 1 because we wanted to begin the process of re-centralizing our digital lives on a platform we actually control. Replacing all the services we use all at once is impossible — so we picked a suite that we felt would work nicely together. We’ve always felt that one of the most exciting things about Urbit is in bringing your digital life together in a way that feels like home.

The digital home, we think, is what our computers are meant to be but simply can’t be in a world of cloud services. Once upon a time, thirty years ago, your personal computer was an open-ended tool that was reasonably simple to understand and use, lasted a pretty long time, and belonged to you in every way.

OS 1 is a first step down the road back to a system that’s simple, durable, and belongs to you in every way. It’s a long road, and we feel like we’ve made a very significant step forward.

One really critical thing about OS 1 is the pattern of ‘groups sharing modules’. This pattern makes it perfectly clear how a virtual computer can outcompete a bunch of different services. As the collection of modules in OS 1 → N grows, we make it easier for others to contribute modules, and we increase the flexibility of connecting modules our system quickly outruns the messy, disconnected world we’re currently stuck in.

OS 1 isn’t mature enough to be _easy_ for outside contributors to add modules — but it is [open source](https://github.com/urbit/urbit), and anyone is welcome to tinker and experiment with modifying it. We run a [grants program](https://grants.urbit.org/) to reward contributors for improving any part of Urbit OS. As the system matures we expect this program to expand and accelerate.

## Looking ahead

By using OS 1 you inherit all the benefits of running Urbit OS. Each user runs their own node completely independently. Everyone using Urbit OS owns their own identity and data. And every Urbit OS node communicates over an encrypted and authenticated network. (Again, We don’t yet call Urbit OS ‘secure’ because it hasn’t been audited.)

OS 1 is just a client for Urbit OS, of course. Other people could write their own clients that are completely different — like different windowing systems for Linux. Our hope is to build a client that includes interface components and frameworks that make it exceptionally easy to build modules for groups of people to share. Other clients could potentially invent entirely new ways of interacting with the underlying system.

There are two threads by which OS 1 evolves into OS 2 and beyond. First, by becoming a more powerful system and second, by adding modules to expand our supported modes for interacting.

In its current form, OS 1 by no means exposes all the power of the underlying system. Our approach to building OS 1 was to focus on the quality of the UI, and accept that it will feel like a monolithic app. We’re already working to evolve our interface into something that feels flexible to an ordinary user and developers can easily extend and build on top of.

Specifically, we want better affordances for putting multiple streams of data on the screen at once, better keyboard shortcuts and navigation affordances, better libraries and frameworks for building modules. We want a standalone client and a single login system. These are some of the things currently on the drawing board.

As far as modules are concerned, there are too many things we’d like to build to list them all. We’d really like to have threaded conversations; short, Twitter-style messages; biometric and status tracking; an e-book reader and annotations system — and that’s just to name a few we see in the near term.

We’ve long since felt that the most powerful thing about Urbit is that it’s a general-purpose system. OS 1 puts us on the road to giving people an actual material sense of what using a general-purpose networked computer feels like.

As we expand the affordances of the system and add modules over the course of OS 1, 2, and beyond we expect to deliver a system that can foster everyday creativity. There’s a long road ahead, in the best possible sense. We’re really excited about what the future holds.

### Becoming a homesteader

<img class="ba" src="https://media.urbit.org/site/posts/essays/intro-os1-landscape.png">

As a distributed team trying to stay connected, we like using OS 1 from day to day. We’d really like to hand-onboard a small group of like-minded groups of people who want to experiment with living on the fringe of the digital world. Toward this end, we started the community grants program.

Each community that’s selected will get a block of address space to share, direct support, and (in the near future) free hosting.

Please tell us a bit about yourselves [here](https://urbit.org/community/community-grants/).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Value of Urbit Address Space (2 of 3)]]></title>
            <link>https://urbit.org/blog/value-of-address-space-pt2</link>
            <guid>https://urbit.org/blog/value-of-address-space-pt2</guid>
            <pubDate>Sun, 12 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt2.jpg)

_This is the second in a series of three posts on Urbit address space. See also [part 1](https://urbit.org/blog/value-of-address-space-pt1/) and [part 3](https://urbit.org/blog/value-of-address-space-pt3/)._

## Measuring value

Value and price are distinct concepts that often get conflated. In our view, Urbit address space has value for four fundamental reasons: it’s scarce; it has utility; it has some limited liquidity; and it has network effect. Price, on the other hand, is always a function of supply and demand, and it's not something we – as builders – concern ourselves with very much. Let’s take a look at these fundamentals within the Urbit ecosystem.

## Scarcity

256 galaxies, ~65,000 stars, ~4B planets.

![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt2a.svg)

A foundational design principle of the Urbit network is that the address space is limited. This rarity helps qualify Urbit as a [collectible](https://nakamotoinstitute.org/shelling-out/), and thus creates a non-zero acquisition cost for an address. This cost discourages abuses like spam and bot-net attacks. Traditionally, these attacks are made with quasi-unlimited access to IP addresses. The unit economics of acquiring planets for these nefarious purposes is a strong deterrent.

There are 256 galaxies on the network. Each galaxy is initialized with ownership of 255 stars. Galaxies act as root nodes for peer discovery and packet routing within the Urbit network, and they are each also entitled to vote on updates to the smart contracts which govern the network. To date, galaxies trade primarily on OTC (over the counter) desks, and rarely appear on the open market.

There are 65,280 total stars on the network. In turn, each star is initialized with ownership of 65,535 planets. Stars currently trade on platforms independent of Tlon, such as [urbit.live](https://urbit.live/) and [opensea.io](https://opensea.io/). The current price range can easily be ascertained on those sites, but as of the time of this writing, stars are selling at a price that greatly discounts their planet holdings.

One would expect that in an efficient market the relative pricing of stars on one hand, and planets on the other hand would eventually align (so to speak). This may come to pass as the Urbit community increases education about Urbit, and as additional planet sellers and hosting providers enter the space.

Finally, there are 4,294,901,760 (or ~2<sup>32</sup>) planets on the network. Planets currently trade largely in a range of $10 to $15. We expect planet prices to fluctuate from provider to provider as described in the previous post, based on the quality of services various providers offer. That said, it's worth noting that the cost to configure addresses for distribution is fairly static and this may act as something of a lower bound.

That said, we also anticipate that planet prices will be abstracted away from most purchasers, and will be included in bundled annual packages of hosting and data routing services. For this reason, infrastructure service providers (i.e. hosting providers) will likely be the best positioned parties to capture value from planet distribution.

While an increase in the supply of Urbit address space is a technical possibility, it would run counter to the economic incentives of Urbit address space owners. This is why we view a galaxy vote to dilute address space as improbable.

Scarcity may be sufficient alone to drive value, but it’s much more impactful when the unit has some underlying purpose, which brings us to utility.

## Utility

Utility (i.e. what Urbit addresses can be used for) has largely been addressed in the previous installation of this series. Briefly, our view is that stars and galaxies are useful for more than simply selling their subsidiary address space. Their use value encompasses their unique functionality on the network and the business models that functionality represents.

As a refresher, this use value falls in five broad categories.

1. Authentication technology is broadly useful. All Urbit identities — planets, stars, and galaxies — can be used for authenticating one’s Urbit computer, and for authentication in general. Urbit ID was designed for Urbit-specific authentication, but a lot of general functionality can be built on top of this infrastructure. Urbit ID is simple, extensible, and easy to use, making PGP style claims much more useful than they are today.
2. Network infrastructure services represent a potential revenue stream. Stars and galaxies specifically should be understood as providing their owners the opportunity to develop and use network infrastructure. We anticipate that stars and galaxies will eventually charge for infrastructure related services, like hosting and packet routing, and will distinguish themselves on quality and service.
3. Stars and galaxies are well positioned to offer additional services. Because of their role as high level network nodes, stars and galaxies are uniquely positioned to offer additional services, including content delivery networks (CDNs), Bitcoin and other blockchain-related nodes, 0x relays, and Tor exit nodes.
4. Schelling points have value. Because stars and galaxies hold a certain authority on the network (by dint of their relationship to their subsidiary nodes), they act as [Schelling points](https://nav.al/schelling-point), or default hubs, for various activities that will arise as the network grows. Already various groups and communities are beginning to collect around stars. This gravity has value and will eventually be priced.
5. Voting has value. Galaxies exclusively hold a vote on the network. This voting right can be separated from the galaxy itself and transferred, and we anticipate that this will happen eventually. The value of this right has not and may never be priced into the market, though as Urbit adoption grows, the value of a vote may emerge.

Utility is only one component of a value calculation. To further develop the inquiry into value, let’s move on to trading factors.

## Trading, volume, and liquidity

Urbit IDs are individually represented by non-fungible ERC-721 tokens, and can therefore be sold by any platform that supports this token standard. Currently there are three known Urbit-exclusive sales platforms and one generalized ERC-721 platform that list Urbit IDs. Prices for stars and planets are readily available. Volume is low, as no effort has been made to promote the fact of availability, yet the number of [total transactions](https://azimuth.network/stats/events.txt) has increased steadily since the network was launched to Ethereum in 2019, even absent public messaging.

![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt2-tps.svg)

![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt2-tss.svg)

Buying non-fungible tokens like Urbit IDs is rather different than trading quasi-fungible tokens like Bitcoin (even setting aside the issue of volume). Each Urbit ID is unique, and so they tend to be purchased by end users for their specific characteristics, rather than generically. As an example, the planet `~parret-barret` sold for about $1,000 at a time when most planets were selling for $10-20, perhaps due to its rhyming name. Planets with circular sigils also often sell for significantly more than other planets — we’re not entirely sure why this is the case.

## Planet Sales

![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt2e-price-eth.svg)

![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt2e-price-btc.svg)

## Star Sales

![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt2e-price-btc-usd.svg)

This ID-specific trading pattern is generally appropriate in our view: Urbit ID isn’t designed to be rapidly traded at high volume. Urbit is more like a house than a fungible good like a currency.

For the time being buying and selling of Urbit IDs happens through auctions on specific platforms, and via person-to-person transactions, because each transaction is for a _specific_ Urbit ID. Again, Urbit ID is designed in the spirit of property titles, rather than currencies, so this makes sense.

Strictly speaking, liquidity is a measure of the degree to which a given asset will change in value due to a given transaction. In that sense, Urbit address space is likely fairly illiquid. But liquidity can’t be properly understood without volume. As noted above, the volume of transactions on the network has been steadily increasing since inception, and yet the price has remained fairly constant. This seems to indicate a healthy ratio.

![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt2b.svg)

A further impact on liquidity and volume is that of available supply. At present, the majority of Urbit address space is locked by smart contracts. These lockups began to release at varying linear rates in January 2019. All address space will be completely unlocked and tradeable by January 2025. Eventually as both understanding and demand increase, we anticipate that planets will find an equilibrium price, and stars will be repriced accordingly.

We’ll discuss lockups and spawning limits in more detail in the third installment of this series.

In our view, this combination of scarcity, utility, and the above trading factors is a useful description of existing market dynamics for Urbit address space. A further description of why Urbit has value lies not just in its trading characteristics, but in the utility of human interaction. This brings us to network effect.

## Network effect

Much is made of the concept of network effect and its impact on network valuations generally. The concept is fairly straightforward so long as numbers aren’t applied. Broadly speaking, networks are interconnected systems of people or things. Network effects are mechanisms wherein every new user of a given system makes the system more valuable to every other user.

Urbit is a network of networks, and it’s designed specifically for communities — for communication and collaboration. The more people who use Urbit, the more communities get started by design. The more communities there are, the more likely outsiders get pulled in to join them, and so the virtuous network effect cycle continues.

Digging deeper, Urbit is unusual as a network for the following interrelated reasons:

1. Urbit is a platform in the true sense; wherein
2. connections are peer-to-peer;
3. privacy is high;
4. discoverability is low;
5. customization and autonomy are nearly limitless; and yet
6. the number of possible groups and node connections is essentially unbounded.

The upshot is that Urbit can serve as the meta-network for many different kinds of individual networks, each with their own value. Urbit is much more akin to the internet itself than it is to, say, Facebook. Reed’s and Metcalf’s laws therefore apply to Urbit in some very interesting ways.

## Network laws

Before diving into a discussion of network effect, it's worth noting that although individual tokens and users of those tokens benefit in various ways from a thriving network, the structure of the Urbit network does not grant token holders any rights to profits or losses "generated by the network" as a whole. In fact the very notion is counter to the intent of Urbit's ethos of decentralization. Individuals on the network may profit by their own activities, but there is no central authority profiting off activity in the aggregate; there is no ownership of the network as a whole, and so there are no centralized profits and losses to share. Address space tokens represent one's ownership of their own parcel of land as it were.

That said, an entire continent may have aggregate value even though it is distributed. To explore this notion with regards to Urbit, it's worth reviewing the three laws typically cited to express the value of a network as a whole:

- Sarnoff’s law states that the value of a network increases proportionally to its size. This is widely understood to understate the value of most modern networks.
- Metcalf’s law states that the value of a network is the square of the number of users (n^2).
- Reed’s law states that the value of a network increases with the number of groups that can be built on the network. This is expressed as 2^n, where n is the number of groups.

Reed’s law captures the notion that groups vastly increase the density of connections on a network and so scale value more quickly.

Urbit is a network of networks, and so is best described by Reed’s law.

Urbit’s unique approach to groups also helps resolve two other problems which lead to value loss in many networks: Urbit’s design significantly reduces both network pollution (i.e. irrelevant feeds) and network congestion (clogged bandwidth), as individual clusters can easily separate their activity from other networks on the platform.

## Urbit is a platform network

It’s important to note that Urbit has utility absent the network, as Urbit OS is in fact a Turing-complete virtual computer. Though the system is designed around communities, individuals can use Urbit to create personal documents, archive data, and write code for the system. This is how Urbit’s total network size can be relatively small and still provide value for individual users and clusters. However, Urbit already has users, and for many of these, critical mass — the point at which the network is more valuable than its cost — has already been reached. In addition, as each of these individual clusters writes code for the platform, positive indirect network effects increase (more utility arises from these individual development efforts).

This combination of effects makes Urbit significantly more robust than non-platform networks which can’t rely on this intrinsic utility.

That said, we do not intend to ever rely simply on this individuated computing utility alone. Urbit is for communities, and Tlon’s primary focus is to increase adoption of the system as a whole, including the network. To this end we’re working steadily to increase functionality of the system, improve messaging, and actively onboard communities.

## Network identity

Another distinguishing characteristic of Urbit is that identities are pseudonymous but can easily be de-pseudonymized by users at will (though not by outside authorities). This flexibility combined with identity reputation accrual means people can behave in different ways depending on the social context. People can communicate privately, publicly, or in small groups, and they can do it anonymously or otherwise. This natural and extensible approach to social engagement results in personal comfort and drives adoption.

## Extensibility

Because Urbit is vastly customizable, and because it’s a network platform for other networks, it can and should grow in ways we can’t predict. Each new use case that develops creates a new market, new communities, and new hubs. Each of these contributes to the diversity of the overall ecosystem, making it vastly more interesting and diverse than anything we might create alone. We expect this extensibility to contribute greatly to retention as users are able to build the world they want to inhabit.

Urbit is a deeply extensible platform for communities: it’s a network of networks. Users join to be part of communities, then launch communities of their own, further driving growth and engagement in a virtuous cycle.

In the next installment of this series, we’ll describe lockups and availability in more detail and will share the data we’ve managed to compile about address space distribution.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Infrastructural]]></title>
            <link>https://urbit.org/blog/infrastructural</link>
            <guid>https://urbit.org/blog/infrastructural</guid>
            <pubDate>Thu, 09 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/infrastructural-1.jpg">

## Seasons

It’s early 2020, the transition between winter and spring, and Tlon’s interface group has concluded a series of projects that mark a transition point for the Urbit project. We’ve named the culmination of our efforts “OS 1,” as in “Operating System 1.”

For those who have yet to try it out, OS 1 is a bundling of “essential digital utilities” in the form of 1) a linear chat, 2) a long-form text editor and publishing/discussion medium, 3) a link bookmarking/discussion software, and most importantly, 4) a grouping mechanism that allows you to bundle the above services in the context of a group of friends, acquaintances, or family. We see these utilities as being archetypical “software shapes” that are inherently flexible and open for interpretation in terms of their use, but we have wild expectations for how these software shapes will evolve in the near future. Later design output and supplementary writing will expand upon what we mean by this.

Functionally, OS 1 has been designed to serve as a bridge between [OS 0](https://urbit.org/blog/landscape-a-portrait/) (The first interface in Urbit’s evolutionary chain) and OS 2 (Urbit’s eventual departure from the web browser context). In its service as a “bridge”, we designed OS 1 to extend from the baseline app-like “module” experience first defined in OS 0, while granting it new affordances that gesture towards nascent conceptions of “communal computing” we have planned for OS 2 onward.

This year, as the warmer seasons give way to chillier ones, we plan on further demonstrating our vision of what new computers and networks can be and how they feel to use. Until then, we'll be building upon OS 1, our foundation and initial take on what we deem "human-shaped infrastructure."

This post serves as a reflection–meditation on OS 1’s initial form development and the attitude we brought to bear in designing it. I will be highlighting a few disparate-yet-interconnected themes we encountered in our design work, and how we materially began to address them.

## Products

Urbit’s interfaces, and the process by which we build them, are resolutely not projections of the world’s current conception of digital design—that of mass digital product design. Products are sold, bought, and discarded as they are in their physical sense. Digital products are slotted into the [vending machines](https://urcad.es/writing/personal-computer-vending-machine/) we call our phones and are mass produced as candy is produced. Candy is _essentially_ free, and contemporary digital products are _absolutely_ free of cost. If you’re reading this, you probably already have a good idea of what free corporate digital products mean for your privacy.

Urbit is distinctly _not_ free (as in freely offered as a service via a corporate entity), and your urbit is distinctly _not_ a product. As we trace over the interfaces we design with our cursors, we’re not building a product, we’re not selling a product, we’re not painting a product, and we’re certainly not decorating a product.

Here at Tlon, we’re assembling thoughtful infrastructure you can spend your life using, learning, and extending. We’re attempting to assemble spaces you can one day pass on to friends, close collaborators, or possibly your grandchildren. We are resolute in our practice and stay our hands to the greatest degree possible as a result of this mindset.

## Beautiful Infrastructure

OS 1, while incremental in its initial expression from OS 0, serves to outline our stance of what sublimely beautiful, useful, and durable digital infrastructure should feel like to inhabit. For the purposes of OS 1, we can imagine “Beautiful Infrastructure” to form the spirit of what we’re building:

**Beautiful infrastructure is inhabitable**. You’re not floating in an infinite feed of content streams. You are situated in a defined space with edges you can shift at-will, as your needs deem fit. Our model for inhabitable computing is new and in limited flux, but our vision is long.

**Beautiful infrastructure is a gravitational force**. Even if you can’t feel it or directly experience it, well-designed infrastructure is a cohering force. One is grounded with respect to the infrastructure they live alongside.

**Beautiful infrastructure is like a [shell](https://en.wikipedia.org/wiki/Shell)**. Well-considered infrastructural projects provide durable, generalized, reusable, and most importantly, _self-designed_ containers around otherwise formless flows of information.
The current state of mass software design has gotten many of the “reusable” elements of design down pat, but these structures are optimized to pump ads and information into your brain, algorithmically-sorted-linear-feed style.
In Urbit, I can take the conceptual container of "temporal linearity" and use this to shape communication data as I see fit. I should be able to shape once-linear communication and cast it into a nodal communication model: My DM is now a MUD.

Truly beautiful infrastructure undergirds the daily exchanges people actually care about—I don’t drink plumbing, I drink the water it carries and protects.

Another way of thinking about “Infrastructure” (here defined loosely as “the _truly_ essential structures that allow society at varying scales to operate”) is to think about it in terms of interpersonal support structure.

We deeply hope that Urbit can form a support structure for you and your community.

These self-evident statements underlie the core problems we sought to address in designing a userspace for OS 1: How do we design an _actually_ personal digital infrastructure? What does infrastructure look like when shared with immediate friends? With a cooperative organization? How can we impress upon Urbit's earliest adopters that once they've obtained an Urbit ID, their computer is at that moment _literally_ entirely theirs?

<br>

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/infrastructural-2.jpg">

## Expressing Infrastructure

OS 1 was optimized from an interface design standpoint to ensure that a new inhabitant viscerally felt like there was a “space to inhabit”, or a “canvas to be painted”, or a set of simple and fundamental digital structures they could arrange to make their computer their own.

Counterintuitively, designing around this notion of a "rich blank slate” required OS 1 to be designed in a manner that _almost_ results in it feeling incomplete, or on the verge of appearing deeply unremarkable.

A few key design decisions emphasized the above gestalt we sought to express:

- We decided very early on to revert the colorful presentation of Modulo to a literal blank slate—OS 1 is much like a sheet of graph paper now.
- All typography and typographic representation was severely flattened. This decision was one of our more drastic ones, and granted OS 1 a sense of being somewhat more "undirected" in terms of its form. We hope that as our system becomes more robust, users can decide which elements of their systems require emphasizing, to feel most at home with their information.
- The majority of graphics used throughout the system were rendered into black and white line drawings. As architectural schematics and orthographic projections flatten their representation of reality so an architect can “see structure” easier, we made the decision to express a visual foundation that felt more like a diagram than an ergonomic user interface.
- In its visual simplicity, OS 1 was essentially arranged to emanate the quality that modifying the underlying system was a simple task. Rather than present Urbit's first users with beautiful artistry and a sense that our infrastructure was to remain untouched and sacred, we decided to present a visual face to the project that felt nearly rudimentary, nothing outside the realm of editorial capability for the average person.

Many other small constraints have been set into place to build what we truly believe to be simple, durable, personal, digital infrastructure.

While visually primitive, OS 1 has managed to manifest a rich systematic expressiveness based on how it seems to be currently inhabited. We've been enjoying witnessing the ways people are beginning to interpret and make use of the faculties provided to create communal computing experiences of their own.

What's most wonderful to observe is the fun people are having in striking out on their own in this collective endeavor. More than anything, we hope Urbit’s inhabitants are having a good time and learning to enjoy computers again.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Value of Urbit Address Space (1 of 3)]]></title>
            <link>https://urbit.org/blog/value-of-address-space-pt1</link>
            <guid>https://urbit.org/blog/value-of-address-space-pt1</guid>
            <pubDate>Mon, 06 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/value-of-address-space-pt1.jpg)

_This is the first in a series of three posts on Urbit address space. See also [part 2](https://urbit.org/blog/value-of-address-space-pt2/) and [part 3](https://urbit.org/blog/value-of-address-space-pt3/)._

## Part One – What/why, a history, and some analogies

Does Urbit address space have value?

The short — but perhaps not very useful — answer to this question is that yes, the market appears to believe that it does have value. This series of posts digs a bit deeper into why.

As developers, we at Tlon tend to focus on building functionality rather than valuation models – possibly to our detriment. When we discuss Urbit address space, it’s typically about the technical elements, or the use cases.

Now that people are using Urbit on a daily basis, we want to make sure that Urbit IDs (collectively “Urbit address space”) are well-understood. We thought it would be useful to explain our thinking about value, and to provide some of the building blocks that others can use to create their own valuation models.

There’s a lot to discuss, so we’re breaking this discussion into three posts. The first explores what Urbit ID is, shares some history, and provides a few analogies that can help in understanding value on the network. The second looks at scarcity, utility, liquidity, and network effect. The third post explains lockups and availability.

For a refresher about what we’re doing, check out our [introductory materials](https://urbit.org/understanding-urbit/) or [Urbit for Normies](https://urbit.org/blog/urbit-for-normies/).

## Urbit ID basics

In order to explore why Urbit IDs have value, we’ll start by explaining the basics of how they function.

From one perspective, Urbit ID is simply a means of logging into Urbit OS. From another, Urbit IDs represent a new class of digital asset.

From the standpoint of an ordinary Urbit user, Urbit ID is designed to be simple: it’s a login system for a new OS, but with one or two unusual qualities. Under the hood, your Urbit ID is your network address, your username, and a digital asset wallet. Anyone can use your Urbit ID to locate you on the network, and then send you messages (i.e. packets), or digital assets.

We say that Urbit IDs represent a new form of digital asset for three reasons.

1. Urbit ID is designed such that the user actually _owns_ their name. This means that Urbit IDs are transferable and tradeable. Conventional username and password schemes are merely claims to a bit of data on another party’s server. An Urbit ID, on the other hand, is a piece of cryptographic property on a public key infrastructure.
2. Urbit IDs have utility: they’re currently useful in the Urbit ecosystem, but beyond that they’re vastly extensible and they can be used for many more purposes. Owning an Urbit ID is a bit like holding a self-authenticating property title. If Bitcoin is money and smart contracts are law, Urbit ID is land.
3. Urbit IDs are scarce in order to discourage spam and abuse.

We’ve often said that Urbit IDs have value because they’re useful and scarce. The fact that they’re being traded on platforms independent of Tlon seems to bear this out.

## Urbit network structure

The network of IDs is structured as a sponsorship tree consisting of 256 galaxies, ~65,000 stars, ~4B planets.

Galaxies are the root nodes on the network. They each have a vote on upgrades to the rules that govern the network, they provide packet-routing and peer-discovery services, and they spawn stars. Each galaxy has 256 (2<sup>8</sup>) stars to spawn.

Stars similarly provide packet-routing and peer-discovery services, and spawn planets. Each unbooted star contains ~65,000 planets (2<sup>16</sup>).

Planets are the individual IDs that most people use on the network. There are a total of ~4B (2<sup>32</sup>) planets all combined. Planets can also each spawn ~4B ‘moons,’ which are Urbit IDs intended to be used for IoT and other devices. Moons are permanently locked to their planets for security and to protect the network from sybil attacks.

Stars and planets can leave their sponsors (i.e. the star or galaxy currently providing peer discovery and packet routing) if they wish, and sponsors can choose to stop servicing any given star or planet. This is intended to prevent lock-in and to encourage good behavior from both parties. This mutual accountability is important in a network of finite identities that accrue reputation.

Essentially Urbit ID is 2<sup>32</sup> individual names that are bundled into blocks that are larger and larger in size. You might think of a planet like an individual house, a star like a town or a city, and a galaxy like a county or a state.

The Urbit ID registry and its rules are built on a set of smart contracts called [Azimuth](https://github.com/urbit/azimuth). These contracts are registered on the Ethereum blockchain. Galaxies can upgrade the mechanics of Azimuth by majority vote.

Today, Urbit ID is live and deployed. Each Urbit ID is represented by an ERC-721 non-fungible token. People buy and sell Urbit IDs every day and the number of transactions has been steadily increasing.

So, fundamentally, Urbit ID is just a finite set of names and a system for assigning them. We’ve left out a few technical details here, but if you’re curious you can read our [introductory](https://urbit.org/understanding-urbit/urbit-id/) materials or, to go deeper, read the [docs](https://urbit.org/docs/) or the [source](https://github.com/urbit/azimuth).

## Why we need a new address space

In our view, the short history of the Internet has been a lesson in centralization and consolidation. DNS is a cabal of root servers. IP is essentially controlled by a single entity. All of our naming schemes have been more or less centralized. Certificate-signing is a mess of competing authorities. Search is Google. Hosting is AWS. And don’t even get us started on social networks.

Centralization on its own isn’t bad, but it certainly has some negative implications, privacy being the most obvious. Beyond that, the naming schemes we have on the Internet today aren’t _personal;_ they’re not controlled by their users.

Simultaneously working against this trend are a variety of decentralized web projects, various digital currencies, and dozens of protocols that are all focused on individual use and distributed ownership. But how do any of those actually surface to the mainstream? How do people identify themselves in this new digital world? Where do they call home? Where’s the Schelling point when they want to connect and work together?

Urbit ID is the missing piece. It’s the minimally viable substrate for the digital world that’s been sketched out by Bitcoin, Ethereum, and all of their decentralized kin. From our perspective, the kit of decentralized technologies that exist today is designed for a world that’s only just coming into existence. That new world shouldn’t be owned by any one entity; it should be distributed. We believe that Urbit OS and Urbit ID are the right foundation for interacting in that world.

The ownership structure of a new territory has a huge impact on its future shape. While most of Urbit ID remains an uninhabited grid, we see it as most likely to become a varied array of neighborhoods and cities. Not because this is a nice outcome, but because it’s the most economically likely one. More on the concept of neighborhoods below.

## History and distribution

So how did these ~4B names get initialized and distributed? Urbit address space was created _ex nihilo_ — from nothing but an idea — and then distributed directly to project contributors who helped develop the system.

Now that the system is up and running, Urbit address space has steadily become more distributed. This arguably follows the distribution patterns of the Bitcoin UTXO set, and even historical distribution patterns of physical land.

Let’s take a look at how this came to be.

Urbit was originally an experimental personal project. The original Urbit address space registry was just a text file in the source code at that time. At the very beginning, all of the address space was owned by Curtis — its creator — and it was all pretty much worthless. In the years leading up to 2013, Curtis gave away galaxies to anyone who would help or contribute to the project, and to several people who were simply in the right place at the right time.

Once Urbit became a working prototype, in mid 2013, a company (Tlon) got off the ground to help develop Urbit and a number of other developers joined. At this point, Tlon bought half the address space from Curtis for what now looks like an exceptionally good deal. Then Curtis and Tlon each earmarked a significant chunk of address space for infrastructure and community development — we refer to this as the urbit.org address space, and it’s held by Tlon.

From 2014-2018 Tlon and Curtis both gave away address space to individual contributors who were helping with the project. In 2016 and 2017, Tlon sold some of its address space in two crowdsales to fund the development of Urbit (which formatted the Urbit address space as a user-facing system). These sales were focused on getting address space into the custody of users with an interest in the technology and developing the network.

It was then decided that a public key infrastructure was the most logical way to instantiate ownership of Urbit address space. Thus, after much [consideration](https://urbit.org/blog/urbit-and-the-blockchain/), Urbit ID was deployed to Ethereum in January 2019 under a set of contracts called Azimuth. At this point, there were about 2000 star holders and around 80 galaxy holders. We can’t be sure how many independent holders there are now — the address space is entirely out of our hands — but the distribution has been steadily increasing. Addresses trade regularly on urbit.live and Opensea, and are sold by a few other smaller outlets like planet.market and Urbit Marketplace, all of which are independent of Tlon.

## Analogues and the intrinsic value of address space

We’ve often said that Urbit address space, particularly stars and galaxies, have intrinsic value that should be understood beyond simply the price of the planets they contain. Another way of putting this is that, because stars and galaxies are infrastructure nodes, they’re uniquely positioned to generate cash flow from activities on the network beyond simply selling their planets.

This cash flow won't likely come from passive activity, but from actively working to develop businesses located on stars and galaxies. Let’s dig a bit deeper into these activities through the lens of some analogues to the existing world.

### DNS

We’ve often compared Urbit ID to the IPv4 and IPv6 systems. In this scheme, galaxies are much like [/8 blocks](https://en.wikipedia.org/wiki/List_of_assigned_/8_IPv4_address_blocks) of IPv4 addresses, while planets are much like individual IP addresses. The difference is that IP addresses are rarely owned by end users, and they’re typically assigned dynamically, so they tend to change. This is why IP addresses can’t be used to accrue reputation for end users or to prevent spam. It’s worth noting that while most of us don’t own our IP addresses; they are currently [traded](https://auctions.ipv4.global/) on the open market. As of the time of this writing, individual addresses are selling for ~$20. /8 blocks are extremely valuable, and none are currently on the market.

### ISPs

Another analogy that we often use is that of ISPs (Internet service providers). Stars in the Urbit network are the closest approximation here in that they help planets connect to the network. Ultimately, connections on Urbit are peer-to-peer, but stars provide initial connections, distribute software updates, and route packets when peer-to-peer connections don’t yet exist. These services all represent a cost, and we believe they’ll eventually be metered and priced.

### CDNs

CDNs (content delivery networks) are another useful comparison. Stars are perfectly positioned to play this role in the Urbit ecosystem. Because stars are designed as packet-routing infrastructure, they’re able to easily spin up greater bandwidth to service high-demand content, or to aggregate content. Stars can also act as content curators and providers, or as content filters for those who want a more narrow range of access. On the other end of that spectrum, stars could easily function as something similar to VPNs (virtual private networks) for any type of content.

### Software distribution

An infrastructure innovation that’s relevant here is that Urbit OS is specifically designed to make over-the-air (OTA) updates to the system — meaning software and updates are distributed automatically with no effort on the part of the end user. By default, planets and stars get their system updates from their sponsors. As the system evolves, we expect stars and galaxies to not only provide core system (kernel) updates, but also to act as software distribution hubs. Stars will distinguish themselves from one another by the quality of their service. Some might focus on speed of distrubtion; others on assesing the quality of the code they distribute. All of this represents effort on behalf of the star, and could act as a profit center for the star operator.

### Payments and transactions

On top of routing and software distribution, there are likely other worthwhile services for stars and galaxies to provide. A payments-focused star could run Bitcoin, Lightning or Ethereum nodes exclusively for sponsored planets. A trading-focused star could run a 0x relayer and provide an order book for sponsored planets. It’s easy to imagine machine learning or compute services being offered as a service; for example, a star could bolt on a TensorFlow chip and allow its sponsored planets to run computer functions for a fee.

### Land

We often use land as an analogy to describe Urbit address space. This is not simply because Urbit address space is finite or because IDs act as addresses on the network. It’s because Urbit is designed to be extremely extensible. Once you take possession of your Urbit — whether it’s a galaxy, star, or planet — you have immense flexibility: you can use it as-is out of the box, you can rearrange your environment, or you can go as far as writing code to create new functionality. Urbit address space is meant to be used productively. Urbit is very much territory for homesteaders.

We expect that certain groups of Urbit IDs will be more valuable than other groups. There is no unit price for physical land — rather, price depends on location and a host of other factors. Similarly, we expect a range of prices to develop for Urbit IDs. We’ve already seen price variation around specific names and [sigil](https://urbit.org/blog/creating-sigils/) shapes.

In the long term, the real value of an infrastructure node (a star or galaxy) is not simply in trading on the unit price of planets, but in developing and improving the real estate.

### Dealer-operators

Another approach to developing the value of address space that is already emerging is that of the dealer-operator. The most convenient way for an ordinary person to use Urbit is to have a planet hosted in the cloud so they can log in from any device. Because the long-term value of a star or galaxy is in providing services, and because most planets and stars need to be hosted, providers of these services have begun to emerge.

These providers sell users a planet, host it for them, and deliver related services through their stars and galaxies. This means that with a couple of clicks an ordinary user could buy a planet, sign up for a hosting/routing bundle, get access to a set of services, and be immediately ready to interact with the community of their choice.

There are plenty of other examples that we haven’t even imagined yet. The important thing is that stars will likely distinguish themselves through the services they provide. Since planets and stars can always change sponsors, a large part of the long-term monetization of a star or galaxy lies in the quality of service that a given star operator provides.

This independent ecosystem has a secondary benefit of creating a varied tapestry of digital environments on Urbit, since every community and every dealer-operator can customize as they see fit. That variety will make the landscape much more interesting and ripe for exploration than anything we might create with the top-down approach found on centralized services. That variety will also likely cause a range of values for planets depending on their sponsor or “location”.

This ecosystem has already begun to emerge. Both Tlon and urbit.live are working on developing services along these lines, and we’ve heard from several other entrepreneurs considering similar offerings. This is emerging not simply because it serves a user need, but because it’s the directional flow of the system. In other words, it’s the simplest way to monetize address space while avoiding the oligarchic, surveillance-based, advertising-oriented systems we’re stuck with today.

To summarize, our view is that Urbit address space is valuable because it’s useful and it’s scarce (and it has network effect, but more on that later). What’s more, while the use case has already begun to take shape, it will grow in directions we can’t yet imagine because the system is designed to be extensible — Urbit is a homestead, not a hotel.

We’re looking forward to seeing what the world builds with Urbit.

In the next post in this series, we’ll explore the issues of scarcity, utility, liquidity, and network effect.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2020.4.4 Update]]></title>
            <link>https://urbit.org/updates/2020-04-04-update</link>
            <guid>https://urbit.org/updates/2020-04-04-update</guid>
            <pubDate>Fri, 03 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2020.04.04-update.jpg)

We’ve had a big week. On Friday, we presented OS1 to the world. The event included both an interactive demo, and a panel of Tlon developers and designers talking about the thinking, and the deep roots of computing history, that lead up to this moment. Lots of you attended online and asked great questions; thanks for coming! If you missed our livestream of the OS1 release event, a video can be found [here](https://www.youtube.com/watch?v=71ViyftPkGk).

Urbit OS1 is designed as a flexible, user-owned tool for creating and living in communities. To that end, we’re giving out sets of Urbit address space to communities who’d like to use Urbit. [You can apply here.](https://urbit.org/community/community-grants/)

If you’re a Hoon School graduate, we’ve got a big announcement: The inaugural Hoon School Hackathon, a free-form competition in which participants will have a month to create the coolest Urbit-related projects they can, runs from Friday, April 3 to Monday, May 4. A total of 22 stars are being given away to those who submit the best projects in this timespan. The Hackathon is only available to those who have graduated from a session of Hoon School. We’ll be sending an email out to everyone who is eligible.

Haven’t done Hoon School? Don’t worry! We will be running more hackathons in the future, at least two a year. The next Hoon School session begins on Monday the 6th, so there’s still time to sign up. Go to [urbit.org/community/hoonschool/](https://urbit.org/community/hoonschool/) to enroll.

OS1 is for [homesteaders and tinkerers](https://urbit.org/understanding-urbit/roadmap/). It’s profoundly new. It’s not our final destination, but it’s an important and foundational tool for getting there. And it’s a big leap towards allowing individuals and communities to use it for their needs. There’s already a growing constellation of public communities on Urbit. When you’re ready to launch OS1, check out our [install guide](https://urbit.org/getting-started/).

If you need a planet, you can buy one from [Urbit Live](https://urbit.live).

For updates on OS1 and the Urbit project in general, we encourage you to follow us on [GitHub](https://github.com/urbit) and [Twitter](https://twitter.com/urbit)!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Understanding Urbit Podcast]]></title>
            <link>https://urbit.org/blog/the-understanding-urbit-podcast</link>
            <guid>https://urbit.org/blog/the-understanding-urbit-podcast</guid>
            <pubDate>Thu, 02 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/uu-podcast.png">

At the end of January, the team at Tlon invited me to spend some time at their San Francisco office and to create a podcast series about Urbit. The idea was to produce an interview-based series about the project told in the words of those working on it. In this modest goal, I think we were very successful. Beyond a transactional description, however, we captured a range of perspectives of the flaws in our current computing landscape and visions for how Urbit will alter it.

Over the course of seven episodes, the interviews explore subjects ranging from the philosophy of technology to the performance optimization of Nock execution. Most are non-technical, but even the technical ones will be understandable and entertaining to a non-technical audience. That latter fact is the result of just how much fun the Tlon team is to be around.

The series can be found on iTunes, Spotify, and most other streaming platforms.

<iframe style="border: none" src="//html5-player.libsyn.com/embed/episode/id/13669184/height/90/theme/custom/thumbnail/yes/direction/backward/render-playlist/no/custom-color/000000/" height="90" width="100%" scrolling="no"  allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>

We begin our journey with Urbit veteran Galen Wolfe-Pauly, who introduces the project and its design principles while reflecting on the collective Stockholm syndrome we suffer in the grasp of existing computing models. We learn a bit about Galen’s background in architecture, and the importance of invisible technology.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit is for Communities]]></title>
            <link>https://urbit.org/blog/urbit-is-for-communities</link>
            <guid>https://urbit.org/blog/urbit-is-for-communities</guid>
            <pubDate>Sun, 22 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/urbit-is-for-communities.jpg">

## Generated, not fabricated

What is it that makes high trust communities take shape?

When I think of the places in the physical world where people seem to feel the most at home, they’re places that have evolved over long periods of time and are owned by the communities that inhabit them. Communes in rural California, Rome, rural Japan, and villages in Indonesia all come to mind.

These are places that aren’t designed in one go. They’re the product of lots of different contributors working in loose collaboration, often over long periods of time.

Places that grow under the care of the people who live in them seem, somehow, to become much more alive and engaged. The strength of connection in these communities is palpable. You can feel the difference.

There’s nothing even remotely like this in the digital world. The digital world is totally fabricated, stamped out, and controlled.

It’s not just the surveillance, lack of privacy, or interfaces optimized for addiction — those are all downstream from the root problem: our software can’t evolve with us. It’s designed and controlled by the people that make it. We don’t participate in shaping it directly at all.

And since our software can’t evolve with us, our connection to it remains thin. The digital world of today is low-trust by design. We live in a digital world controlled by other people. Nothing about it belongs to us.

It’d be great if we felt a deep appreciation for and connection to our digital communities the same way we do in the physical world. Digital communities should feel alive and engaged with their surroundings. They should feel as vibrant as a city on a summer night, cozy like a family dinner in an old ranch house.

We don’t often talk about it explicitly, but this is what Urbit is for. Urbit is for giving communities the tools to evolve their own environments; for us all to feel a sense of life and self-directedness in the digital world.

It’s not any single specific technical feature of Urbit that makes it well-suited for communities to homestead and develop. It’s the combination of the technology under the hood and the interfaces we build on top. Let’s talk about both.

## Technically capable

I love [this tweet](https://twitter.com/devonzuegel/status/1221804267083718656) about becoming a ‘digital prepper’. It feels like it has already happened to me, too. I’ve seen enough centralized services shut down and disappear (often with my data) that I’m reluctant to try new ones. No matter how friendly and cozy their branding.

I find myself vetting every new app or service to figure out whether they have the potential to survive far into the future. The giant services I’ve become dependent on all seem somewhat worrisome. How long can these free services possibly stick around? Certainly not forever.

The incentives in the current structure are totally misaligned. Let’s walk through them:

I want to keep my data forever, but most companies are beholden to growth. If they can’t produce that growth and die, my data either disappears or becomes unusable without their software.
I don’t want my data to be sold or for anyone to spy on me, but ad-funded companies have to engage in these practices to stay alive.
I don’t want a piece of software to go away if a company dies, but apps and services require maintenance that’s complicated and expensive to do. Without the company around, their software is useless.

The simple fact is, I let companies run my software because it’s too much work for me to run it myself. Most people can’t be their own sysadmin — and those that can have other things to do.

This is more or less the entire technical value proposition of Urbit: to build a system that’s simple enough that it requires almost no maintenance. Our approach to building software makes all of the above problems easily solvable.

Perhaps more importantly, we have a direct incentive to solve these problems. Tlon funds Urbit’s development by selling addresses and providing hosting. And the only reason anyone pays us for these things is because we make Urbit as directly useful for you as possible.

That means we have to solve the problems inherent to the legacy internet. There can’t be any sense of suspicion or uncertainty in our new system. Your Urbit has to be something you can really trust and attach to. This is why your Urbit lets you run or write whatever code you like, and why we’re focused on making sure the data you put into your Urbit lasts forever: it won’t disappear when some company dies.

But even with a system that fixes all of these issues by default, it only matters if the system is usable and understandable. What we really want is a digital world that’s generated by the communities that inhabit it — which means it has to be generated by people with no technical knowledge.

## Communities are built by people

In the physical world, you can arrange the furniture in your house, or go to Ikea, or build your own furniture, or figure out how to build a house from scratch. By taking your preferred approach to design, you contribute to the shape of your city. The world around us is a wonderfully loose collaboration between the more technically oriented architects and planners, and the everyday homeowners and residents.

The digital world is, of course, nothing like this. Even software developers are stuck with the current system. None of our existing apps or services can connect to one another, so whether you’re a user or a developer, you’re faced with the daunting task of replacing everything all at once if you want a better system. But nobody can do that.

Urbit provides an experience with less distance between ordinary use and total customization. To start, we’ve created Ikea-like, Lego-like and woodshop-like levels of usability. What we’ve built isn’t nearly as complex as the physical world, of course, but it’s a start.

For most people, customizing your Urbit should be a matter of picking from an available suite of modules. Not unlike going to Ikea. For some people, recombining interfaces and data sources within Ubit should feel like playing with Legos. And for others, who want to dive in and write code, it’s the same as going into a shop full of high-quality tools.

We’re not quite to this level of sophistication, but we’re on the path. Let’s talk about where we are and where we’re going.

## OS 1

Our rough attempt to satisfy this goal is hovering on the horizon. We call it OS 1.

In OS 1, you bring a group of people together to share a set of channels. A channel can be a chat, a notebook, or a collection of links. We built an interface for doing this, but you could just as well build your own. Inside OS1, data and interface aren’t stuck together like they are with apps in the default web. Nor are the people you’re connected with locked into any given Urbit app. App, data, and social graph are always separate in Urbit; they’re modular and always under your control.

OS 1 is designed to make it easy to start a group. Everyone in the group runs their own instance — so everything is only shared with the people you’re connecting with. Light customization of this experience is easy for an ordinary user.

If you want to go deeper, anyone can build a new protocol for storing data and transferring it around Urbit without too much difficulty, but you do have to write some code. If you really want to dive all the way in, you can modify the system all the way through to the kernel.

Currently, our Ikea experience is pretty limited, there are only a few Legos to play with, and the shop is still quite rudimentary — but it’s a good start and, for the first time, it exists as one complete system.

The system is ripe for experimentation, customization, and exploration. It’s ready for earnest homesteading. Come build.

## → N

OS 1 is really just the beginning. There are so many more modules and means of communicating and collaborating to add. There is so much we can do to make the system more customizable.

But OS 1 actually passes the bar of being both usable and futureproof. Urbit is something you can put energy into, in earnest, even as a digital prepper. It’s both safe enough and customizable enough that high trust communities can begin to take root. Urbit isn’t ready for you to build Rome — but it is ready for you to start a commune, salon, or reading group.

The point, in the long term, is to let the technology fade into the background. We want people not to be ruled by their software, but the opposite: for our software to grow to suit us. Our hope is for Urbit to be as invisible, calm, and reliable as possible — and for people to be at the center, in control.

If you want to explore this new world with us, let us know. We’re going to give away a limited number of hosted OS 1 communities.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Precepts: Discussion]]></title>
            <link>https://urbit.org/blog/precepts-discussion</link>
            <guid>https://urbit.org/blog/precepts-discussion</guid>
            <pubDate>Tue, 17 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/discuss-01.jpg">

The precepts aren’t arguments. We will discuss and justify them here. We don't expect to convince you this is exactly the right set of precepts, but we hope to convince you that this is a coherent set of precepts that might lead to something very interesting.

We will address these in the same categories presented above:

- A: General Design. Principles of engineering that apply in a great
  many situations. Any piece of code will exhibit at least a few of
  these.

- B: Specific Design. principles of engineering that apply in a few
  specific situations. What these lack in general applicability they
  make up in specific guidance.

- C: Attitude. Good code is the result of people approaching the act of
  engineering with the right attitude.

- D: Theory. The eternal tension between theory and practice must not
  simply be acknowledged but dealt with.

- E: Text Style. Code form matters.

- F: Real Software. Not all software matters. Any software which
  wouldn't exist on Mars isn't real.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/discuss-02.jpg">

### A: General Design

These are principles of engineering that apply in a great many
situations. Any significant piece of code will exhibit at least a few
of these.

### Simplicity

> A20: One hundred lines of simplicity is better than twenty lines of
> complexity.

> A21: Prefer mechanical simplicity to mathematical simplicity.

At Urbit's root is a strong opinion on what constitutes simplicity. We take a semi-subjective view of simplicity. Specifically, we say that the sort of simplicity that matters is the sort that makes it easy to reason about stuff. We call this "mechanical simplicity".

A competing view of simplicity says that it can be measured objectively by metrics such as the number of moving parts, the number of kinds of moving parts, the orthogonality of concepts, or cyclomatic complexity. We believe these are important metrics because they are good approximations of mechanical simplicity, but they don't tell the whole story.

In acoustics, we use decibels of sound pressure to measure objective volume of sound. However, the Fletcher-Munson curves (equal-loudness contours) describe how loud sounds are perceived to be relative to their frequency. For example, a 75 dB sound at 4kHz sounds equally loud to a 90 dB sound at 10 kHz, even though the latter is over 20 times the sound pressure.

Similarly, some sorts of complexity are much easier for humans to deal with than others. For example, humans are much better at learning languages compared to even simple mathematics. Even those who are "good at math" are objectively much better at languages, in terms of how much complexity they can absorb. Humans are also built to understand some
social dynamics and structures, even very complex and nuanced ones, without even consciously knowing the rules to them.

Some examples of things that are objectively quite simple but subjectively hard for people to learn:

- Pointers. Once you've properly learned them, it becomes hard to
  sympathize with your past self that found them difficult, but in
  practice these are a stumbling block for many people. Some think
  they're a "weed-out" concept, meaning they're just a good litmus test
  to see if you're the type of person who can learn how to program.
  Even if that's the case, it's still meaningful that they're effective
  in that.

- Recursion. Same as above. Notably, `while` loops do not evoke the
  same reactions in people.

- Monads. A little more complicated than the above, but objectively not
  that complicated. Certainly much less complicated than the C++
  standard library, but for some reason many people fail to learn monads
  after giving it an honest attempt, while that's rarely the case for
  the C++ standard library.

- Math in general. The ideas in mathematics are generally pretty clean
  and small, which is why once you've learned a concept, it seems
  obvious in retrospect. The C++ standard library doesn't look much
  more obvious in retrospect than it does on first glance.

- Any language that induces a moment where you exclaim to yourself,
  "This is true programming! Everyone should program this way, it's so
  obviously better!". People say that often about Lisp, Haskell,
  Prolog, and Smalltalk. Nobody ever said that about C, Java,
  Javascript, or Python. And yet, which ones are easier to learn?
  Which ones are used in real life?

I've emphasized learning here, but the same principles apply to using a
tool after you've learned it.

When evaluating simplicity, presumption should be on the side of "what
everybody does when they have a choice" instead of "what's
mathematically simpler". Being mathematically simple is a point in your
favor, but the burden of proof still falls on you to argue that it will
be simpler to learn and use.

Adherence to this precept is difficult because you have to decide
whether an objectively simpler construction is in fact better. This
gives a framework for deciding the question.

> A19: Dualities must be faced head-on and analyzed differently at
> different layers.

A crucial point is that the question of simplicity depends on the facts
and circumstances of the case. In deeper layers of the system,
mathematical simplicity tends to pay greater dividends. If the features
of the base layer are not orthogonal, the interactions between them will
only grow more complex as you rise in the stack. If the base layer has
many moving parts, the number of moving parts can only increase as you
rise in the stack.

This isn't the only duality that depends on the layer of the stack.
The most important layering of the stack is between "systems" and
"applications", where "applications" are those pieces of code on which
no other application depends. Many answers that are correct in system
code are incorrect in application code, and vice versa. These precepts
are an attempt to describe principles that apply at all areas of code,
but they're much more important to follow in system code.

> A22: The Law of Leaky Abstractions is a lie; abstract airtightly.

The Law of Leaky Abstractions says that all non-trivial abstractions are
leaky. This is the sort of statement that most engineers will accept
immediately and most mathematicians would dismiss out-of-hand. In
mathematics, if an abstraction leaks, it's not simply an imperfect
abstraction, it's completely wrong and should be thrown away. So they
manage to create perfect abstractions. They don't always abstract what
you wanted to abstract, but at least they're perfect.

If mathematicians can do that, there's no reason programmers shouldn't
be able to do it as well. Sure, programmers have to deal with some
performance considerations that mathematicians can elide, but that's
rarely the reason abstractions leak. They leak most often because the
creators are lazy or sloppy. If your abstraction leaks, find a way to
either plug the leak or reframe the abstraction to incorporate the
"leak" in a coherent way. It's not a leak if it's part of the spec. I
call this "turning leaks into decorative fountains".

### Conceptual clarity

> A6: Represent your data as closely as possible to the essential
> structure of the problem.

There are times when you need to represent your data in an unnatural
format for performance reasons, but this is rare. When possible, keep
the structure and location of your data in as natural of a manner as
possible. For example, if a function can produce an integer or an
error, don't produce a negative number to indicate an error — use an
explicit tagged union.

An important part of this is to fit your data types to your data
skin-tightly. If your data types permit states that you intend to be
impossible, this is suboptimal. There are degrees of this (if you need
a number between 0 and 1000, a uint32 is probably fine even though it's
suboptimal), but it's important to strive for it.

As an example, if your program can't respond to requests until it
completes an initialization process to fill in some of its state, it's
tempting to make nullable all the parts of its state that are filled in
during the initialization process, then just check whether they're
nullable when you use them. This creates a complex set of representable
states of partial initialization, and any bugs in that area will be
difficult to track down. A better option is to create a "larval" stage
of your program that performs the initialization. If requests come in
during this larval stage, queue them up until it's done. When it finishes
initialization, it metamorphizes into the full program, where all the
fields in its state are not nullable. Then run through its queue of
pending requests. This more closely resembles the essential structure
of the problem.

> A8: When mating different paradigms, build one cleanly on top of the
> other.
>
> A9: Never misuse an abstraction.

An abstraction provides a set of tools to solve a problem. Use them in
the intended way. If this is awkward, consider that this may be the
wrong abstraction to use. If the impedance mismatch is large between the
paradigm that your program uses and the paradigm that you're mating it
with, consider building an explicit layer whose sole purpose is to
convert between the paradigms (see B5).

### Correctness

> A10: Correctness is more important than performance.
>
> A12: Correctness is more important than optimality.

Sometimes you devise a solution which is fast but slightly incorrect.
This is rarely a good idea. Especially at lower layers of the system,
incorrectness expands as it bubbles up.

Other times, you devise a solution which is correct, but you could
probably make it cheaper without sacrificing correctness. Sometimes
that's worth doing, other times it's not.

Finally, in some cases you find a solution that's "optimal"
performance-wise or simplicity-wise, but it doesn't quite handle every
situation correctly. Maybe in the real world there are genuine
exceptions, and the code is much faster or simpler if you don't handle
those exceptions. In these cases, it's more important to handle every
case correctly than to "snap" to the nearest elegant formulation.

> A11: Be simple and uncompromising in defining what's correct; go crazy
> with optimizations.

Nock is a great example of this. It contains the character of the
virtual machine, but its asymptotics are bad. Add jets to fix the
asymptotics.

Another example is the ACID nature of Arvo. Arvo is a pure
function f(logs) of its event log, so formally Arvo is just a
function run against an event log. A naive implementation has
very bad asymptotics; processing each new event is O(n) in the
number of historical events. Choose the function g(state,log)
such that f(logs ++ log) = g(f(logs),log). Then, as long as you
keep the state in memory, processing each new event is constant in
the number of previous events. This still requires O(n) restart
from disk, but you can also periodically (and non-blockingly)
write a checkpoint of the state to disk, so that restart from disk
is only linear in the number of events since the last checkpoint.

This pretty much says it all. Define what's correct in as simple of
terms as possible — this will make it easier to implement and reason
about. Then don't compromise on it.

> A13: If you don't completely understand your code and the semantics of
> all the code it depends on, your code is wrong.

It's impossible to build correct code on a foundation that you're unsure
of. This is different than the problem of building something with
strong guarantees on top of something with weak guarantees — for
example, delivery guarantees on top of an unreliable transport protocol.
In that case, you are sure of the underlying system, it's just that what
you're sure of is that you can't rely on it delivering packets in order
or at all. So, you formalize what you _are_ sure of, which is that it
will eventually get your packets through if you keep sending them
forever. And that's something you can build on.

This is another reason it's important to have simple and accurate
correctness claims. When somebody else relies on your code, they
will need to know what exactly you claim to provide. If you're
accurate, then they don't have to understand your code, only your
guarantees.

> A14: Deterministic beats heuristic.

Heuristics make it hard to give precise safety guarantees, so you should
only use them when you don't guarantee much.

> A17: Referential transparency is honesty and stability.

A claim of referential transparency is a very strong guarantee, so it's
very useful for any code built on top of it. That code doesn't need to
know anything about how you produce the value because it can't
negatively affect the rest of the system, and it's free to cache
indefinitely.

> A18: Responsibilities should be clearly separated.

A program should be responsible for its own guarantees, though it must
rely on other programs to maintain their guarantees. You should avoid
guarantees that unduly couple separate programs. Any guarantee that
references state in more than one program is suspect.

### State management

> A1: Data is better than code
>
> A15: Stateless is better than stateful.
>
> A16: Explicit state is better than implicit state.

Data is better than code, but code is better than state. If you must have state, state that is data is better than state that is code.

There are many reasons for this. The most basic one is that humans are better at dealing with nouns than verbs. This is true to such an extent that we subconsciously convert statements of the form "so-and-so does such-and-such" to "so-and-so is a such-and-such-er". It's more challenging to view someone as a composition of their internal motivations such that they'll act in a particular way. It's much easier to see them as simply "friend" or "enemy" or "socialist" or "evil capitalist".

Socially, the verb -> noun simplification is often problematic because it doesn't communicate the whole picture as accurately. It's an approximation that fails to capture important nuances. And that's because any nontrivial verb can't be understood in terms of a simple noun.

However, the practical implications of this insight are different in code. Socially, people are who they are, so the best we can do is learn to understand them better. In code, though, we have a
powerful tool: convert the verbs to actual nouns. We can take advantage of our innate ability to reason about nouns and use that to make code that can more easily be reasoned about.

Another way of looking at this is that data is easy to reason about. Code is hard to reason about, because it's much larger. Function types are known as "exponential types" because the number of possible functions between sets of size `m` and `n` is `n^m`. If there's global state of size `s`, this is even worse: `n^(m*s)`. The halting problem says that it's impossible in general to even determine if a piece of code will finish without running it.

A final way of seeing this is that it's easier to reason about things that don't change. Data doesn't change, so it's a stable foundation. Pure code changes based on its arguments. Impure code changes based on its arguments and state. Impure code that uses code stored in its state
nests this whole complexity within itself.

You can't, in general, update code in any way other than replacing it wholesale. This is not true of data, where to upgrade you just need a function from the old data type to the new data type.

Sending code over the wire is problematic, because it's either very large or depends directly on what the other person has on their local ship. If you depend on what's on their ship and you're wrong, you may get the wrong result. So you explicitly require certain dependencies, at certain versions, ... this way lies dependency hell. There are ways to tame this, but if you just used data in the first place, those problems wouldn't exist.

Of course, we can't always use data, precisely because it's smaller than code. And there are occasionally times when we could use either, but the code is actually easier to reason about than the data. All else equal, data > code > state of data > state of code.

A note on laziness: lazily defined data occupies a middle ground. It's harder to reason about than strict data, but you get a lot more guarantees with it. It's probably not worth using as your basic substrate, but it makes some things easy to reason about.

### CQRS/pubsub

> A2: Everything should be CQRS.
>
> A3: (Almost) Everything should be pubsub.
>
> A4: A subscriber shouldn't affect a publisher.
>
> A5: Communication between nodes should be communication between
> independent actors.

Fred Brooks pointed out that when you add people to an organization with `n` people, the number of interpersonal connections goes up with `n^2`. This is true of binary interpersonal connections, but if you allow groups of any subset of the people, then the number of total groups goes up with `2^n`.

The same is true of entities in a program. A program must speak to many other programs about many things. Occasionally it can treat all others the same, so that the number of things it needs to say is constant in `n`. Sometimes it needs to say something different to each person, making it linear in `n`. Other times, it has a set of things it can speak about, say `m`. Pubsub lets the complexity grow with `m` instead of `n`. This lets the total communications grow with `m * n` instead of `n^2`.

It's generally good to have more structure in how you communicate with other entities. If all you have is `send-message`, then you force each entity to define their norms around when messages are to be sent, and how to associate one message with another (eg a request to a response). This also gives the underlying system no visibility into the conversations.

In CQRS+pubsub, we get a number of useful guarantees to help us structure our conversations. We know that a command will have no response other than exactly one positive or negative acknowledgment. We know that to request any data, we must have an active subscription, and
we know that a subscription may be canceled at any time. We know that a subscriber's failure to process a subscription update can't break the publisher. We know that after the initial subscription update, any subscriber to a path will get the same updates as anyone else on that
path.

The underlying system can keep track of subscriptions, and can even cancel them automatically in certain circumstances (eg if the subscriber is on another ship and has stopped responding). This is like the nouns and verbs discussion above. Subscriptions are nouns, so we can reason about them better, and so can the underlying system. "Send a message" is a verb, so we have few guarantees about it.

From Dijkstra's "Go To Statement Considered Harmful", which may as well have been written about unstructured event passing:

> My second remark is that our intellectual powers are rather geared to
> master static relations and that our powers to visualize processes
> evolving in time are relatively poorly developed. For that reason we
> should do (as wise programmers aware of our limitations) our utmost to
> shorten the conceptual gap between the static program and the dynamic
> process, to make the correspondence between the program (spread out in
> text space) and the process (spread out in time) as trivial as
> possible.

In our case, we make the programs of both the publisher and subscriber simpler by writing in terms of well-known constructs like "subscribe" and "push subscription update". You need to know much less about your counterparty.

> A7: A client's representation of data should be as close as possible
> to that of the server.

This is a natural architecture given pubsub, but it's also worth pursuing in its own right. This blurs the distinction between client and server, which makes the client more full-featured.

It reduces communication to syncing, which means offline-mode is just a special case of sync latency, and all the local features are still usable.

It also tends to reduce centralization, since you're already used to operating on your own, and you have all the data required to do so. The "server" becomes a commodity, easily moved when desired. Git is a good example of this — central git servers are common, but they're also a commodity, so you're never locked into a particular hosting provider. This is possible because the data structures are exactly the same on the client as on the server.

> A23: Some cliches are repeated because they are true; others must be
> repeated because they are not.

Computer security is an industry built on cliches. An example of the first is "your security is only as strong as your weakest link."

An example of the second is "security through obscurity is ineffective". Security through obscurity is in fact the most effective form of security — if nobody cares about you, you will never be hacked. The problem is that you must remain obscure for it to work, and that's hard to explain to people in a precise way. It's effective at protecting precisely when there is nothing worth protecting. So, it's better (for them, their companies, and their users) to tell them a lie.

However, it's important for whoever's coming up with the cliches to understand the specifics of how they're untruthful. Some of these very precepts may fall under the category of "literally untrue but more useful than the truth".

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/discuss-03.jpg">

## B: Specific Design

There are some principles that aren't obviously better than the alternatives, but if you use them consistently you avoid a lot of issues. These are all examples of this.

> B1: Always ack a dupe; never ack an ack.
>
> It's okay to ack a nack as long as you never nack a nack.

This is a simple rule, and if you follow it you get various guarantees for free. For example, sending a message will always cause up to a constant number of additional messages to be sent by direct or indirect causality (other than application-level code), so you never have to worry about accidentally causing a loop.

Additionally, acking an ack can never take you from imperfect to perfect reliability. Urbit isn't big on heuristics for stuff that's visible to userspace (A14), so don't even go down that road.

Following this rule greatly reduces the architecture space for networks. This is very helpful in finding a good architecture.

> B2: Never construct or deconstruct a duct.

A duct is akin to a first-class call stack. Don't deconstruct that for the same reasons you shouldn't read your own call stack. If you read your own call stack, and do different things based on that, it breaks a lot of assumptions we have about messages. For example, we assume that a vane will handle a task the same way regardless if the initial IO event was a keystroke or a timer. Don't break that.

Similarly, don't construct these by hand. This would be like inserting other functions into your own call stack and then returning to them. Powerful, yes, but pretty much always a bad idea because it breaks our assumptions.

> B3: Route on wire before sign, never sign before wire.

When we send a message to another vane or app, we send it on a wire. When we get a response to that message, we should care first about the wire it was sent on.

It's tempting to shortcut that and route based on the type of response. Maybe you only call to `%iris` once in your app, so you feel like you can just route directly on that. But it doesn't scale, because that dimension is orthogonal to the true dimension you care about — which request this response corresponds to. This is essentially a violation of A6.

> B4: Only go from statically typed to dynamically typed if you must.

Consider the set `U` of all possible programs. Then consider "the program you want to write" to be a set `S` of programs that differ only in aspects you don't care about. For example, maybe one takes a little more time and one takes a little more memory, and maybe you don't care about that. This set has a generating "specification" — any program that meets that specification is in the set.

A type system or testing suite can guarantee that a program is in another set `T`. Obviously, both `S` and `T` are in `U`. Hopefully the intersection of `S` and `T` is non-empty — that is the set of programs which typecheck and meet your spec.

A perfect static type system can guarantee `T` is a subset of `S` — if it typechecks, then it works. Obviously, if you let `T := {}` (ie no program typechecks), then this is vacuously true. So you want `T` to be as large as possible while still being a subset of `S` — as many programs as possible typecheck without them being incorrect. But it can't make `T == S` — there will always be some programs that do the correct thing in practice, but the type checker can't prove that.

Dually, a perfect testing suite can guarantee that `S` is a subset of `T` — no correct program fails the tests. This is vacuously true if you have no tests, for then `T = U`. So you want `T` to be as small as possible while still being a superset of `S` — you don't want to reject valid programs if you can help it. But you can't make `T == S` — there will always be some programs that are invalid but pass your typechecks (at least, if your program requires a Turing machine).

(It is possible to create a static type system that has `S` subset `T` property described above for a testing suite — see Erlang's Dialyzerand [related work](http://user.it.uu.se/~tobiasl/publications/contracts.pdf).)

A dynamic type system tells you neither of these ahead of time. Instead, you end up with type errors at runtime. Errors at runtime must be handled at runtime, when the programmer is not present. Errors at compile time are handled at compile time, when the programmer is present.

There's a hybrid, which is "static type checks at run time". In other words, you load the code and run the type checks at run time. This is better than pure dynamic checking because as long as the code compiles, you get the guarantees of a static type system. But the later in the process that the code is compiled, or the more it's changed before compiling, the less guarantee you have that the type checker will pass. If a static type checker gives an error at a time when the programmer is not present (because it's run at runtime), that's worse than a dynamic type system — at least that would give it a chance of executing correctly!

> B5: Anything with business logic speaks one paradigm; anything that
> translates paradigms has no business logic.

Translating between paradigms with significant impedance mismatch is usually convoluted code. The state machines are often hard to see, and it tends to be quite cluttered.

You want your business logic to be as clean and short as possible. This way the interesting algorithms are laid bare.

> B6: Functionally enforced semantic rules are better security primitives
> than memory access restrictions.

Memory access restrictions are blunt tools. Blunt tools are nice in simple systems, and if all you have is nails, then a hammer is perfect. But in practice you punch all sorts of holes in these restrictions, because you need more granularity and flexibility.

Better to define rules in a more powerful language. This allows you to follow A6 and A8. It also lets you use all the correctness tools, like type systems, that you've developed for the rest of your code.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/discuss-04.jpg">

### C: Attitude

Good code is the result of people approaching the act of engineering with the right attitude.

> C1: Code courageously.

If you avoid changing a section of code for fear of awakening the
demons therein, you are living in fear. If you stay in the
comfortable confines of the small section of the code you wrote or
know well, you will never write legendary code. All code was
written by humans and can be mastered by humans.

It's natural to feel fear of code; however, you must act as though
you are able to master and change any part of it. To code
courageously is to walk into any abyss, bring light, and make it
right.

The unix/internet stack is a giant ball of mud. It's so big that when you're standing on it, it looks like a bog, and it's not clear that there is a bottom to it. You know there must be, but it doesn't matter because you learned long ago that the best solution is to not dig too deep. Build a strong structure by spreading out your weight and using strong construction materials. If there's something useful deep in the mud, it's probably not worth diving in to pull it out. That's dangerous and prone to failure, and you know many people who have gotten stuck down there.

This is an appropriate reaction to the unix/internet stack. It's also self-perpetuating. The bog is filled — even _composed_ of — countless predecessors who did that same thing. If you ever find yourself on solid ground, protect that with your life. Learn how it works and how to use it well. Then build a strong structure on top of that. Don't let it decompose into a layer of mud.

Urbit is small enough that, while there's definitely some construction-related dirt and muck covering it, the solid metallic core is not very deep — not more than waist deep in most places. The feeling of always being in contact with the bottom is very different than flailing about in a bog.

This property is worth fighting for. It's the whole reason Urbit was written. New Urbit programmers are instinctively distrustful of anything below them and code defensively and fearfully. They must learn that it's all drastically simpler and more legible than they're used to. It's still hard, but you can actually make progress. To do so, you have to stand up straight, so you can get a firm footing on the ground. Keep your chin up and your shoulders back, and adopt the posture of a conqueror. When something doesn't work right, don't retreat into your shell of safety and control — fix it. The forces of chaos are always lurking, but their victory isn't inevitable. It's all on the line, so code with abandon.

> C2: No time for lazy people.

If there's clearly a right way to do something and a wrong way, do
it the right way. Coding requires incredible discipline. Always
follow conventions, and fire anyone who won't. Anything that can
be solved by discipline is not a real problem.

> "To him who knows to do good and does not do it, to him it is
> sin."

Preserving the property of solid ground requires perpetual discipline. Once lost, it's often impossible to reacquire. Don't compromise your standards.

Call people out when they're being lazy. And when someone calls you out, recognize it and fix it. Sometimes it's just a question on a code review — "why did you do it this way?" Upon reflection, you determine that you did it that way because you couldn't be bothered to do it right. Maybe that was a reasonable choice at the time you were coding so you wouldn't be distracted, but if it's been called out in a code review, now's the time to fix it, not make excuses.

> C3: When a smart person makes an obviously stupid suggestion, before
> responding take a full 60 seconds to envision how you would implement
> it and what the effects would be.

Once you've determined that someone understands a situation well, if they earnestly make a suggestion that you haven't thought of, or that you immediately dismissed as impractical, stop and consciously consider it. This is one of the best ways of countering the natural echo chamber
of your own mind.

This is also one of the best ways to build stuff correctly. Very often, you will be tempted to cut a corner, and someone will point out that it should be done correctly. You should consider why you immediately rejected it. Was it because you were afraid of the relevant piece of code? If so, you should learn more about that code to determine if it's actually a good idea. Did you reject it because you felt it would distract you from working on what you thought was more important?
Consider carefully whether this particular piece of technical debt is worth taking on. It's worth 60 seconds of thinking about how you could solve it correctly right now — often it would be quite easy to do correctly and you'd be paying interest on the incorrectness for a long time.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/discuss-05.jpg">

### D: Theory

The eternal tension between theory and practice must not simply be acknowledged, but dealt with.

> D1: Academia is a succubus.

The results from academia are useful to take advantage of, but the process of academia is a deadly sin for a project as ambitious as Urbit.

Academia usually gets the right answer, but it's slow, and it often cycles through a large number of wrong answers before it gets to the right one. It's also unconcerned with many things that a real project must consider. For example, it's generally more concerned with mathematical simplicity than mechanical simplicity, contradicting A21.

> D3: Not being qualified to solve a problem is no reason not to solve it.
>
> D4: The best way to get the right answer is to try it the wrong way.
>
> D6: Everyone must regularly alternate between theory and practice.

One common failure mode for academia is to get bogged down in optimally solving a particular part of a problem such that it fails to solve the whole problem.

There's a sense of "if I don't know how to do it, I must discover the correct answer before I can do it". This will get you the right answer if it terminates, which is the sort of algorithm mathematicians like. Engineers like algorithms that do in fact terminate.

The fastest way to build a good system is to build it as well as you know how, then iterate on it. You have to be disciplined about actually iterating over time as you learn about the problem, but often the way to learn more about the problem is to move beyond it and work on adjacent
problems. Hindsight is 20/20, so get the problem in your rearview mirror as fast as possible. Then while you're driving somewhere else, you'll see what you should have done. Then turn around and go do it. This only works if you or someone else is willing to go back and fix it
(C2).

> D2: Never fear math.

You can spend years working on a problem that you're able to solve in a few days with the right theoretical grounding. There's no excuse for being ignorant of theory; or rather, being ignorant of theory is an excuse to learn it.

Many engineers fear theory the same way they fear a complex piece of code deep in the stack (C1). But they shouldn't, because theory is rarely muddy. The same characteristics that make theory impractical also make it clean and learnable. It's also pretty permanent, so a one-time investment will pay dividends for a long time.

Of course, if you look deep down, you may find laziness is what's keeping you from learning theory. If that's the case, you need to decide how much you want to design good software. Because there's no room for laziness (C2).

> D5: Practice tells you that things are good or bad; theory tells you why.

You can never tell whether a system is good or bad without using it (see discussion on A21). Theory has great explanatory power, but only limited exploratory power. The best it can do is point out areas of the idea maze you haven't explored and suggest correlations between
objective properties and your subjective judgment of the quality of the system.

However, that explanatory power is indeed powerful, and the exploratory suggestions are often able to break you out of a rut (attractor basin). Respect the tension.

<img class="ba" src="https://media.urbit.org/site/posts/essays/discuss-06.jpg">

<br>

### E: Text Style

Code form matters. Code that is hard to read is hard to maintain. Code that is inconsistently formatted is hard to read, but consistency isn't the end of the story. Some formats are simply hard to read.

Formatting also isn't the end of the story. Naming and commenting conventions are even more important to clarity. The human brain is quite good at taking stuff that's in an unexpected form and interpreting it.

This is why the diversity of accents and handwriting rarely causes issues, while the diversity of languages requires specialized translators. For someone used to typing on a QWERTY keyboard, it takes some time to get used to typing on a Dvorak keyboard because you have to rewrite your muscle memory. But it's nothing like how hard it is to learn another language. Russian script is roughly as different from English script as Russian grammar is from English's, but it's drastically easier to learn to read, handwrite, and type Cyrillic than it is to learn Russian grammar.

So, uniformity of style is good, but it's not sufficient. The style must be readily readable and writable.

### Formatting

> E1: No code should extend beyond 80 characters, most within 55.

Very wide code is unreadable. Even before you get to the readability threshold, it's useful to keep your code relatively narrow. Too narrow of code, on the other hand, results in too tall of code. What these two have in common is that they make it hard to navigate the code.

Code navigability is the ability to find the part of the code you're looking for. This has several inputs:

- how far away is what you're looking for?
- how many distinct places in the code can you have on screen?
- how much code can you have on screen?
- how fast can you recognize that you're in the correct place?

Some of these are strongly affected by workflows. We can't force a developer to have an effective workflow, but we can support those who do. If your workflow is deficient in one of these areas, consider improving it.

One of the primary inputs to code navigability is how much of it you can have on your screen. Code that is too wide limits the number of columns of code. Some people keep only one column on their screen, so they don't see a problem with long lines of code. The most efficient navigation is to already be there (i.e. to only have to move your eyes). If you only have one column of code open, you can only be in one place, which eliminates the best form of navigation.

Dually, code that is too narrow limits the number of lines you can have on a screen (this isn't a separate precept simply because we've never had to tell someone to write _wider_ code). This suggests there is some happy medium. This is dependent on the language, but in Hoon we've
found that up to 55 columns is a pretty good number for most code. However, there are plenty of legitimate reasons to go a bit longer than that. 70 columns is rare, but not surprising. There is essentially never a reason to extend beyond 80 columns.

> E2: Tabs aren't real.

Code is a text file, and text files are WYSIWYG. The reader should view the file exactly the same as the author wrote it. This is a low-overhead way of avoiding editor-dependence in code, which is as bad as browser-dependence in javascript. Sure, tabs aren't as big a deal as the hell that front-end devs have to deal with, but there's no reason to give an inch to the forces of platform-dependence.

Some argue in favor of "customization". Customization is inconsistency.
There can be good reason for inconsistency in some areas, but not in
code formatting, which is such an intensely communicative action.

> E3: A text file is a series of lines, each ending with a newline

      character.

There are several competing definitions of text files, but most commonly-used software uses this one. It's simple and consistent.

Its disadvantage relative to "a text files is a series of characters, possibly including newlines" is that there are some arrangements of characters that are not valid text files (ie non-empty and not ending in a newline). However, some series of characters were already not valid
in a text file — eg those including control characters or other nonrepresentable characters.

In return, we get the advantage that we can treat a text file as having a more complex and useful structure — a list of lists of characters, rather than simply a list of characters.

These are theoretical concerns — the real answer is that it's the way it's always been done, and deviating from that without a good reason is asking for trouble.

### Names and comments

> E4: One block comment is better than interleaved comments on every line.

Interleaved comments are easy to write because you can just paraphrase the code. This is also why they're generally useless. In the micro, code should always be immediately understandable. In the macro, it's often helpful to give context as to the purpose or constraints of the function. Sometimes it's good to even give the algorithm line-by-line in pseudocode, but mixing the pseudocode with the real code obfuscates both.

> E5: Don't name anything you don't have to.

> E6: If it's the same thing, give it the same name.

It is often said that there are two hard things in computer science: cache invalidation and naming things. This is a good aphorism. As often, someone will respond with "There are two hard things in CS: cache invalidation, naming things, and off-by-one errors". This is a weak
joke because off-by-one errors are not hard at all. They're mostly a matter of discipline, and there's a couple of conventions that help. If you're looping on a zero-indexed variable, use `i < num_loops`. If you're looping on a one-indexed variable, use `i <= num_loops`.

However, cache invalidation and naming things are genuinely hard because they must be solved ad hoc. There is no one-size-fits-all cache invalidation strategy, and possibly there never will be. Similar for naming. So you must actually comprehend and work within each individual
context.

You shouldn't solve hard problems if you don't need to, so don't name anything you don't have to. Giving unique names to things is tiring, and it reduces readability. A consistent pattern for naming things makes it easy to keep track of what is what and reduces the number of
decisions you must make.

Examples:

- If the only difference between three things is that they're not the
  same, consider naming them `thing-1`, `thing-2`, and `thing-3`.

- Use agglutinative morphology. If `a` is to `b` as `c` is to `d`, then
  find an affix which describes this distinction (say `-suf`) and rename
  them to `a`, `a-suf`, `c`, and `c-suf`.

- A corollary of the above is that if one variable represents the "same"
  thing with a different type, that type should be the morpheme added.
  For example, if `a-set` is a set, then `~(tap in a)` should be called
  `a-list`.

- Don't abbreviate (E8) — everyone abbreviates differently, and bits are
  cheap. If it takes you a long time to type the name, consider (1)
  finding a more succinct name (good any time you can do it), (2)
  becoming a faster typer, or (3) learning autocomplete tools, such as
  snippets.

- Especially don't abbreviate or otherwise change the word when adding
  affixes. Inflectional morphology is bad in such an ad hoc context as
  code.

> E7: Humans are good at memorizing.

We're really good at memorizing sets of things, like runes. We're also good at inferring structure from patterns. We're bad at memorizing structure in apparently unrelated names, though, and once we see a pattern, we assume it's densely populated.

So don't be afraid to use new names for new concepts. If concepts are siblings, they needn't necessarily have a direct connection in their name, but if they're hierarchical, then something should suggest that. This can be syntactic or semantic.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/discuss-07.jpg">

### F: Real Software

Not all software matters. Or at least, not all software comes within
the scope of "Urbit". Urbit cares about "Martian software".

> F9: Timeless software is good software.

There's different sorts of software. A lot of software is inherently ephemeral, and can really only be run in one place. A SAAS company runs bespoke software on a particular set of servers, and that software has no future. It will never be run on anyone else's servers, and it will eventually stop being run even there. It won't even have any direct descendents. It's a genetic dead end.

However, not all software is this way. Urbit is interested in software that can live forever. This is what we call "real" software.

This is the most important passage in all that has ever been written
about Urbit:

> What is Martian code actually like? There are two possibilities.
>
> One: since Earth code is fifty years old, and Martian code is fifty
> million years old, Martian code has been evolving into a big ball of mud
> for a million times longer than Earth software. (And two million times
> longer than Windows.)
>
> This hypothesis strikes me as possible, but implausible. Since the _big
> ball of mud_ expands indefinitely, Martian code would therefore be so
> large and horrible that, despite its underground installed base, the
> server room bulged into space like a termite mound, intercepting
> low-flying asteroids and stinking up the solar system all the way to
> Pluto. Our latest space telescopes would surely have detected this
> abominable structure - if not, in fact, collided with it.
>
> Two: therefore, at some point in Martian history, some abject fsck of a
> Martian code-monkey must have said: _fsck_ this entire fscking ball of
> mud. For _lo_, its defects cannot be summarized; for they exceed the
> global supply of bullet points; for numerous as the fishes in the sea,
> like the fishes in the sea they fsck, making more little fscking fishes.
> For lo, it is _fscked_, and a big ball of mud. And there is only one thing
> to do with it: _obliterate_ the trunk, _fire_ the developers, and hire a
> whole new fscking _army_ of Martian code-monkeys to rewrite the _entire
> fscking thing_.
>
> This is such an obvious and essential response to the _big ball of mud_
> pattern that, despite the fact that we know nothing about Mars, we can
> deduce that it must have happened on Mars. Probably several times.
> Probably several hundred. For each of these attempts but the last, of
> course, the result was either (a) abject failure, (b) another _big ball
> of mud_, or (c) both.
>
> But the last, by definition, succeeded. This is the crucial inference we
> can draw about Mars: since the Martians had 50 million years to try, in
> the end they must have succeeded. The result: Martian code, as we know
> it today. Not enormous and horrible — _tiny and diamond-perfect_.
> Moreover, because it is tiny and diamond-perfect, it is perfectly stable
> and never changes or decays. It neither is a _big ball of mud_, nor tends
> to become one. It has achieved its final, permanent and excellent state.

We don't know that Urbit will achieve this final form, but Urbit is an attempt to make progress in that direction. Any software that isn't a candidate for "tiny and diamond-perfect" is either a prototype or scaffolding.

Here's some characteristics of real software:

> F1: If it's not deterministic, it isn't real.

If you do the same thing twice, your computer should react the same way. This is comforting. This is also what makes it easy to reason about and use effectively. If you're not sure what your computer will do, you'll be afraid of it and act defensively toward it. This inevitably leads to a big ball of mud.

Diamonds are extremely hard, and they wear very slowly. A diamond surface will support you every time; a mud surface will shift out from under you exactly when you put weight on it.

> F2: If it's centralized, it isn't real.

Code that depends on a central authority or has a single point of failure is fundamentally brittle. No authority lasts forever, no company lasts forever, no server lasts forever. Under certain
circumstances, bones and the like can be preserved for a long time — but not alive. The remains of buildings sometimes last for thousands of years, but the cities are gone.

The only things that last forever in their useful form are big hunks of rock (like the pyramids at Giza) and ideas, through writing and transcription. So, if you depend on the sun existing, this is
acceptable. If you depend on a piece of source code to be kept forever, copied and re-copied, you're fine. If you depend on a 20-year-old company existing and being easily accessible, this is brittle.

Another way to look at this is to say that anything that wouldn't work on a spaceship is architecturally flawed. Maybe it requires many sequential round-trips to a central server because it doesn't have all the relevant information. See discussion of A7.

> F3: If it's owned by someone else, it isn't yours.
>
> F4: If it's managed by someone else and you can't change who that is, it
> isn't yours.
>
> F5: If it's not yours, it isn't permanent.
>
> F6: If it's not permanent, it isn't real.

Nobody is as aligned with your values as you are. If you don't control the software, then you can't guarantee you'll always have access to it. Whoever does control the software may destroy it, move away, or simply revoke your access to it.

Control has some nuance. If it's physically controlled by a company and you can't get your data and the software that makes it useful, you definitely don't have control. If you have physical control of it, you do have control. But if you're hosting the data and software on a commodity cloud server, you still mostly have control of it. Your privacy has been reduced, sure. However, as long as you keep regular backups of the data and software, if the hosting provider disappears you just need to find another host, or host it yourself. Any particular host is likely to disappear, but the situation where _every_ host disappears and you can't even host it yourself is much less likely. Brands are mortal, commodities are not.

Some branded hosts allow you to download a zip file of your data. This gives you a little more control over your data, but it's much closer to "no control" than "total control". This is because your online world is data plus code, and without the code that makes it useful, data is only good for scrapbooking. The scrapbook will remind you of the good old days, but you won't be able to live them again.

> F16: Sovereignty necessitates understanding.

Not everyone cares to understand the software they're using. But if you want to compute sovereignly, you must understand what your computer is doing. If it regularly surprises you, you're not in control of it. You must tame it. The current paradigm is a wild monster which cannot be tamed by mere humans — only megacorporations even attempt to do so, and it's always temporary. So, your software needs to be simple enough that it can be understood.

> F10: System modules should be designed to be frozen permanently;
> conversely, Urbit consists of that system software which admits of a
> Kelvin version.

"Kelvin versioning" is a versioning scheme where your current version is a natural number, and new versions count down. Once you hit version 0, no more changes should be necessary.

This is the opposite of the usual way of developing software, where there is no defined endpoint. This paradigm suggests that you're building something specific. Most current software builds higher and higher in a vain attempt to reach the heavens, until all available effort is expended just to keep this tower from falling over. Kelvin versioned software cuts away until you reach a strong bedrock. Not every piece of software should have a Kelvin version, but infrastructure should.

> F11: The two procedures for achieving timelessness are distillation and
> generalization.

When building a timeless system, you start by building whatever you need to make it work. Then as you continue on, you may find some of the features are no longer necessary. Often, they're only needed when you're using them for user-facing work, but you've already moved on to building user-facing stuff somewhere else. You don't need the niceties anymore, so you should remove them.

Other times, you find that you want something similar to a feature you already have, but not exactly the same. When this happens often enough with the same feature, you may discover what is the essential nature of the feature and what are simply ornaments of the original use of the feature. Then, you can generalize the feature so that each of the desired use cases is well served.

> F13: That which cannot be Kelvin-versioned should update fluidly and
> automatically.

Not everything should be Kelvin versioned. Much user-facing code is in a continual process of discovery, and it must react to changing userbases and their needs. These should update without user interaction. You should be able to turn off your ship for years at a time, then turn it back on. After a few minutes or hours of catching up, you should be ready to go.

This means you need upgrade paths to be permanent, and they must not lose information. Anything that stops being able to upgrade is not permanent, since it will succumb to bit rot.

> F14: Humans are interactive and temporal; technology is permanent and
> exhaustive.

This is why the software humans touch directly should not be Kelvin
versioned but the infrastructure that makes it work should be.

> F7: The way it is isn't always the way it ought to be.

You should presume that there's a good reason for why things are done a certain way because what works best tends to win in a market in the long term, but markets are rarely efficient. Markets become more efficient over time, if they become more liquid, and as they become larger. Software is young, the cost of switching technologies is often large, and the space of software paradigms yet to be explored dwarfs those we've exhausted. So don't be surprised if you find ways to improve the situation drastically.

> F8: The way it ought to be isn't always the way it is.

On the other hand, sometimes the elegant solution just isn't right. The ultimate test of the quality of software is whether it's useful to humans. Humans don't fit nice equations, so the timeless truths of mathematics are often mismatched with human convenience. Never sacrifice real utility for the sake of making the code more elegant.

> F12: Standardization is better than perfection.

Coordination problems are some of the most difficult. When given a choice between compatibility and improvement, carefully consider whether the problem solved by the improvement is weightier than the problem caused by the incompatibility.

> F15: Communities are autonomous.

This is both a positive statement and a normative one. Communities are in fact a thing separate from their platform, but sometimes changes in the platform can kill them. That's bad. It's slightly different from freedom of association, since that's a freedom that applies to individuals, not the communities themselves.

Communities are the basic building blocks of society. We are each a member of some number of communities, and most power is held by these communities. Some communities coincide with family ties, some with common goals, beliefs, or interests. Some may be freely joined by just showing up — others are nearly impossible to join without having been born into them.

Throughout civilization society has had many forms. Governments have ranged from police states to feudal societies to democracies to informal tribes of people. In each of these, the fundamental unit is the community. Humans don't live on their own, and they don't live in one
universal society. They are a part of some communities and not of others.

Technology shouldn't force us into a single global community. Discoverability isn't an unmitigated good. Most communities should be closed off from each other — that's what makes them a community. This allows them to develop their own ideas and norms. These bleed into
other communities and may spread if they provide some benefit.

Many technologies today combine us into a single community, or at least a single set of norms. If many communities are hosted by a single entity, there will be pressure from some of those communities toward the entity to pressure other communities to follow certain of their norms.
This crosstalk isn't all bad, but there must be an equilibrium. All too often the lines between the communities are so permeable as to be inconsequential. In this case, the communities will converge in a single large community, at the cost of the memetic diversity of the original communities.

Technology should mirror human interaction, and humans interact in communities.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Precepts]]></title>
            <link>https://urbit.org/blog/precepts</link>
            <guid>https://urbit.org/blog/precepts</guid>
            <pubDate>Tue, 17 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/pre-01.jpg">

Urbit is a principled approach to system design and programming, but it's often not obvious what those principles are. We have many specific terms for the different parts of the project: Arvo is the OS, Hoon is the language, Tlon is the company, Azimuth is the identity system, Ames is the network. But the word most associated with the project is "Urbit", and it's not clear what technically it refers to. It's only a small stretch to say that "Urbit" _is_ this set of principles, and that if anybody follows these principles strictly they will create a system that is isomorphic to the Urbit.

Some of these are commonly held among many software projects, and some are not. Some are only debatably better than the alternatives, but Urbit exclusively chooses them.

We’ll start with a brief description of many principles, then we’ll go into a long-form justification.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/pre-02.jpg">

### A: General Design

1. Data is better than code.

   Store data in your state, send data over the wire, dispatch based
   on data.

2. Everything should be CQRS.

3. (Almost) Everything should be pubsub.

4. A subscriber shouldn't affect a publisher.

5. Communication between nodes should be communication between
   independent actors.

   Each message should do one complete thing, and there shouldn't
   need to be a sequence of coupled messages.

6. Represent your data as closely as possible to the essential structure
   of the problem.

7. A client's representation of data should be as close as possible to
   that of the server.

   This blurs the distinction between client and server. It allows
   offline-mode, reduces communication to syncing, and decentralizes.

8. When mating different paradigms, build one cleanly on top of the
   other.

   Never try to make them work on some of the same primitives. Never
   abuse one to make the other work. For example, ducts in
   themselves are very general - if you want to do pubsub, that can
   easily be built on top of ducts, but don't pretend that pubsub is
   a _part_ of the duct system.

9. Never misuse an abstraction.

   An abstraction provides a certain set of tools; use them and only
   them.

10. Correctness is more important than performance.

11. Be simple and uncompromising in defining what's correct; go crazy
    with optimizations.

    Nock is a great example of this. It contains the character of the
    virtual machine, but its asymptotics are bad. Add jets to fix the
    asymptotics.

    Another example is the ACID nature of Arvo. Arvo is a pure
    function f(logs) of its event log, so formally Arvo is just a
    function run against an event log. A naive implementation has
    very bad asymptotics; processing each new event is O(n) in the
    number of historical events. Choose the function g(state,log)
    such that f(logs ++ log) = g(f(logs),log). Then, as long as you
    keep the state in memory, processing each new event is constant in
    the number of previous events. This still requires O(n) restart
    from disk, but you can also periodically (and non-blockingly)
    write a checkpoint of the state to disk, so that restart from disk
    is only linear in the number of events since the last checkpoint.

12. Correctness is more important than optimality.

13. If you don't completely understand your code and the semantics of
    all the code it depends on, your code is wrong.

14. Deterministic beats heuristic.

    Heuristics are evil and should only be used where determinism is
    infeasible, such as in cache reclamation.

15. Stateless is better than stateful.

16. Explicit state is better than implicit state.

17. Referential transparency is honesty and stability.

    Lack of referential transparency and other forms of
    disingenuousness are some of the world's big problems. Only
    deviate from referential transparency if absolutely necessary.

18. Responsibilities should be clearly separated.

    This applies from kernel modules through network citizens.

19. Dualities must be faced head-on and analyzed differently at
    different layers.

    Statically typed vs. dynamically typed, imperative vs. functional,
    code vs. data, and effectful vs. pure can all be a matter of
    perspective, and all relevant perspectives must have coherent
    answers.

20. One hundred lines of simplicity is better than twenty lines of
    complexity.

    It's not enough for an abstraction to reduce code duplication; it
    must actually make the code simpler.

21. Prefer mechanical simplicity to mathematical simplicity.

    Often mechanical simplicity and mathematical simplicity go
    together.

22. The Law of Leaky Abstractions is a lie; abstract airtightly.

    If your abstractions are leaking, it's not due to some law of the
    universe; you just suck at abstracting. Usually, you didn't
    specify the abstraction narrowly enough.

23. Some cliches are repeated because they are true; others must be
    repeated because they are not.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/pre-03.jpg">

### B: Specific Design

1. Always ack a dupe; never ack an ack.

   It's okay to ack a nack as long as you never nack a nack.

2. Never construct or deconstruct a duct.

3. Route on wire before sign, never sign before wire.

4. Only go from statically typed to dynamically typed if you must.

   Once you go into a dynamically typed world, it's hard to go back.
   Statically typed is better than dynamically typed, so if something
   can be made static, it should be.

   Each timeless data structure is a brick in the foundation of
   digital civilization.

5. Anything with business logic speaks one paradigm; anything that
   translates paradigms has no business logic.

6. Functionally enforced semantic rules are better security primitives
   than memory access restrictions.

   A compiler can use type safety as an effective tool to enforce
   some classes of security guarantees.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/pre-04.jpg">

### C: Attitude

1. Code courageously.

   If you avoid changing a section of code for fear of awakening the
   demons therein, you are living in fear. If you stay in the
   comfortable confines of the small section of the code you wrote or
   know well, you will never write legendary code. All code was
   written by humans and can be mastered by humans.

   It's natural to feel fear of code; however, you must act as though
   you are able to master and change any part of it. To code
   courageously is to walk into any abyss, bring light, and make it
   right.

2. No time for lazy people.

   If there's clearly a right way to do something and a wrong way, do
   it the right way. Coding requires incredible discipline. Always
   follow conventions, and fire anyone who won't. Anything that can
   be solved by discipline is not a real problem.

   > "To him who knows to do good and does not do it, to him it is
   > sin."

3. When a smart person makes an obviously stupid suggestion, before
   responding take a full 60 seconds to envision how you would implement
   it and what the effects would be.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/pre-05.jpg">

### D: Theory

1. Academia is a succubus.

   Academia has a really high ratio of smart people to useful
   products. Academia has many genuinely smart and interesting
   ideas, but always remember that pursuing them whole-heartedly will
   never result in a useful product.

2. Never fear math.

   Academia is inefficient, but it's also correct. Those people
   wasted a lot of time finding the right answer, but now that
   they've done it, you must exploit it. If you don't know the
   theory, learn it. No excuse for being "bad at math". Most who
   are "bad at math" are simply lazy or fearful. Be strong and of
   good courage. If you're truly so bad at math that you cannot
   learn it, you should not design systems.

3. Not being qualified to solve a problem is no reason not to solve it.

   If you don't know how to do it, do it anyway. "We are too young
   to realize that certain things are impossible. So, we will do
   them anyway."

4. The best way to get the right answer is to try it the wrong way.

   You cannot design a good system without spending most of your time
   in contact with the problem. The bad parts about systems are
   rarely obvious in theory, but often in practice.

5. Practice tells you that things are good or bad; theory tells you why.

   Never use theory to design a good system from scratch; only
   practice can tell whether the system is good.

6. Everyone must regularly alternate between theory and practice.

   There is an eternal wheel of system design. Given a system, use
   practice to discover what is bad, missing, or unnecessary. Then,
   use theory to fix the bad, add the missing, and remove the
   unnecessary. Repeat.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/pre-06.jpg">

### E: Text Style

1. No code should extend beyond 80 characters, most within 55.

2. Tabs aren't real.

3. A text file is a series of lines, each ending with a newline
   character.

   Corollary: all non-empty text files end with a newline (often
   hidden by editors). An empty text file does not end with a
   newline.

4. One block comment is better than interleaved comments on every line.

5. Don't name anything you don't have to.

   This includes conventional names for variables of particular
   types. For example, the conventional name for a variable of type
   `path` is `pax`. You should have a good reason for using any
   other name for a `path`.

   A more recent convention that follows the same principle is to
   give the variable the same name as its type.

6. If it's the same thing, give it the same name.

7. Humans are good at memorizing.

8. Abbreviations aren't worth it.

<br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/pre-07.jpg">

### F: Real Software

1. If it's not deterministic, it isn't real.

2. If it's centralized, it isn't real.

3. If it's owned by someone else, it isn't yours.

4. If it's managed by someone else and you can't change who that is, it
   isn't yours.

5. If it's not yours, it isn't permanent.

6. If it's not permanent, it isn't real.

7. The way it is isn't always the way it ought to be.

   If you can make it the way it ought to be, do so.

8. The way it ought to be isn't always the way it is.

   Some things can't be made more elegant.

   For every ailment under the sun
   There is a remedy, or there is none;
   If there be one, try to find it;
   If there be none, never mind it.

9. Timeless software is good software.

10. System modules should be designed to be frozen permanently;
    conversely, Urbit consists of that system software which admits of a
    Kelvin version.

11. The two procedures for achieving timelessness are distillation and
    generalization.

    Every temporary or contingent feature in a system module should
    eventually either be removed (distillation) or relaxed into
    timelessness (generalization). For an example of the result of
    both procedures, consider the abstraction of the core in Nock and
    Hoon.

12. Standardization is better than perfection.

    Kelvin versioning stops when we run out of versions, not when
    every defect has been rectified.

13. That which cannot be Kelvin-versioned should update fluidly and
    automatically.

    All incompatible upgrades should provide permanent and automatic
    upgrade paths. This is principled permanent backward
    compatibility.

14. Humans are interactive and temporal; technology is permanent and
    exhaustive.

15. Communities are autonomous.

16. Sovereignty necessitates understanding.

    If you don't understand a system you're using, you don't control
    it. If nobody understands the system, the system is in control.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit for Normies]]></title>
            <link>https://urbit.org/blog/urbit-for-normies</link>
            <guid>https://urbit.org/blog/urbit-for-normies</guid>
            <pubDate>Tue, 11 Feb 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Urbit is a challenging project to fully describe because, rather than a single product, it’s an entire system. Often when I talk about one of the individual elements of the system, someone will tell me that another company is already building that — and they’re usually right. What sets Urbit apart is that we’re building all these elements at once to work together seamlessly.

For that reason, this overview is long. I wanted to explain, at a very high level, as much of the system as possible, to share an image of the entire forest rather than spending too much time on any of the trees.

My own path to Urbit was not predictable, so it turns out I’m a useful ambassador to describe what the heck we’re doing to my fellow normies.

I refer to myself as a normie because I’m a lawyer by training, not the typical code-savvy early Urbit adopter. I ran a law firm and, after retiring, founded a podcast and magazine about relationship dynamics. During that time I came to believe that humanity was in desperate need of better ways to relate. I didn’t know how, but I knew that my podcast about romance wasn’t going to move the needle. I began to look for a bigger project. I wanted something I truly could invest myself in; something that could have a real impact on this problem.

That’s when a friend introduced me to Urbit. Saying it was the most credible project he’d seen in years, he described it as “an open-source decentralized internet project,” and that it “would give control of computing back to regular people.” That sparked my interest, but I didn’t totally understand it. After looking over the website and watching a couple of obscure descriptive videos on YouTube my response was threefold:

1. **This is huge** — if it actually works, it’s the future.
2. **This is real** — It’s got working code, dozens of engineers, and a very unorthodox solution.
3. **I don’t truly understand this** — I can’t read the code, and I can barely comprehend the paradigm shift.

So of course I asked for an intro.

Fast forward: I ended up becoming COO at Tlon, the primary developer of Urbit. Urbit is exactly the sort of project I was looking for — one that represents an important promise for humanity. But, boy, did I have to fake my way through the technical elements of my new job those first few months.

What I eventually came to realize is that if Urbit is only accessible to programmers, it’s dead on arrival. In order to be useful, Urbit has to be understandable by the non-technical user. Like me. And maybe like you.

I understand as well as anyone how complicated Urbit can appear. But, fundamentally, Urbit is quite simple and it promises a critical upgrade to human interaction. That might sound like hyperbole but it’s the reason I work here. This is my attempt to explain to fellow normies the scope and scale of this world-changing project called Urbit.

## What is Urbit?

Let’s take this one step at a time and start with the most basic definition:

Urbit is a peer-to-peer internet being built from scratch to be more private, secure, and durable than the current internet.

At its most basic level, an Urbit is:

1. A super-private computer, combined with
2. an ID, which is
3. connected peer-to-peer with other Urbit computers.

Taking that a half-step deeper, each Urbit user gets a permanent identity, which allows them to access their personal computer in the cloud, and then talk to directly with other Urbit computers (i.e. other people) on the network, all without using an intermediary.

When I say “computer” I’m not talking about a physical device, but rather the software that computes. Urbit is a virtual computer, not a hardware device. Today that means you can access your Urbit computer from anywhere, on just about any device with a web browser. Eventually you won’t even need the web browser.

By “intermediary” I’m talking about all those centralized servers that we use every day to do our computing. Servers owned by Google, Facebook, YouTube, Instagram, Twitter, Slack, Amazon, Nest, Apple, and so on. All of these companies and products keep close tabs on our activity and use that information to sell us things and influence our opinions. Everything we do online is watched and recorded.

Urbit will fundamentally change that — more about the privacy implications later.

<img class="ba" src="https://media.urbit.org/site/posts/essays/normies-1.png">

## What it looks like

Another way of explaining Urbit is to describe how it feels and looks. Visually, Urbit belongs to a genre often called “calm computing.” Urbit is designed to be simple, basic, and non-addictive. You won’t find any flashy-blinky lights here; no zany colors; no wacky branding. Just calm, functional, purpose-built tools for people to connect and work together. (One of my favorite examples of calm computing is the [light phone](https://www.thelightphone.com/).)

Today Urbit’s interface looks like a tab in your web browser that has some limited functionality (chat, a weather app, a notebook, link sharing). Soon, you won’t even need the web browser — you’ll be able to access or run Urbit directly in its own window. Inside will be a super clean interface with all the functionality you might want from your computer, in one place and with one login (think document creation, email, social media access, accounting) — but it will run on your virtual Urbit computer, so it will be safe from corporate prying and data leaks, available on any device, and all inside one simple interface.

## What it’s for

Fundamentally, Urbit is neutral open-source infrastructure, so it can be for many things. From our highest level perspective Urbit is computing for real communities and normal people, not for corporations. To make that real, Urbit focuses on delivering a computing experience that is secure, private, durable, and calm.

For me, Urbit’s core purpose is to give us all back our privacy and our autonomy. It’s time for humanity to control its tools rather than the other way around.

## Key elements

One potential barrier to understanding Urbit is that we’re building out multiple layers of this new internet simultaneously, and each has its own explanations and value propositions. Remember, what sets Urbit apart is that we’re building of all these elements at once to work together as a system.

I’ll try to explain the most important of these without straying too deep into the technical weeds.

1. **A peer-to-peer network**

   Peer-to-peer networking is a really big deal. On the current internet, essentially all of our communications and activities go through centralized servers owned by corporations (Facebook, Google, etc.) — and those corporations can’t help but use all that information to make money. They’re capitalists, after all, and so we get constant privacy violations and interfaces built for maximum dopamine addiction.

   In an Urbit world, all those communications go directly between users (i.e. peer-to-peer) with nobody in the middle. That means there’s no data capture by any megacorp, less intrusion into your life online, and communications go back to the semi-private one-to-one or small group format that is most comfortable for humans. It’s more like real life.

2. **Your own server**

   Servers are complicated. Too complicated. Have you ever tried to use a command line? Exactly. It’s a terrible way to work, and that’s just a hint at how complex servers are to operate. To hide that complexity, we let corporations run our servers for us — they can afford teams of engineers. The problem is that today most of our computing is handled by these corporate servers — and that means we’re giving up control because of complexity.

   As an example, every time you use Siri, your message is sent to Apple’s servers, where it is processed, and the response is sent back to you (which is admittedly amazing). Unfortunately that’s why it never works if you’re offline, and it’s also why Apple knows what you’re saying to Siri. And this applies to all the apps we use: The actual computing happens on corporate servers. The problem is that we consumers aren’t in control and, again, the corporate entities watch, record, and gate-keep all of our activity.

   Fundamentally, Urbit is a super simple server. That means Urbit can run those computations and hold all that data for you, eliminating the need for a corporate intermediary.

3. **Permanent, personal ownership of your digital identity and all your data**

   Urbit IDs are permanently ownable — and that ownership is backed by cryptography, not some corporate database. Once you take possession of your Urbit ID, no central authority can ever take it away from you. Sure, if you start spamming people on the network, word could get around and you might get blocked by other users, but none of them can prevent you from using your ID or accessing your Urbit computer. Compare that to the current internet where Facebook owns your Facebook profile, Google owns your Gmail account, Twitter owns your Twitter handle, etc. At any time and for any reason, those services can arbitrarily shut off your access, and you have little to no recourse — all that data, all those followers, and all that reputation is wiped out instantly. Your Urbit, on the other hand — both the identity, and all the data inside your Urbit computer — is yours permanently, so long as you know your secret key.

   A secure decentralized identity system like the one we’ve built leads to some very interesting use cases that are otherwise insurmountable. For example: decentralized Uber, decentralized delivery services, and a solid solution to the problem of fake reviews. To build any of these services, the problem of permanent identity needs to be solved first, and we’ve done that as part of our overall system. I’ll spend more time on use cases below.

   It’s worth noting that this problem has never been solved before. All of our communication channels on the internet today rely on someone else to authenticate our identity. Urbit is — to my knowledge — the first practical application of a decentralized ID system that actually works.

4. **An incentive for good behavior**

   On the Urbit network, identities are finite, and they accrue reputation. Compare that to the current internet where identity is infinite (anyone can create as many email addresses or social media profiles as they want, essentially for free) and so spam, scams, and DoS attacks (“denial-of-service”: when many disposable identities ‘attack’ a server at the same time) are rampant. On the Urbit network, there are just over 4 billion total IDs (2<sup>32</sup> to be exact). Scarcity creates value. That scarcity, combined with reputation accrual, means there's an incentive for good behavior.

   You might think 4 billion IDs sounds like too few given how many humans we have on the planet. I won’t go into the technical details here, but if we ever get to the point where that’s a problem (which would be a great problem to have), we’ve outlined several solutions that allow everyone alive to get on the network. We don’t intend to lock anyone out.

5. **Tools anyone can learn and use**

   Urbit is a system that anyone with patience can understand completely from top to bottom, from the integers of byte code to the complete OS and everything in between. Urbit in its entirety is just over 50,000 lines of code. That is tiny. Compare that to Linux (the open-source OS that most modern computing is built upon), which is tens of millions of lines of code, and you start to see how important this is for efficiency. Apple’s and Windows’ codebases are similarly massive. In our current computing system, nobody can understand the entire thing completely, and that means there are innumerable security holes. With Urbit, while it may demand something of you, any reasonably intelligent developer can grasp the whole thing. We’ve worked very hard to keep our system simple at each level. That makes it more efficient, more durable, and much more secure.

6. **Lessons from the last half century**

   Bear with me — this is where some jargon kicks in. In many ways, Urbit is an attempt to apply lessons learned from the failures of 20th century computer development. From an engineer’s perspective, Urbit solves a series of problems that we end users rarely notice, but which cause extraordinary amounts of complexity and waste. The list of applied lessons is long, but rather than bullet them all, I’ll explain the one that surprised me the most.

   Urbit is deterministic. That is, a given sequence of inputs always produces the same output. When I first heard that, I thought, “Wait, isn’t that what all operating systems do? Give you the same result every time?” Weirdly, the answer is no. Normal operating systems don’t work this way. Normal modern operating systems actually get varying results when they compute things. This is a deep problem that causes programmers countless hours of frustration. The most common implication of this that you’ve probably experienced is having to reboot your computer — either because it’s locked up, or because it simply won’t do something that it was totally doing a second ago. What’s annoying to a regular user, though, is absolutely crazy-making to developers.

   This determinism makes programming on an Urbit immensely more efficient than other environments.

   Urbit applies this and a whole list of other lessons from the past half-century of systems software to increase reliability and security in everything from file storage to networking to user-facing apps. All this adds up to more security and reliability and less service-lock-in with Urbit than with our current systems.

7. **Private, human-sized, and efficient**

   Because Urbit isn’t centralized or owned by any one company, there’s no incentive for it to dominate your life. Your Urbit isn’t designed to spy on you, get you addicted to clicking its buttons, manipulate your emotions to gain attention, or nudge you to buy something. Your Urbit is a simple, customizable, permanent place for you to do all your computer-based tasks with your friends in absolute privacy.

   This is so much the case, in fact, that it presents a bit of a problem for Tlon. We don’t know how many people use Urbit every day, who they talk to, or what they’re doing. While we think this is how things should be, it puts us in a bind when a VC wants to know about our user base; we can only make educated guesses. That said, we think this is the right problem to have.

   What all this adds up to is that the Urbit network is immensely more resource efficient, secure, easier to customize, and smaller in size than any other computing system in the world. If you care about data security, privacy, durability, or even just elegance, Urbit has the best design going.

   <br></br>

<img class="ba" src="https://media.urbit.org/site/posts/essays/normies-2.png">

## How it compares

A final way to understand Urbit is to make comparisons between Urbit and current products we use today. This is limited, because ultimately Urbit will grow in directions we can’t predict, but comparisons are a useful starting place.

Again, on the current internet, we all access megacorp software using our web browsers and app interfaces. This means that we each exist as a line in a megacorp database, and those megacorps use that data to make money, which results in rampant privacy violations and addictive interfaces. Urbit is the alternative to all that: it’s decentralized, private, and secure. And it’s yours.

Let’s get to some real-world examples.

## Urbit vs. Reddit

Imagine you’d like to discuss a certain research topic with a group of friends. Say, Canadian small cap equities or the best cookie recipes. You’ll need a chat interface for live discussion, a notebook to record concepts, and a way to share links for discussion. You can do this in the default web if you want: use Reddit for the links (but make sure it’s a private group), use Google Docs for the notebook (but make sure everyone has Gmail), and use iMessage for the chat (but everyone needs a Mac). And don’t forget, each service has their own login and security holes, and they’re all mining your data.

The alternative is spin up a group on Urbit. All of that functionality is available today in one clean, simple interface. It’s private, you own the data, there’s only one login, and you can even learn to build apps for your group.

## Urbit vs. Facebook, Twitter, etc.

Or let’s say you want to share pictures with your friends, post micro-messages to the world, write a blog, or share a podcast. There’s simply no reason you should use some centralized company (one that then owns your content) to broadcast any of those things. Instead, send it out from your Urbit. You’ll own the content, you’ll control the data, no company will spy on you, and nobody can ever take your ID from you. With Urbit we all finally own the tools, and that means we own the data by default.

## Urbit vs. Nest

Imagine, as I do, that you want a connected video camera in your house, but don’t want the Nest corporation (which is now owned by Google) to be able to spy on you. Or perhaps you just don’t want to have to sign up for yet another duplicative service in order to use the camera you just bought. If any of that is the case, you can run your camera through your Urbit instead. The video feed will never leave your control, because it no longer has to live on Nest’s servers. Your camera will talk over a secure channel only to your Urbit. Your Urbit is the server.

You can apply this same concept to smart speakers, a Ring doorbell, connected baby monitor, smart fridge, or any of the innumerable connected devices that give someone else access to your personal life. Why should anyone else have access to that information?

## Urbit vs. Google Docs

Imagine you want to write a screenplay with a small group of friends, but you don’t want Google mining the content of your shared doc for advertising keywords, and you won’t want to use multiple services for chat, document sharing, email, etc. In that case, simply create an Urbit group with your friends and write together using Urbit’s writing tools. Your content will stay completely private to the team until you decide to release it to the world, and you’ll communicate using one simple interface. Even better, the archive of your multimodal work lives in one place, so looking back at your process doesn’t require reconstructing it from dozens of different apps. And everything is stored on your respective Urbit computers, not Google’s servers.

## Urbit for your protected health information

Imagine, as is already becoming the case, that it becomes highly valuable to have your genome sequenced in order to make good healthcare decisions. In that scenario, most of us would want our health care providers to be able to make precise assessments of parts of our genome, but we wouldn’t want insurance companies or other third parties to have access without our permission. In the current paradigm, once you share the information, it’s out there and can be leaked or sold. So much so that we all sort of assume that leaks are the default. In the Urbit paradigm, that information lives on your Urbit computer and nowhere else, and any software necessary to process it can be run on your Urbit as well. In other words, there’s never any need to share the raw data with anyone; instead, you can download a small program, run it on your Urbit, and share the final analyses only without ever exposing your data.

Some of these cases are, admittedly, a bit speculative since we haven’t built all the functionality yet. But it’s coming, and quite soon.

For now, if you like the way this sounds you can [get yourself an Urbit ID](https://urbit.org/getting-started/#id) and start learning about how to safely store cryptographic keys (it’s really not that hard, and we give you suggestions). If you’re feeling technical or adventurous, you can try booting our beta OS interface to see what it looks like. It’s fussy, but it exists. Soon it will be less fussy. You can check out our [roadmap](https://urbit.org/understanding-urbit/roadmap/) if you’d like to know when.

## Why we need Urbit

We humans haven’t evolved enough to manage the firehose of information that modern technology blasts us with. There’s too much news, too many connections, too many opinions, and more agendas out there than any of us can mindfully comprehend. We’re designed for much smaller communities, one-to-one connections, and slower idea assimilation than our modern infrastructure allows. The pace of change is increasing, and we don’t know how to manage it.

We’re scared, and to manage that fear we’re becoming more insular, more entrenched. Layer on top of all that the incentives that big business and big politics have to manipulate our emotions, and we’re headed in a very dangerous direction.

We can’t turn back the technological clock; humanity can only ever press onward. This is where Urbit comes in. Urbit is a forward-looking solution to this particular set of problems around human-scale computing and personal autonomy. Urbit provides a means by which groups can live peacefully in parallel.

Urbit is a computing environment that allows humans to do everything they want on computers, but in communities of their choosing, in a way that feels direct and natural, and in a way that allows true personal freedom. Urbit is calm, secure, and private in its most fundamental architecture. No spying corporations. No manipulative politicians.

And that is what we need. Humans need a way to at once take advantage of our vast technological advances but not be dominated by them. Urbit is an open-source tool that we all own, that anyone can understand down to its roots, that’s fully under its user’s control. It is human-scale computing for human-scale communities. Simple, durable, yours.

For me, this first iteration of Urbit is more than enough, and it’s exactly the sort of peaceful future I want to work towards.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2020.2.6 Update]]></title>
            <link>https://urbit.org/updates/2020-02-06-update</link>
            <guid>https://urbit.org/updates/2020-02-06-update</guid>
            <pubDate>Wed, 05 Feb 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![pajaro dunes](https://media.urbit.org/site/posts/updates/~2020.02.06-update.jpg)

It’s been a busy 2020 already, and we’re excited about everything that’s going live this year. Here’s the latest from the Tlon team:

1. Last month’s updates to Arvo and Bridge included:
   Fixes related to the network stability vote.
   [Updates](https://github.com/urbit/urbit/pull/1996) to both Gall and Ames (our application sandbox and networking module, respectively).
   [Support in Bridge](https://github.com/urbit/bridge/pull/335) for withdrawing stars from the linear release contracts.

2. Gavin (`~ridlur-figbud`) wrote about how we created sigils, the visual representation of Urbit IDs. Read the post [here](https://urbit.org/blog/creating-sigils/).

3. We’re pleased to announce the latest round of our semiannual gifts to Urbit contributors. It’s our way of rewarding the hard work of contributors to the project over the last six months. To see all the contributions we’ve recognized, take a look at the [History](https://grants.urbit.org/history) section on the Grants website.

   - `~bannum-magtus` has been tireless in their efforts as a community Guide in the #ship-starting-support channel on our [Discord server](https://discord.gg/C9ENTt3), and as an Urbit evangelizer.
   - `~nolmeg-hobdyn` could also be found nearly every day volunteering as a Guide in #ship-starting-support.
   - `~minder-folden` was a deep font of Urbit-related content, outreach, and support.
   - `~risruc-habteb` provided invaluable, consistent support in urbit-help.
   - `~rabsef-bicrym` for their efforts to teach Hoon to the community.
   - [`~dinleb-rambep`](https://github.com/pkova) brought a steady stream of useful contributions to the [urbit repository](https://github.com/urbit/urbit/pulls?utf8=%E2%9C%93&q=author%3Apkova).

4. Looking for a more formal way to contribute and get rewarded? Look for a [Bounty](https://grants.urbit.org/bounties) to claim, or pitch a [Proposal](https://grants.urbit.org/proposals) of your own. We’re always on the lookout for community members who distinguish themselves through their contributions.

5. Community member Reid is hosting a Dallas-Fort Worth meetup on February 12. [RSVP](https://www.meetup.com/Urbit-DFW/events/268194997/?rv=ea1_v2&_xtd=gatlbWFpbF9jbGlja9oAJGUwMGVjNGVmLTM3YTMtNDI1Yy05MDY1LTMyZGNiZjIxNDc2MA) to join.

6. `~rabsef-bicrym` is coordinating a Denver meetup on February 13 during [ETHDenver](https://www.ethdenver.com/). Come say hi to other community members and folks from Tlon. For more details and to RSVP contact `~rabsef-bicrym` at [denver.urbit.meetup@protonmail.com](mailto:denver.urbit.meetup@protonmail.com).

7. The next SF meetup will be on February 28 at our offices. Join us for a drink and a chat about all things Urbit. [RSVP](https://www.meetup.com/urbit-sf/events/268519069/?rv=co1&_xtd=gatlbWFpbF9jbGlja9oAJDYzNTAyYWNhLTBlYWQtNDAwNC1iODNlLTljMDk0NzQyNTE3NQ) and bring a friend.

We’ve also scheduled a meetup in SF for [March 27](https://www.meetup.com/urbit-sf/events/268519156/). We hope to see you at one of these events!

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Creating Sigils]]></title>
            <link>https://urbit.org/blog/creating-sigils</link>
            <guid>https://urbit.org/blog/creating-sigils</guid>
            <pubDate>Mon, 03 Feb 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
<!-- ![](https://media.urbit.org/site/blog-9.jpg) -->

![](https://media.urbit.org/site/posts/essays/sigils0-v3.png)

One of the basic building blocks of Urbit is Urbit ID, our naming and identity system. Your Urbit ID is a short, recognizable name that’s also a network address for your Urbit OS instance. (You can find a complete, high level description of Urbit ID [here](https://urbit.org/understanding-urbit/urbit-id/).)

Your Urbit ID is meant to feel a bit like a secret code name. It doesn’t leak any information about the real you — but it’s still memorable and recognizable. Getting an Urbit ID should feel exciting, like getting a brand new identity in a new world.

From a design standpoint, some of this is accomplished simply by having a system for the names themselves. Under the hood, Urbit IDs are actually just numbers. There has always been an algorithm for turning these numbers into pronounceable names like `~tacryt-socryp` (13,304,832) or `~litzod` (1,280) or `~nes` (212).

While the names are great, they’re not quite enough, especially in a rich interface. Each Urbit ID really needed some form of visual representation, image, or crest. A digital identity needs to be something you can really attach to, both yours and those that belong to your friends.

There are 2<sup>32</sup> or 4.2 billion unique Urbit IDs. Clearly there’s no way that we were going to do this by hand. And purely algorithmic solutions can often produce disappointing, undifferentiated output.

Regardless, we set out to tackle this problem. By the end of this process, every Urbit ID got its very own ‘sigil.’

In this post we’ll walk through how we thought about the problem, iterated through possible solutions, and the toolchain we used to arrive at the final result.

## Background

What are the basic primitives of a visual language? There aren’t any completely authoritative answers to this question, of course. But we knew that to produce such a large number of visually distinct items we’d need some way to reason about form that’s closer to letterforms.

So we started by collecting influences.

<iframe class="arena-iframe" width="100%" src="https://www.are.na/tlon/seal-zp3irwad52y/embed"></iframe>

The ‘chop’ or [seal](<https://en.wikipedia.org/wiki/Seal_(East_Asia)>) is conceptually pretty close to what we wanted to get to.

<br /><br />

<iframe class="arena-iframe" width="100%" src="https://www.are.na/tlon/kamon/embed"></iframe>

[Kamon](<https://en.wikipedia.org/wiki/Mon_(emblem)>) are even closer — especially since they have very little visual complexity.

<br /><br />

<iframe class="arena-iframe" width="100%" src="https://www.are.na/tlon/grids-jd_xbmspxkm/embed"></iframe>

We also spent a good amount of time with both Anni Albers and Agnes Martin. Both of these painters had an incredible mastery of the grid as a means of creating engaging visual work. These paintings all have a wonderful tension between an underlying system and their specific expression.

<br /><br />

<iframe class="arena-iframe" width="100%" src="https://www.are.na/tlon/stella-xfroicotm_4/embed"></iframe>

Frank Stella is a master at producing incredibly dynamic work from only a few elements. His ability to create a sense of depth from simple overlapping elements is fantastic.

<br /><br />

<iframe class="arena-iframe" width="100%" src="https://www.are.na/tlon/ledoux-palladio/embed"></iframe>

The plans of both Ledoux and Palladio are incredibly dynamic. They’re mostly gridded, use only a few elements, and use lots of symmetry — but they’re at once distinct, engaging, and fresh.

<br /><br />

<iframe class="arena-iframe" width="100%" src="https://www.are.na/tlon/flags-k9moxiayuvq/embed"></iframe>

Another influence: international maritime signal flags. We like these not only because of their striking visual qualities, but also because they correspond with a letter system, just like our sigils. Each one conveys useful information; for example, “Keep clear of me; I am maneuvering with difficulty,” a flag we all feel like raising from time to time. This influence was key to the idea that pairing symbol to phoneme was a possibility.

You can see the whole collection of our visual research [here](https://www.are.na/tlon/2019-sigils-research).

Ultimately, we didn’t specifically draw on any of these influences very consciously. The goal of visual research is to get a sense of the territory, what has been tried, and what works. We think these threads of prior work are evident in the final result — you can _feel_ them, but it’s tough to point to them individually.

## What’s in a name?

> _“Lev’s sigil appeared, strobing, as Netherton was getting out of the cab in Henrietta Street. “Yes?” Netherton asked.”_
>
> <cite>— William Gibson, The Peripheral</cite>

Before we get to how we worked through the problem of actually designing these things, let’s talk about the problem of naming.

We went through so many names for these things. Crest, symbol, seal, tag, pictograph, stamp, emblem, signet, icon, glyph, holomark, visage, radigy, pattern, the list goes on for an incredibly (embarrassingly) long time. We argued about this, we went back and forth about it.

Sigil won, ultimately, because of the way that it’s personified in William Gibson’s _The Peripheral_. In the far future, characters talk to each other by some kind of telepresence. When a call comes in from someone else, they first appear as a ‘sigil.’ It’s a strange word, but we were imagining a similar use-case.

While we can’t point to any specific parts of our visual research that reappear directly, sigil is lovingly borrowed.

## Experiments + iterations

So, how did we actually end up making these things?

We iterated through plenty of possibilities before landing on our final approach. Let’s walk through the two we remember best.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils1-v2.png)

The first attempt was a series of images in the style of Karel Martens. Overall this technique was just too cluttered and sometimes difficult to parameterize in a predictable way. We kept iterating.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils2-v2.png)

Just like the previous example, the main idea was that we could take a set of geometric primitives, combine them, then alter their appearance along a set of parameters, like color, rotation, and size.

But also just like the previous attempt, the technique of overlapping symbols made the images too difficult to read and differentiate. We wanted to create sigils that were not only great to look at, but visually ordered. Since overlapping elements didn’t seem to quite hit the mark, on we went.

## Closing in

Eventually, we realized: tiles! With tile designs there are no overlaps, which in early experiments immediately started to take on the consistent, legible appearance we were after. Each element is discrete and clearly visible. Tile designs were also easier to create and control from an implementation standpoint.

Best of all, tiles made it clear that we should be thinking in terms of creating representations of individual syllables rather than entire names. Urbit IDs are constructed from two sets of 256 three-letter syllables. `~fallyn-balfus` is `fal` `lyn` `bal` `fus`, for example. (There are two syllable sets in order to prevent duplicates — we always alternate between the two when composing names.)

Thinking in terms of syllables greatly reduced the complexity of the problem, but there was still some work to do.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils3-v2.png)

At first, we thought about using a 4 x 4 tile grid, as shown here. These designs were tricky to implement because of the detailed lines and arcs spanning across individual tiles. In order to generate a result that matched these mockups, a program would have to generate a data model that knew about which tiles touched which other tiles.

We felt this was too complicated and had an unknown performance profile. Plus, they proposed a deterministic color scheme and we felt strongly that color is personal, not to mention hard to parameterize. In the end we thought it better to create something that had the potential for user customization.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils4-v2.png)

Around this stage, we were thinking a lot about how architectural plans aren’t unduly constrained by the fact that they’re only one color. We had a feeling we could make the grid smaller and assign details to the tiles individually.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils10-v3.png)

So, we scaled it down to a 2 x 2 grid and stuck with it. It’s simple to implement, visually unique, consistent, and the color scheme is black and white, leaving room for user customization. We felt we had reached a semblance of a final result. Now all we had to do was manually draw 512 unique but consistent individual ‘phonemes’.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils5-v2.png)

As it turns out, drawing 512 consistent, abstract elements by hand isn’t easy. We had to strike a balance between authorship and automation — we wanted each tile to look well-made, but not too authored. To do so, we took advantage of Figma’s web API which helped us design in SVG but iterate programmatically.

## Final process

![](https://media.urbit.org/site/posts/essays/sigils6-v4.png)

We took a look at our hand drawn mockups and drew each individual visual building block of the tiles separately. Then we loaded the SVG elements into a script that programmatically combined them to create trillions of layered symbols. This way, we were able to easily select candidate phoneme symbols that worked visually.

We eventually added a rule system to find higher quality phoneme symbols — but this combination of programmatic generation and hand selection was working pretty well.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils7-v2.png)

The final step, using the tool we built, was to hand select individual phoneme symbols and create a complete index.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils8-square-v2.png)

This allowed us to start looking at possible combinations and selecting phoneme symbols based on their interplay with others.

Once we had selected the final set, we went about compiling the `sigil-js` library that’s now publicly available. This turned out to be fairly technically complex due to the different ways SVG is handled between browsers and Figma — but the end result is a single Javascript library you can use to embed an SVG in almost any context on a web page. See it in action and browse the available sigils [here](https://sigil.azimuth.network). If you're technically inclined, the [source](https://github.com/urbit/sigil-js) can be found on GitHub.

<br /><br />

![](https://media.urbit.org/site/posts/essays/sigils9.png)

We think sigils are pretty successful. They look nice in our native Urbit interfaces, people have made them into shirts and posters and cards, even laser-cut them to make stamps.

Urbit ID and the sigils are components of Urbit that are totally separate from the OS — you can use them on their own and potentially even extend their functionality. We’re happy with what we’ve done with them so far, and hope that people will experiment with what’s possible with this naming and identity system.

![](https://media.urbit.org/site/posts/essays/sigils11-v2.png)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.12.6 Weekly Web Update]]></title>
            <link>https://urbit.org/updates/2019-12-06-update</link>
            <guid>https://urbit.org/updates/2019-12-06-update</guid>
            <pubDate>Thu, 05 Dec 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2019.12.05-update@2x.jpg)

Wishing everyone a festive holiday season. Here are some updates from the Tlon team:

1 -
We recently released urbit v0.10.0. This continuity-breaching release contains both Arvo and Vere changes, so users should update their binaries. After upgrading, users should create new piers. Find the release binary for [macOS](https://github.com/urbit/urbit/releases/download/v0.10.0/urbit-darwin-v0.10.0.tgz) and [linux64](https://github.com/urbit/urbit/releases/download/v0.10.0/urbit-linux64-v0.10.0.tgz).

A few release highlights:

- Our networking vane, Ames, has been completely rewritten. Its protocol has been simplified, and several new features have been added to it. We expect Ames to be much more reliable and easy to upgrade.

- Perhaps most importantly, Ames now supports arbitrary-length negative acks, which was one of the primary networking bugs on our old network.

- Gall, our application sandbox, has also been significantly changed. This has also been a long-running project at Tlon that we’re really excited to get out on the live network. Gall itself is about a thousand lines shorter.

- The concept of "threads" is introduced. These are temporary processes for operations whose state is transient, like an http request-response.

- Includes a full redesign of the Landscape chat interface, plus adds additional features for mobile use and easier join flows.

Check out the full release notes [here](https://github.com/urbit/urbit/releases/tag/v0.10.0).

2 -
This year we set out to get Arvo to a point that we can credibly call ‘stable.' ~poldec-tonteg wrote about the details of how we accomplished stability [here](https://urbit.org/blog/stable-arvo/).

3 -
The final San Francisco meetup of the year is on December 13th. We hope to see you – [RSVP here](https://www.meetup.com/urbit-sf/events/266904108/?rv=ea1_v2&_xtd=gatlbWFpbF9jbGlja9oAJDA0YTUxZjZlLWU1ZGQtNGJkYS1hN2JlLWQwZTc0MDA0ZTAwZA).

4 -
The Seattle Urbit group is hosting a meetup on December 18th. [RSVP](https://www.meetup.com/Urbit-Seattle/events/266619060/) for tech and holiday cheer.

Talk to you soon!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Designing a Permanent Personal Identity]]></title>
            <link>https://urbit.org/blog/pki-maze</link>
            <guid>https://urbit.org/blog/pki-maze</guid>
            <pubDate>Tue, 26 Nov 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/pki-maze.png)

A public key infrastructure (PKI) is a system for binding a set of keys to a name. Sometimes a small amount of metadata is included.

Existing PKIs include PGP-style ["web of trust"](https://en.wikipedia.org/wiki/Web_of_trust), [SSL certificates](https://en.wikipedia.org/wiki/Certificate_authority), [ZeroTier](https://www.zerotier.com/lf-announcement/), [Keybase](https://keybase.io/), [OpenID](https://openid.net/what-is-openid/), [Mozilla Persona](https://developer.mozilla.org/en-US/docs/Archive/Mozilla/Persona), and [Login with Google](https://developers.google.com/identity). These take unique approaches to the problem and have achieved some degree of success, but none provide globally consistent, permanent, and completely self-owned identities. Exhaustive exploration and categorization is unfortunately out of scope for this post, so we'll just describe Urbit's approach to achieving these properties in our PKI.

In Urbit, a "name" is often called a "ship" or an "address" because we use the metadata in the PKI to make names routable. The total data is two 256-bit asymmetric keys, a cryptographic suite number (to allow changing crypto algorithms), the revision number of the key, and the name of a ship that will route for it. This sums to less than 128 bytes of data.

Each PKI trades off various properties. We chose a tripartite system so that appropriate choices can be made for different use cases. Here, we explore the various properties we chose by following a series of binary choices -- the idea maze.

There are two sorts of PKI: either you can change your keys or not. If you cannot, then your name is impermanent, for no one can keep a set of keys secure forever. Even if your opsec never fails, eventually your crypto algorithms may be compromised.

However, if you sacrifice the ability to change your keys, you can have a very nice property: self-attesting keys. If your name is a hash of your public key information, then no other source of information is required to verify you are who you say you are. This is a useful property since it requires no coordination at all. Many things are impermanent, especially during development. It also provides a way to try out the network without obtaining a permanent address.

This is our first stop in the idea maze. We call this sort of name a "comet". A comet's name is the 128-bit hash of its public keys.

However, Urbit is yours and it's forever. You shouldn't have to change your name every time you change your keys. So, we go back and take the other choice: you must be able to change your keys.

To change keys, you must sign a message with the old keys revoking them and supplying the new ones[^0]. The question is what happens if the old keys also sign a second set of new keys. This could happen if an attacker obtained your old keys after the fact. This is important because one of the reasons to be able to change your keys is to invalidate the old ones so that they have no power.

We have two options again: the PKI may be globally consistent or not. To be globally consistent means that if you believe a name is bound to a set of keys, then nobody on the network will disagree.

If you don't require global consistency, you may sign this message and send it to all your neighbors, and they pass it on, and hopefully it gets to most of the network quickly. However, if one of those ships receives two contradictory versions of this message, the only thing it can do is trust the first one it heard, which may be different than what someone else heard. Thus, this is pairwise consistent but globally inconsistent. This is essentially how the pre-blockchain Ames network worked, though key changes were not actually implemented. Because global consistency is a valuable property, we looked at other options.

For a globally consistent PKI that allows you to revoke keys, you need to be able to distinguish between two cryptographically valid messages to determine which was signed first. The dual problem could be solved easily — you can prove a message is signed after another by including the signature of the first in the second. This is equivalent to reading out a newspaper headline to prove a message was recorded after a given day.

However, the problem of proving one message was sent before any later ones inverts the problem. You can solve this with newspapers by placing the message in the text of the newspaper. However, while reading a newspaper requires no central party, writing one does. For a long time, this sort of message was always handled by a central party. SSL revocations are managed by a few central parties. When you buy property, it's not sufficient to have the previous owner sign the title — this must be entered into a central land registry. Otherwise, the owner may sell their property to multiple people and there would be no way to determine who is the new owner. With the land registry, all you need to do is ask the registry which sale happened first, and that's the one that counts.

However, Urbit is yours and it's forever. Trusting central registries jeopardizes both. The keen reader will notice that the problem of determining which key rotation happened first is exactly the double-spend problem that Satoshi solved with his proof of work algorithm for Bitcoin. His first block famously includes a newspaper headline to prove he didn't mine the block before that date. In a beautiful duality, his own algorithm proves that he didn't mine it after that date.[^1]

Some argue that blockchain is only good for money. This is myopic and is generally based on the experience that its most valuable application so far has been money. However, blockchain is a cryptographic primitive to do what was previously impossible: prove that one message was signed before another without a central party. Blockchain was discovered by someone trying to create digital money, and he needed that primitive, but that doesn't mean that's all it's good for.

Thus, we store our PKI data on a blockchain for our second kind of name: planets. A planet is a 32-bit address which has key information stored on the blockchain.[^2] The owner of a planet may broadcast new PKI data by adding it to the blockchain. Any later messages by the old keys will be rejected, and everyone on the network will listen to the blockchain for key data. Thus, we have global consistency, permanence, and self sovereignty. We know of no other solution that can provide these properties.

However, while small individually, the aggregate PKI data for all nodes on the network may become very large. This is not an issue for comets because nobody needs to store comet keys except for those which they're talking with, and even those can be garbage-collected and re-requested and verified. For planets, there is a canonical set of keys, and somebody must store that. There are about 2<sup>32</sup>, or 4 billion planets. If the PKI data is about 100 bytes for each planet, this is about 400 GB of data. This may be more than most users wish to store, but it's small enough that it would be very cheap for someone to host this data for many users[^3].

This information is currently stored directly on the Ethereum 1.0 blockchain, but as is well understood in blockchain circles this approach will not scale beyond a certain point. Many chains are pursing designs that allow the users of the smart contracts to store locally the data associated with the contracts they care about and only commit hashes to the chain. We expect there to be several viable options for this by the time our scaling needs exceed what's provided by Ethereum 1.0. This will free us from the cost of hosting the PKI data on all Ethereum nodes, but the data must still be stored somewhere. Any service that could handle such a large amount of data would inherently centralize the network.

However, 4 billion is not enough addresses for every device on the planet today, much less in a few decades. So, we apply our maxim of re-examining our choices at each level for each use case. Examining the idea maze above, we cannot use the blockchain option for everything since the data is too big. However, it's not actually necessary for each of your devices to have its own self-sovereign identity separate from your planet. So we choose the option of using a central registry: your own planet.

We allocate 4 billion "moons" to each of those planets. A moon is a 64-bit address whose 32-bit suffix is its planet. Your planet can easily store the keys for its own moons, and anyone who needs to talk to your moons can ask you for the keys.

This is the sense in which moons are true ships: they're permanent names and you own them completely, as long as you own the planet. However, they're not independent ships — their keys can always be revoked by their planet.

To create a sane network, we require global consistency for all our names. There are three other properties; pick any two:

- Comets are impermanent, self sovereign, and plentiful.

- Planets are permanent, self sovereign, and not plentiful.

- Moons are permanent, not self sovereign, and plentiful.

Fancifully, comets are wayward celestial bodies that are great for testing and miscellaneous low-value things that won't last for long. Planets are where you can build a home and shape it into anything you want it to be. People can always find your planet; it's not going anywhere. Moons are useful for special purposes, like storage, heavy industry, and anything else you might want to do off-planet.[^4]

[^0]: Or the equivalent with a hierarchical key structure. In practice, you want to have a master key which signs a junior key for everyday use. You use the master key to rotate the junior key.
[^1]: More strictly: it proves that he didn't mine it after the other blocks currently on the Bitcoin blockchain. It only gives an ordering within the chain, not a literal timestamp.
[^2]: In addition to planets, there are stars and galaxies. From a PKI perspective they're treated exactly like planets, but on the network they provide infrastructure services like routing.
[^3]: In practice, this will likely be an included service by your sponsoring star. It could be a separate service, but it will be very cheap because it's a commodity and the "cost of production" is very cheap. At any rate, it should never rise above the capital cost of a 400GB hard drive.
[^4]: To extend the metaphor, stars are a neighborhood to live in -- they're easier for other planets to see, so when they want to send you a message they look for your star first. If they don't even know where your star is, they can certainly find your star's galaxy, and that will be enough to locate the star. Of course, if your star is not providing satisfactory service, you can take your planet and move to another star.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Stable Arvo]]></title>
            <link>https://urbit.org/blog/stable-arvo</link>
            <guid>https://urbit.org/blog/stable-arvo</guid>
            <pubDate>Tue, 19 Nov 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/stable-arvo.png)

### A contract by which Arvo evolves

We want your Urbit to last forever. We want an ordinary Urbit user to never worry about their Urbit breaking, going away or failing unexpectedly. We don’t just want this — we think this is one of the most incredible things Urbit can actually deliver.

In order to get closer to an Urbit that can last forever, we set for ourselves the goal of getting Arvo (the kernel of what we’ve been calling ‘Urbit OS’) to a point that we can credibly call ‘stable’ by the end of 2019.

But what do we mean exactly by ‘stable’? For something meant to last far into the future, stability really means _resilience_. Arvo has to both run and upgrade itself without ever breaking or falling into an unrecoverable state.

Getting Arvo to this point doesn’t quite achieve the user-level goal we’re hoping to achieve. But if you’re comfortable doing a bit of system administration, Arvo itself should need almost no maintenance.

To achieve stability in practice Arvo needs three things:

- The Arvo network (Ames) has to be stable
- Arvo can’t easily fall into an unrecoverable state
- Arvo has to have a clear and formalized upgrade mechanic

All of these are actively being worked on, and are mostly near completion. Let’s walk through them one by one.

### A new Ames

To ensure that Arvo can upgrade itself forever, it needs a network to deliver the updates. Toward this end we’ve put a lot of work into making Ames, the Urbit networking protocol, as reliable as possible.

Ames is a big part of what makes Urbit Urbit. It guarantees exactly once message delivery, it’s encrypted and authenticated. The original Ames design is pretty good. But it’s also incredibly difficult to maintain and had a few really painful edge case bugs. When the network has fallen over in the past, it has been far too hard to debug the original Ames code.

We managed to update this original Ames code to use Ethereum as the source of truth for keys and key updates. We also made significant changes by introducing a new version of Jael, our kernel module for managing keys and signing inside of Urbit. While this change was significant, Ames still had some pretty nasty occasional bugs related to subscriptions and subscription updates. In order to get Ames to be truly reliable, it needed a rewrite.

We’ve been working on that rewrite, codenamed Alef, for a few months now. Alef doesn’t aim to add any new functionality — it’s simply a drop-in replacement that’s cleaner and more reliable. We currently have Alef running on a testnet and sending packets with an industry-standard congestion control algorithm. There’s still some work to do, but it’s coming along nicely. Some early tests even show it to be faster, which is great.

We expect to switch to Alef in a continuity breach (network reset) during this quarter. This will be a huge step toward resilience. A networking protocol we can trust to deliver updates is essential for a computer that will last a long time.

### Recoverability

Another barrier to stability with existing Urbit is that a ship can, under specific conditions, fall into a terminal state. If part of your ship’s state relies on event in the future and this event crashes, then that part of the state can become unrecoverable. Consider, for example, an event that is set to be triggered by a timer. If this timer crashes, that event will never happen. This is a huge problem.

In order to understand the difficulties with error handling and how we’re dealing with it, we have to understand the Arvo operating system. Arvo is responsible for coordinating messages being sent from the outside world (Unix in our case) and messages sent from one vane, or kernel module, to another. Both Arvo and the vanes are explicit state machines, meaning that they must specify every possible state and the transitions between them. These properties make it possible for the system to be fully updated (we’ll discuss such upgrades below).

This architecture means that errors have to be considered not simply as an exception, but as a possible state in the explicit state machine. In practice, we have to account for both deterministic errors like semantically invalid formulas and non-deterministic errors like running out of memory or a plug getting pulled.

Deterministic errors are currently handled within the virtual interpreter, Mock, and result in a “bail: exit.” They can be handled “within” Arvo and are never written to the event log. The real difficulty lies with non-deterministic errors, specifically ones can potentially cause other events.

An obvious case of causally-connected events is a timer; any code that sets a timer eventually suspends itself, waiting to be awoken. And yet, if the subsequent timer event were to crash, the state machine awaiting it would remain suspended, expecting a transition that can and will not
occur.

We believe that we have a general scheme that accounts for both classes of error. We’ve formalized this and will use it going forward to avoid falling into inconsistent states.

Our solution to this problem is simple: if Arvo or one of its vanes crashes while processing an event, the fact of the failed event itself becomes a new event. The runtime injects an error notification in the event log, named, as is befitting of a failed event: %crud.

In the case of a failed timer event, the error notification is routed back to the code that set the timer and communicates the following: you were expecting to be woken up, but, when you were, you crashed. The code in question could then consider the logical operation of which the timer was a part to have failed, or perhaps it could try again. In any case, it must not crash when handling the error notification, and it must not continue to expect to be woken up.

This quarter, building on previous work, we’ve built on the %crud pattern and mapped the protocols between the vanes and between arvo and vere. This allows us to make sure that %cruds are all handled (so as to avoid the crash discussed above) and, in future iterations of the vanes, know what conditions need to be accommodated to avoid introducing regressions.

By adopting this pattern and virtualizing userspace, we can make completely sure that code running in the kernel or an app can’t cause your ship to get into an inconsistent state.

### Telescoping Kelvins

Finally, in order for a ship to reliably receive and apply upgrades, we need to formalize and enforce a versioning scheme inside the system.

Most software simply increases its version number on each release. Nock (our VM spec) and Hoon, on the other hand, uses kelvin versioning. Kelvin versioning doesn’t infinitely increase version numbers. Instead, we decrease the version number on each significant change in the hope that our software will eventually not need to change at all. Infrastructure, if it’s going to be truly reliable, should eventually reach absolute zero.

Nock is already nearly frozen at 4K. A change to Nock is a major event.

At the level of the kernel (including Arvo proper, Zuse, and the Vanes), we’ve never fully followed a kelvin versioning scheme. The bottom of the stack always had to freeze first. But now the system is starting to stabilize such that we need a path toward a ‘cool’ system all the way up in the vanes. Versioning the kernel is a different challenge than the VM or language since the vanes interoperate with one another.

We have a formalized scheme for how we think kelvin versioning should work at the Arvo level in process now. This year we’ll start tagging each version of the kernel with an appropriate kelvin. This scheme means not only applying a version tag to each kernel, but also making sure there are transition functions written between versions. Additionally, it will include a versioning mechanism for the interface between the kernel and the runtime.

Let’s dive into the details, but just a bit:

The mechanism for the kernel is pretty simple. In short, we’ll enforce that everything above a particular layer must ‘cool’ (or upgrade, by shedding a version number) when something underneath drops a version number. This ensures that the system can’t fall into an incorrect state due to simple incompatibility. For example, if Hoon changes, all of the Arvo kernel must similarly drop a kelvin to ensure compatibility.

The versioning scheme between the runtime and Arvo is similarly straightforward. We’ll build in an affordance for notifying the user if we need them to manually upgrade the interpreter. This ensures that API changes between interpreter and kernel can always be non-breaking. Someday interpreter changes can be done over the air (like your browser downloading its own upgrades), but we’re not there yet.

What’s important about these two things is that they let us take continuity seriously. "Continuity" or "permanence" is arguably Urbit's killer feature: you start your ship, it just works, forever. Back it up on a USB drive, throw it in a drawer for forty years, and upon reconnecting to the network in 2059 (and pulling down all the updates you've missed) you're back in the game.

With the recent 0.9.0 release we’ve gotten to the point where we can make almost all our upgrades over the air. Even the language is now upgradeable over the wire.

But — in order for that scene in 2059 to actually work, these upgrade mechanisms have to be in place. As your ship upgrades itself, the system needs a way to ensure that each upgrade gets applied in a compatible way. Right now we’re careful about deploying over the air updates such that they don’t break, but that’s obviously not sustainable.

Once this versioning scheme gets released later this year, there’s nothing technically preventing you from starting a late-2019 Urbit in 2039. We hope you’ll use it a lot in the interim — but this is an essential feature for a decentralized system that claims to upgrade itself. We’re really excited to get it implemented.

These three areas of work are all due to complete later this quarter. This gets us something that’s much more resilient than what we’ve ever had before. Given a stable system, we can actually start to put some serious weight on it.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Why Hoon?]]></title>
            <link>https://urbit.org/blog/why-hoon</link>
            <guid>https://urbit.org/blog/why-hoon</guid>
            <pubDate>Wed, 13 Nov 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/hoon.png)

### What can Hoon do that other languages can't?

The short answer is: implement a purely functional operating system.
Try to do this in a principled way in Haskell, and the problems you'll
run into will make design decisions in Hoon and Nock make a lot more
sense.

In particular, the problems Hoon solves that aren't solved by other
functional languages are:

- Compile and run other code in a typesafe manner at full speed,
- Typesafe metaprogramming, and
- Hot code reload and online data migration.

### What is Hoon good at?

Hoon is mostly good at compiling and running other Hoon code. Urbit
consists of many layers of bootstrapping. Several of these layers lean
heavily on this feature, including the Gall application runner, the Ford
build system, the Dojo shell, and the Arvo kernel itself. Even Urbit's
chat application lets you run Hoon expressions and share the results
with your friends.

### Why did we write the OS in Hoon?

The chain of reasoning goes something like this:

Software complexity leads to monopolies and lack of individual digital
sovereignty, in addition to bugs and security vulnerabilities. One of
the best ways to reduce software complexity is to restrict oneself to
pure mathematical functions — no side effects, no implicit arguments.
This makes the system deterministic. So we want a deterministic,
functional operating system for individuals to run.

This operating system should also be axiomatic; we don't want it to
depend on various idiosyncrasies of whatever the current hardware is
like. Hardware changes over time, and we want people to be able to pass
their computers on to their grandchildren, so we should have a virtual
machine that runs this functional operating system.

As hardware changes, people need to move their virtual machines to new
hosts. This means there needs to be a standard way to serialize and
deserialize the VM state at any time. The easiest way to do this is by
storing an event log, just like a database, and writing each event to
that before emitting effects caused by it. Since we also need state
snapshots, every piece of data in the system, including runtime state,
needs to be serializable to a standardized format.

Because the VM will likely move from host to host many times, it needs
to be tractable to actually implement a VM correctly. This means the
system specification needs to be simple enough that it's clear whether a
VM is in fact correct. The x86_64 instruction set that runs most
servers has somewhere between 1300 and 4000 opcodes, depending on how
you count. Nock has 12.

Since Urbit is an operating system, its main purpose is to load and run
programs on behalf of the user. This means the system needs to be
really good at hot code reloading, self-hosting, metacircularity, and
virtualization.

There aren't any other languages out there that are purely functional,
purely axiomatic, performant enough for practical personal use,
universally serializable, and good at runtime metaprogramming. Nock is
Urbit's solution to these design constraints. Some Lisps come close to
meeting these criteria — and Nock is very Lisp-like — but no practical
Lisp dialects are nearly as pure or axiomatic as Nock.

### What is special about Hoon?

It's a purely functional systems language. Calling it a functional
analog of C is not too far off in several ways. Almost all code
throughout Urbit's kernelspace and userspace is written in Hoon.

### What properties does Hoon have? What type of language is it?

Hoon is a statically typed, purely functional, strictly evaluated
programming language.

Hoon and Nock have several unusual properties:

- **Axiomatic**. Nock is a fully axiomatic computing system — no
  dependencies, no builtins, no hardware dependence — just pure math.
  The jet system gives this a practical level of performance.

- **Layered**. Nock is machine code designed for machines to run; Hoon is a
  programming language designed for people to use. Hoon layers over
  Nock in a very similar way to how C layers over machine code. Nock
  has no symbols; all programmer-facing variable names live in Hoon
  types. You can use raw Nock from Hoon, much like dropping down to
  assembly from within C. Hoon compiles to Nock with no "runtime
  system" — aside from subtree lookups, you could pretty easily compile
  most Hoon expressions by hand.

- **Minimal**. Urbit is ruthlessly minimalistic throughout the stack. Nock
  has only twelve opcodes, and Hoon's semantics are a very thin layer
  over Nock's. The only fundamental datatype in Urbit is the noun:
  either an arbitrarily large natural number, called an atom, or a pair
  of nouns, called a cell. This forms a binary tree with atoms at the
  leaves. Lists, sets, maps, queues, executable code, closures, ASTs,
  buffers, strings, floating-point numbers, and everything else in the
  whole programming environment are represented using just this data
  structure.

- **Acyclic**. There are no cycles in nouns, since they're always trees, so
  there are no cycles in Nock's memory model. Pointer equality is not
  exposed to the programmer. In practical Nock implementations, all
  data structures are what are elsewhere called "functional" or
  "persistent" data structures, meaning they're immutable and share
  structure wherever possible.

- **Homoiconic**. Code and data are represented the same way and can be
  converted to each other. Lisp dialects are also homoiconic, but Hoon
  and Nock are arguably even more so, since things like closures and the
  environment are just Nock trees. We even have a statically typed
  metacircular interpreter called <code>+mule</code>. We run userspace code
  metacircularly with negligible performance overhead because of Urbit's
  jet system. In Lisp, "eval is evil" is a common saying, but in Urbit,
  eval is a first-class feature.

- **Universally serializable**. There's one serialization format, called
  "jam", for any piece of code or data in the system. This makes it so
  that deserialization has just one function, a few hundred lines of C,
  as its security attack surface. It also facilitates portability of
  the virtual machine state, since this function can be called on the
  top-level VM state itself to generate a portable snapshot.

- **Jetted**. A jet is a piece of code that the Nock interpreter has that
  reimplements a Nock function in some other, faster language. The `+dec`
  decrement function in Hoon's standard library is defined axiomatically
  using recursion, but is run as a jet written in C that makes use of
  the processor's ALU for performance. When calling a Nock function, if
  the runtime has a matching jet, it will use that instead of the Nock
  implementation. Nock isn't as slow as you might think, especially
  considering it's a minimal, dynamic, axiomatic language.
  <br/><br/>
  This arrangement has the deeper implication that all code written in
  Nock is best considered as a specification for a program, which can be
  executed directly but might never run at all due to being jetted.
  Cryptographic functions, for example, should all have jets with
  constant-time implementations to prevent timing attacks. Most jets,
  though, just take advantage of hardware acceleration for things like
  floating point arithmetic.

- The amount of Hoon syntax is unusually large, but also **unusually
  regular**. Hoon is a "runic" language, meaning expressions generally
  begin with a digraph "rune" corresponding to the type of expression.
  Runes are used in place of keywords and Lisp's "special forms".
  Hoon's syntax makes better use of screen real estate than Haskell or
  Lisp by having a mostly vertical "backbone" of runes that prevents
  long functions from indenting repeatedly and helps quickly identify
  control flow. Hoon does not allow syntactic abstraction, so you
  always know exactly what you're looking at when reading Hoon. The
  similarity of Hoon's syntax to its abstract syntax tree makes
  metaprogramming easier and can be thought of as another layer of
  homoiconicity on top of Nock's.

- **Subject-oriented**. There is no implicit environment; a Hoon expression
  compiles down to a Nock formula, which is interpreted as a function
  that runs with the "subject" as the argument. The subject can be any
  Nock tree, but it contains everything that's in scope. It usually
  consists of the Hoon compiler and standard library as a stack of
  cores, along with whatever functions and variables have been defined
  in the lexical scope.

- **Cores**. A core is a pair of code and data. The core is the underlying
  representation of a function (a lambda with implicit fixed point), a
  library or module, an OOP-style object, and an OOP-style "interface"
  or "protocol". The code consists of a set of Nock formulas that can
  each be run against the whole core as a subject. This means there's
  always an implicit fixed point when running a function, and mutual
  recursion can occur among a core's formulas. A core's data usually
  consists of the standard library (itself a stack of cores), and
  possibly a "sample" (function argument).

- **The type system has several unusual features**. It's intensional, in
  the sense that all constructs are first-class and can be up-cast to
  `noun`, Hoon's "any" or "top" type that matches all Nock nouns. Types
  are also used as scopes, so they store all of Hoon's variable names
  and docstrings. The type system uses an unusual macro-like feature
  called "wetness" to implement parametric polymorphism. The type
  system can also auto-generate coercion functions that validate and
  lift raw nouns into structural types, such as lists or cells. This is
  used to validate untrusted data, such as from the network.

- **Reflective**. The type of type is just a normal datatype in Hoon, and a
  lot of the system manipulates types. In particular, the `!>` rune, when
  applied to a piece of data, uses compile-time type reflection to
  produce something called a "vase": a pair of type and data, similar to
  a <code>Data.Dynamic</code> in Haskell, or a limited form of a dependent pair.
  Since the Arvo kernel does a lot of dynamic compilation, it uses vases
  to implement something akin to a dynamically typed language using
  Hoon. This allows for type-safe dynamic program loading, program
  execution, and data migration.

- **Inert**. Because Nock is purely functional, Hoon compiles to it so
  directly, everything is homoiconic, and Hoon is intensional, there's a
  very nice feeling that everything is just a stationary tree. There
  are no special objects that can't be manipulated; everything in your
  environment is just a subtree, and you could grab it and print it out
  if you wanted to. There's nothing like a "database handle",
  "websocket connection object", or other mystical constructs. The
  calmness of working with such inert building blocks is addictive, as
  many Hoon programmers will attest.

### Why is Hoon the way it is?

Minimalism, mostly.

Urbit's principled minimalism simplifies all kinds of things at many
layers of the stack; for example, Urbit's linker, which is part of the
Ford build system, just conses together multiple libraries into a tuple
to form the compile-time environment for a source file. Universal
serialization means we can safely send arbitrary pieces of data to apps
on other ships without any more work than sending them to a local app.
Using an app called Aquarium that's about three hundred lines of code,
Arvo can run a whole fleet of other Arvos inside itself at full speed,
just like Docker, and perform a suite of deterministic end-to-end tests
on the OS as a whole.

Even Hoon's seemingly baroque syntax is extremely regular and an
unusually thin layer over the abstract syntax tree. It's designed to be
a power tool; learning the syntax takes some time, but you only have to
learn it once, and then it's not hard to read. It's like an English
speaker learning Hiragana or Cyrillic. This heaping spoonful of syntactic sugar
(along with jets for performance) is enough to take Nock from a Turing
tarpit to a practical, ergonomic programming tool.

Subject orientation in Nock and Hoon stems partly from minimalism
(there's just one subject, which serves as state, lexical scope,
environment, and function argument), partly from a desire to simplify
compilation (the type of the subject is a full specification of the
compile-time environment for a source file), and partly in order to give
the language a more imperative feel.

You program Hoon as if you have a mutable environment, but you're
embedded in a purely functional, immutable context. While Hoon is a
purely functional language, many of its runes create a mutant copy of
the subject for manipulation by future runes (similar to Forth's stack
operations), which makes it feel more like an expression is "doing
something" rather than just calculating something.

Everything about a scope, including name bindings, aliases, and
docstrings, is stored in the subject's type. This allows Hoon's
compilation discipline to be similarly minimal: the compiler is a
function from subject type and Hoon source to product type and compiled
Nock. Running this Nock against a value of the subject type produces a
vase of the result. It's hard to imagine a more streamlined formalism for compilation.

The compilation discipline gets applied recursively to build the layers
of the Arvo stack. The Arvo kernel is compiled using the Hoon compiler
as subject, the Zuse standard library is compiled using the Arvo kernel
as the subject, and apps and vanes (kernel modules) are compiled using
Zuse as the subject.

The promise of Urbit lies in its reimagination of the digital world
using components that are as constrained and limited as possible. By
adhering firmly to principle and doubling down on minimalism at every
turn, we get an OS that provides far stronger guarantees than Unix with
a thousand times less code. Given the complexity of modern software,
this is what's required to put personal computing back into the hands of
people.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.11.06 Update]]></title>
            <link>https://urbit.org/updates/2019-11-06-update</link>
            <guid>https://urbit.org/updates/2019-11-06-update</guid>
            <pubDate>Tue, 05 Nov 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2019.11.06-update.jpg)

Hello from San Francisco!

We’re thinking of everyone in the North Bay and elsewhere who were affected by the recent fires. While we’ve had a few days of poor air quality in SF, we’re grateful that it hasn’t been as bad as last year.

Here are some updates from the Tlon team:

1 -
Tlon has been on tour! We just got back from Berlin where we gave a talk at the Lightning Conference. [Check it out](https://youtu.be/vVIt06w3IbM?t=2030). While we were there, we [talked](https://www.youtube.com/watch?v=775vmOKxwSY) to the World Crypto Network.

2 -
If you’re wondering what all this Bitcoin stuff is about, we summed it up [here](https://urbit.org/blog/urbit-and-bitcoin/).

3 -
We’re offering a free, introductory-level online course on Hoon, the programming language that’s designed for use with Urbit. Hoon 101 begins on November 11th and runs for six weeks. Sign up [here](https://urbit.org/hoonschool/).

4 -
We’ve got a new version of Ames (the Urbit OS / Arvo networking protocol) compiling and up to date with master. `~pilfer-pandex` also wrote some compiler documentation that is getting rave reviews around the office. `~wicdev-wisryt` was so inspired that he added tab completion to the Dojo and built [a language server](https://github.com/urbit/urbit/pull/1910).

5 -
Kenny, a long time community member, is hosting the first-ever Urbit meetup in Seattle on November 12th. Details [here](http://meetu.ps/c/4tZGf/c0Pdg/a).

6 -
The next San Francisco meetup is on November 15th. [RSVP here](https://www.meetup.com/urbit-sf/events/266146513/).

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Simple, Durable, Yours]]></title>
            <link>https://urbit.org/blog/simple-durable-yours</link>
            <guid>https://urbit.org/blog/simple-durable-yours</guid>
            <pubDate>Wed, 16 Oct 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
We live in a world dense with digital services. We see the world through them, we depend on them completely, and they’re not going away. They’re only becoming more ubiquitous.

But computers are a mess.

<img class="ba mv5 w-100" src="https://media.urbit.org/site/understanding-urbit/simple-durable-yours/simple-durable-yours-notifications.svg">

We spend all our time switching between services, juggling logins and different interfaces. And once we’re logged in, the services we use harvest our data, spy on us, and often shut down with little warning.

If computers are going to be a part of our lives for generations to come, we need a sound foundation for them. We need a _system_, not a grab bag of apps and services. Urbit is that system.

<img class="ba mv5 w-100" src="https://media.urbit.org/site/understanding-urbit/simple-durable-yours/simple-durable-yours-rock%402x.png">

We built Urbit from scratch to be a system that’s simple, durable, and yours. Everything that computing today is not — but should be.

What do we mean by simple, durable, and yours? Let’s walk through it one by one.

<br /><br />

## Simple

Urbit is designed to be incredibly simple for ordinary users. Your data, applications, and connections all live in a single, unified operating system that belongs to you. Your Urbit requires no system administration and gets all its updates over the air. For developers, Urbit is incredibly compact and efficient. It’s about 50K lines of code — smaller than your average webapp. The entire OS can be understood by a single person and is designed to make building decentralized apps straightforward.

<br /><br />

## Durable

Your Urbit is designed to be durable: both to store your data across generations and to be resilient against crashes. You can't really trust a computer that could disappear or become obsolete. We’ve become accustomed to this distrust, but it’s not the way things should be. Your Urbit is meant to be a permanent digital home. At its foundation, Urbit is designed a bit like a blockchain — making reliability and permanence a priority for the individual.

<br /><br />

## Yours

Finally, your Urbit belongs to you in every possible way. You own it with a private key, control it completely, and can inspect its source code. We want your Urbit to be your digital home. A home you don’t own is just a hotel room.

<img class="ba mv5 w-100" src="https://media.urbit.org/site/understanding-urbit/simple-durable-yours/simple-durable-yours-evolution.svg">

Urbit began as a sketch, driven from a basic intuition that a better platform could be built. Today, Urbit is two components: Urbit ID, an identity system that’s already live on Ethereum; and Urbit OS, a decentralized network and OS stack that’s young but working well.

Over time we’ve quietly evolved Urbit into a carefully engineered, compact system. Urbit isn’t done — but it’s well on its way. The network has been live since 2013 and the interface is coming along nicely. You can own a piece of Urbit today if you can find an invite from a friend, or by buying an Urbit ID. We’re ready for people to begin homesteading this new territory we created with new communities and new software.

We think it’s possible to leave today’s technology behind and build something better. Something more humane, calm, and collectively owned. Our vision of the future isn’t one where technology intrudes in every corner of our lives. It’s one where technology is mostly invisible.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit and Bitcoin]]></title>
            <link>https://urbit.org/blog/urbit-and-bitcoin</link>
            <guid>https://urbit.org/blog/urbit-and-bitcoin</guid>
            <pubDate>Wed, 16 Oct 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Sound money deserves a sound computer.

Urbit imagines a new model for an OS that – among other changes – includes money as a native service. Developers within the Urbit ecosystem will be able to securely use money in their applications as easily as they might use file systems or networking protocols. Creating a new sound currency, however is not our goal; Bitcoin has already done that.

Running a Bitcoin node is very much like running a single purpose personal server (one that hosts the Bitcoin blockchain and verifies transactions). Urbit is designed to be the _final_ personal server, so this week we launched several grants to incorporate Bitcoin into our development cycle. The first of these are directed towards interacting with Bitcoin nodes directly from Urbit.

Bitcoin and Urbit are complementary systems. Sound digital money requires sound computing to be used safely and effectively. Urbit’s OS is strictly-typed and entirely functional, and as a result, it’s orders of magnitude more secure than the Unix ecosystem when fully implemented.

Urbit and Bitcoin converge along the realization that the Virtual is subsuming the Real. In other words, the locus of control over your life is no longer embodied in the physical, but the digital. For example, what worries you more: a pickpocket or a sim-swapper? The bogeymen of today don’t target our physical selves; they target our private keys, our searches, and our data. The client-server computing paradigm is falling in upon itself, and cannot protect us in this new reality. Without peer-to-peer tools like Urbit and Bitcoin, our property and lives lie vulnerable to control by platforms.

To integrate Bitcoin with Urbit, we’re starting with the basics: a Bitcoin wallet and a Bitcoin node solution for Urbit. These tools will bring Urbit’s Bitcoin functionality from 0 to 1, and will serve as building blocks for our upcoming push from 1 to `n`. We’ll be sharing more about this in the coming weeks and months. If this excites you, please feel free to get involved with some of our current Bitcoin bounties, found [here](https://grants.urbit.org/bounties).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Your Last Computer]]></title>
            <link>https://urbit.org/blog/your-last-computer</link>
            <guid>https://urbit.org/blog/your-last-computer</guid>
            <pubDate>Wed, 16 Oct 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
This whole ‘simple, durable, yours’ thing may sound good, but what does it add up to? What does it feel like?

First, let’s talk about what it should feel like in the future.

<img class="mv5 w-100" src="https://media.urbit.org/site/understanding-urbit/your-last-computer/your-last-computer-waves%402x.png">

Imagine that you can log in from anywhere with one simple, memorable name and password. And when you do, an entire OS appears for you. Inside is your whole digital life. Every conversation you’ve ever had, all your biometric data — every step and heartbeat. Your personal mesh of devices: your doors, your car, your irrigation. All of your communities, every message you’ve shared with friends and family. Every connection you’ve made and every archival piece of data, in one place. Secure and private, forever.

You own and control this OS completely. Your system doesn’t live on someone else’s server, so there’s no risk of leaking it in a mass data breach or losing it when a service shuts down. Your Urbit is a sealed, secure, and durable system.

<img class="ba mv5 w-100" src="https://media.urbit.org/site/understanding-urbit/your-last-computer/your-last-computer-is-rock%402x.png">

We’re on our way to this future, building it step by step, but we’re not there yet. The Urbit of today is much more stripped down.

The stripped-down Urbit – Urbit OS 1 – starts out as a new kind of social network.

Today, each of our social tools does one thing. And so each of our communities ends up spanning multiple services. Urbit OS 1 gives you the tools to bring these together into one place.

In Urbit OS 1, a community shares a set of modules. (Think of a module like an app without the data lock-in.) One community may choose to chat and share a forum. Another may choose to chat and watch the crypto markets. And yet another may chat, share links, ebooks, and a to-do list. Anyone can develop a module, and anyone can create a community.

It’s a simple system for intentional digital communities. A first step away from the ill-formed digital world of today. We like to call it ‘social computing’ — on the surface it feels like a new kind of app, but under the hood it’s an OS. It’s customizable all the way down.

We think that a new system like this, even in a simple form, will be a relief from the chaos of the current web. Think of it as a “back to the land” computing movement. If we’re ever going to build new digital cities, they’ll have to start as a few colonies on the frontier.

<img class="mv5 w-100" src="https://media.urbit.org/site/understanding-urbit/your-last-computer/your-last-computer-ocean%402x.png">

Your Urbit is a simpler computer, a quieter computer, a more private computer. We want it to feel predictable, safe, and reliable — things only a complete, sealed system can do. This, we hope, can get us a world where technology keeps us connected, but doesn’t dominate our lives.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.10 Roadmap]]></title>
            <link>https://urbit.org/blog/2019-10-3-roadmap</link>
            <guid>https://urbit.org/blog/2019-10-3-roadmap</guid>
            <pubDate>Wed, 02 Oct 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/2019-10-3-roadmap.jpg)

The daily work of building a new OS from scratch is so engaging and exciting that we habitually forget to even take stock of what we’ve accomplished. We’re fixated on the prospect of moving the world on to Urbit, starting with ourselves.

It’s a good thing I have a recurring reminder to write these updates. While our focus is on the future, it’s good to get a sense of the rate that we’re moving forward, and to let everyone know what’s been going on. We’ve made great progress over the past few months.

We’ve got a new interface, Urbit 0.8.0, Hoon School, and a grants program among lots of other updates. We’ll go into detail about all of these, and talk a bit about where we’re headed next. The system is improving at a really good pace. We intend to keep it up.

## Identity (Azimuth)

The other day I got an email, clicked a link, and got a planet. A real, live, piece of cryptographic property with paper wallets and everything. It took about two minutes. And at the end, I could have easily sent invites to my friends.

This experience is part of a completely new Bridge, the interface for interacting with your Urbit identity. The beta experience we’re testing today is quite stripped down, but it’s a huge improvement over the last Bridge release. Clicking a link is a lot easier than downloading source code, running it from the command-line, and probably running into a python-related error.

Getting to this point involved rewriting Bridge from scratch, figuring out how to host it securely, building infrastructure to fund the requisite transactions involved in registering a new identity, and setting up a service to send emails (and dispose of them afterward). We've also redesigned our paper wallets to make them simpler and clearer.

We still want to get this new version of Bridge a bit further along before releasing it to everyone — but we’re excited about it. We didn’t quite get to the point of building an affordance for payments, which we had hoped to do, but that’s coming later.

We want everyone to have an Urbit identity. And we want it to be incredibly easy to get one, so we’ll get Bridge out this month with a new urbit.org (more on that below).

The other area of identity-related work was Sigils — the algorithmically generated images that go with every Urbit identity. (We’ve got a blog post in the works that covers how we created these, which is a good story that needs to be told.) The original version of Sigils didn’t look very good at small sizes and a few collisions were found (thanks to [urbit.live](https://urbit.live) for helping to discover the collisions). The [new, improved sigils](https://github.com/urbit/sigil-js) have no collisions and look great at small sizes.

**Q4 2019**

- Release Bridge to the public
- Get Bridge working well on mobile
- Add payments support, hopefully including BTC
- Add a network explorer

**Q1 2020**

- Integrate Bridge with a native app for Arvo

## OS (Arvo)

As a team, we want Urbit to be our primary computer, our last computer, our permanent computer. And we want this now — or at least as soon as we possibly can. We’re both ambitious and impatient.

The frustration that we can’t move onto Urbit today propels us forward. The system saw major updates over the past few months all the way through the stack. On the Arvo side, we divide our work into Infrastructure (everything in the kernel and interpreter) and Interface (everything in userspace and the front-end). We’ll start with Infrastructure progress first.

We’re very nearly to the point that all the kernel-level code in the system has been written by our current team. The one remaining vane that deserves a rewrite (Gall) has had a major cleanup by Jared just recently. The [Ship of Theseus](https://en.wikipedia.org/wiki/Ship_of_Theseus) approach does appear to be working. The infrastructure team is doing fantastic work and has really deepened their ownership of the system. The Urbit of today is on the road to becoming a great piece of system software.

The biggest infrastructure-level milestone was the release of [Urbit 0.8.0](https://github.com/urbit/urbit/releases/tag/v0.8.0). We introduced a new process-separation architecture, implemented the correct bootstrap sequence, moved to LMDB for persistence, replaced our http vane (%eyre) and moved to Nix for our build system.

To put it simply, Arvo is now much more stable and durable. During the beginning of the year we were seeing bugs and instability that were frustrating and unacceptable. While there are still issues on the live network, none of them terrify us much. We also implemented the ability for users to ‘individually breach’, which means that you can now reset your Urbit without waiting for us to reset the network.

### Landscape (Arvo UI)

We don’t just build infrastructure for others to develop on top of. We build interfaces too. At the top of the stack, we released a completely new Landscape, the interface for Arvo. This new interface makes it possible to build other ‘modules’ for Arvo that go beyond chat and publishing.

This new Landscape is a complete departure from the last direction. Your Urbit now has a simple home screen that launches individual modules and it’s [relatively easy](https://github.com/urbit/create-landscape-app) to create new ones. We’re all enjoying using Landscape around the office. It’s still a bit of a prototype — but it’s quite a good one, I think.

In moving to this new model we decided to narrow our focus to desktop only for now. We’ll return to mobile again next year — but first we want to get the desktop experience right. We’ve pulled the iOS app from the app store for the time being. I’m personally sad to see it go, since I enjoyed using it. But our prior iteration of Landscape just wasn’t quite right.

This version of Landscape is, I think, the last one that we’ll call a prototype. Over the past few weeks, since shipping this, some amazing work has been happening on the interface front. We have a systematic approach to building interfaces on top of Urbit that’s very promising, albeit just getting started. We’ve already put out [one post](https://urbit.org/posts/landscape-a-portrait/) about Landscape's future, with more posts to come.

**Q4 2019**

- Improved Arvo-level error handling
- Implementation plan for ‘telescoping kelvins’ — or [how we plan to future proof Arvo](https://groups.google.com/a/urbit.org/forum/#!topic/dev/6Mwn6TQFVwc)
- Versioning scheme between Arvo and Vere
- A new Haskell implementation of the daemon
- A native client (instead of just a browser tab)
- A [new user-space architecture](https://docs.google.com/document/d/1hS_UuResG1S4j49_H-aSshoTOROKBnGoJAaRgOipf54/edit)
- Hoon.hoon that’s OTA upgradeable
- Working Jacque prototype, a graal-truffle-based implementation of vere

**Q1 2020**

- Integrated client with Bridge and Arvo
- New interface framework, codenamed ‘Widescreen’

## Docs + Community

We had quite a bit of interest in our second session of Hoon School. We ended up with 150 people enrolled in Hoon 101, and 42 in 201. The 101 session just ended, with a lot of positive responses and feedback from the participants. We learned a lot doing it and got quite a bit of interesting new example code.

Hoon 101 started with students with little to no programming experience. Hoon 201, which is just getting underway, covers more advanced topics. We’re quite curious to see what comes out of it.

We’re also adding features to Landscape to make it more amenable to use by Hoon Schoolers. Good examples include code evaluation within Chat (for office hours), and the ability to pin posts in Publish. The next crop of Hoon learners will be able to use Urbit to learn about Urbit.

Aside from Hoon School we’re always updating our documentation. Most notably, we added search to the docs (finally). This was a much needed feature that makes the docs much more usable.

We also launched our [grants program](https://grants.urbit.org/) quietly, but all of our available bounties were quickly claimed nonetheless. We’re ready to give away more address space to contributors and are excited by how quickly people got involved.

We also did some experimentation with holding events on Arvo. We held weekly AMAs for while, and hosted a few meetings with the community. With the new UI out, our public channels have been a lot more active. We’ll surely be holding more on-urbit events in the future — but for the time being the conversation in urbit-help is a lot of fun.

**Q4 2019**

- Vane level documentation
- An active grant program

## urbit.org

Urbit.org is about ready for a refresh — so we’re in the process of rebuilding it. We have, for a long time, told the story of Urbit by describing the system technically. We think Urbit can be explained much more simply and much more concisely. We’re working to put together a new set of materials in this direction.

We’d also like to populate urbit.org with a lot more content about what we’re working on and thinking about. We do a reasonable job of writing updates, but many of our projects get released without any background info. Tlon and the Urbit community are full of smart, thoughtful people — and we’d like to do a lot more to surface their work. We plan to close out the year with both a new website and a lot of writing about what we’ve been building. Not everyone wants to read the source code!

That covers it for now. If you have questions or want to chat — find us in `~dopzod/urbit-help`. See you online!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Landscape: A Portrait]]></title>
            <link>https://urbit.org/blog/landscape-a-portrait</link>
            <guid>https://urbit.org/blog/landscape-a-portrait</guid>
            <pubDate>Mon, 02 Sep 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/landscape-a-portrait-1.png)

Alongside [the v0.8.0 launch](https://urbit.org/posts/2019-7-25-update/) we released the latest version of Landscape – Urbit's prototype user interface. Codenamed “Modulo,” it's our vision of an Urbit UI designed for everyday use. Most importantly, it’s the beginning of an interface that has access to the entire Arvo OS, rather than just one facet. Previous iterations of Landscape solely made use of the [Hall](https://urbit.org/docs/learn/arvo/hall/) messaging protocol.

Served after installation on your ship’s HTTPS port, it allows you to interact with Arvo through a web interface built with [Indigo](https://github.com/urbit/indigo), our new UI design language. It has a home screen, which exposes ‘tiles’ for each Landscape application – each able to integrate and customise information from elsewhere in the system and from the broader internet – and connects them to full-screen, graphical applications.

The first set of application includes Chat, a new, streamlined chat client, a basic Weather information tile, an analog clock, and Publish, a place for publishing, subscribing, and commenting on ‘notebooks’ – invite-oriented blogs hosted on your ship.

![](https://media.urbit.org/site/posts/essays/landscape-a-portrait-2.png)

![](https://media.urbit.org/site/posts/essays/landscape-a-portrait-3.png)

Our unofficial mantra – “it’s not finished yet” – is performed yet again, but we're _close_. We can now talk with the broader community about both our inspirations, our visions for its future and our plan to enact that future.

## Entering userspace

Urbit has been in “research mode” for most of its history, but the system has now made extensive progress and our kernelspace engineers are the opinionated, confident veterans of the long war you’d expect from an operating system’s early history. The spoils of that war, after rewriting and refactoring all of the system's components several times over, are beginning to really speak for themselves.

Urbit’s kernel is graduating from its rebellious period, however its _userspace_ has remained embryonic for most of its history. The project of building an application model has been restarted and rescoped into _aspects_ that could weather the chaotic growth of the kernel, but it would never quite serve as an interface to the entire operating system. Due to one of our latest vane refactors, it’s becoming possible to start that work in earnest.

Alongside the latest release of Landscape came the rewrite of the [`%eyre`](https://urbit.org/docs/learn/arvo/eyre/) vane, which serves a ship’s files and applications over HTTP. Among the improvements came the decision to move from serving from one ‘/web’ folder by default to an application-specific endpoint.

That is, a Hoon application, upon being started, now tells Eyre it wants to serve _these files_ at _this endpoint_ over HTTP and Eyre facilitates that.

Landscape, with this in mind, serves at the root endpoint (you know, at `/`). It pre-authenticates the user and provides an API to your ship for applications (and their tiles) to access and _poke_, _peer_ and _scry_ the ship with.

![](https://media.urbit.org/site/posts/essays/landscape-a-portrait-4.png)

Whereas, before, a ship had a web server that was good at serving text, but was more obscure for complex (or graphical) applications that made use of the Arvo OS and network, now a ship launches with a web-based interface that makes applications much simpler to experiment with and develop.

If you want, you can just serve files at any endpoint with [a boilerplate](https://github.com/matildepark/urbit-static-page).

What's more? Arvo access and Hoon logic are now, by default, inside their own application on the ship itself rather than served as inline code on the front-end. This allows for better separation of concerns and more complex and performant applications.

(If you want to play around, there’s an [experimental tool](https://github.com/urbit/create-landscape-app) you can use to get a full-stack boilerplate running in about 40 seconds.)

All of this is fantastic news; and while Landscape-oriented userspace development is now _possible_, it’s still not all the way to being an interface to _an operating system_. For that, we’ve started drawing up specifications and proposals.

## Rethinking interfaces

Among the inspirations for our team are [the tales of Andy Hertzfeld](https://www.folklore.org/StoryView.py?project=Macintosh&story=Were_Not_Hackers!.txt), working on the Macintosh, and ongoing [discussions](http://doc.cat-v.org/plan_9/4th_edition/papers/812/) and [decisions](https://research.swtch.com/help.pdf) that went into Plan 9 from Bell Labs. (Sometimes, for fun, we also watch videos about [the Xerox Alto](https://www.youtube.com/watch?v=tngrLvyiNEI).)

These inspirations share that their creators were dealing with really primordial stuff – the font of human-computer interface had really just sprung and they were _seeing things no one had seen before_ because they _had to_.

Doing that now, after a lifetime of reflexive familiarity with the dominant solutions – from Apple’s macOS to Google’s Material Design – we have to do the work of _unseeing_. By engaging with what it was like to see for the first time, we get closer to seeing with fresh eyes. We work to avoid implicitly categorising the new territory as simply, well, comparative to the old one.

So, while it’s not the same to simply _read_ these dialogues, it can get us pretty close.

One reason this iteration of Landscape isn’t the last is because – we must emphasise – this is not the only interface Urbit will have. We aren’t creating a web platform. It should be possible to use _just_ the command-line, and ideally it should be possible to serve windowed interfaces from Arvo itself. It should be possible to SSH into _and_ SMS with your ship, should you want to.

After all, we’re creating a decentralised platform of personal servers with an entirely new stack from the bytecode up. Most of the world’s computers descend from Unix, and Unix was based on [timesharing](https://en.wikipedia.org/wiki/Time-sharing) — multiple users in one computer, all pretending it was theirs. Everything since hasn’t left that mindset.

So what do we think that new platform needs from its interface?

- **Landscape, and all of Urbit’s future interfaces, need a standardised way to view and edit the filesystem.** We had circumnavigated this by mounting to Unix, but it’s now time to confront that issue.

- **Landscape, and all of Urbit’s future interfaces, need a way to easily organise around _cohorts_ of ships, or _groups_,** with shared applications or files and a socially-oriented computing experience in turn — [something always in the vision](https://urbit.org/posts/azimuth-is-on-chain/#aegean), but not quite implemented yet.

- Lastly, **Landscape, and all of Urbit’s future interfaces, need a userspace-specific, software design pattern** to integrate all of this: access to the file system, permissioning shared sets of files, and tying it together, an underlying representation of both data and interface amongst many computers.

No more siloed input/output in applications on a ‘timeshared computer’ with your redundant data always belonging to someone else.

## Into the future

Right now, Landscape applications are still _monolithic_ and geared exclusively toward _single-person computing_. We hope to change that, and keep communication open with developers so it’s easy for their own development to keep pace with ours.

It should be easy to share whatever data with your friends as you like; to permission files programmatically on a server that is permanently, irrevocably _yours_.

It should also be easy to read, annotate and discuss a shared book with a specific set of friends; or only allow another set of people to see files in a specific directory if they meet specified requirements.

We will backport these exploratory developments into Landscape as they continue and evolve. This, of course, includes kernel work, as we refactor [Gall](https://urbit.org/docs/learn/arvo/gall/), the userspace handler vane, and in the process, standardise streamlined practices for writing Hoon in user applications. Take, for example, the [async monad](https://groups.google.com/a/urbit.org/forum/#!topic/dev/DDG6gHSG1Lc), which allows you to avoid dealing with moves or handling each response in separate parts of the application. User applications and Hoon should be both laconic and accessible, and we’re reifying that.

Most importantly, we’ll continue to iterate on how we onboard new developers. [Hoon School](https://urbit.org/hoonschool) continues to evolve; its first cohort is thriving and friendly. We have a dedicated cast of teachers and ongoing access to much of the Urbit team through this stream.

If you’d like to join us here, you’ll discover a computer that you can learn and master from the bottom up. Right now, it is a labyrinth for the intrepid; but for the future, and forever, it is _mappable_. A landscape, after all, doesn’t show a single leaf, but the earth and the horizon ahead.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Announcing: Urbit Grants Program]]></title>
            <link>https://urbit.org/blog/announcing-urbit-grants</link>
            <guid>https://urbit.org/blog/announcing-urbit-grants</guid>
            <pubDate>Mon, 05 Aug 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
We’ve long been grateful for the hard work of our open-source community, so we’re pleased to announce Grants, a program that gives contributors the opportunity to be compensated for their efforts. It’s in beta right now at [grants.urbit.org](https://grants.urbit.org/).

The Grants program will reward valuable contributions with Azimuth stars in one of three ways: Gifts, Bounties, and Proposals.

### Gifts

We’ve periodically announced gifts for important contributions to the project – like in [2018](https://urbit.org/posts/2018-2-17-update/) and [2019](https://urbit.org/posts/urbit-grants-and-mid-2019-gifts/) – but we wanted to make this more formal.

Not everyone always works on structured projects, so the lack of formal criteria for receiving a gift is meant to reward contributors who work outside of the bounty and grant system.

Going forward, gifts will be awarded semi-annually (every six months). They’ll retain the informal and arbitrary nature of the awards that came before: Tlon will determine who gets what. We’ll work hard to make sure these payouts are fair.

To see the gifts that have been awarded so far, check out the [History section](https://grants.urbit.org/history) of the Grants website.

### Bounties

Bounties are discrete projects in search of a champion. Tlon will define a clear deliverable, and some number of stars as their reward. Larger bounties will often have their star reward spread across multiple milestones.

Contributors can apply to claim a bounty by clicking the “Request to work on this” button. Once a contributor is selected to work on a bounty, nobody else will be able to apply.

Bounties are listed in the [Bounties explorer](https://grants.urbit.org/rfws). Play around with the explorer by filtering bounties using the Tag and Category features.

### Proposals

Proposals are a way for contributors to pitch their own ideas, with a targeted number of stars. Proposals can be accepted, rejected, or accepted with changes. Unlike bounties, a proposal can only be completed by the individual or group who submitted it.

Proposals don’t need to be fleshed out like a bounty does, at least not initially. Submit an idea and Tlon will work with you to refine it.

You can see the list of accepted proposals in the [Proposals explorer](https://grants.urbit.org/proposals).

### What can you do?

[Sign up](https://grants.urbit.org/auth/sign-up) on our Grants website page, then set up your profile so we know who you are, linking your GitHub, Twitter, and your Azimuth point: reputation is a factor in determining eligibility for a grant.

Also, check out the [Grants section](https://urbit.org/faq/#grants-1) of the new Urbit FAQ for more information.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.7.25 Update]]></title>
            <link>https://urbit.org/updates/2019-7-25-update</link>
            <guid>https://urbit.org/updates/2019-7-25-update</guid>
            <pubDate>Wed, 24 Jul 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2019.7.25-update-1.jpg)

We released Urbit `v0.8.0` this week and breached the network. See the [release notes](https://github.com/urbit/urbit/releases/tag/v0.8.0). The Arvo sourcecode – previously in its own repository – has been merged into the [Urbit repository](https://github.com/urbit/urbit), and Urbit now builds with [Nix](https://nixos.org/nix/).

Amongst many exciting improvements and overall greater network stability, `v0.8.0` comes with a [new version of Landscape](https://github.com/urbit/urbit/tree/master/pkg/interface), which provides a framework for writing new apps and feels much more like using the operating system Urbit is.

We ran into a slew of issues with the network after launch, which were fixed in part thanks to a modification to Vere that allows [direct event injection](https://github.com/urbit/urbit/pull/1389), thanks to **Philip** `~wicdev-wisryt`. You can find `~zod.2019.7.23` relase notes [here](https://github.com/urbit/urbit/releases/tag/zod.2019.7.23).

**Jared** `~nidsut-tomdun` now the maintainer and release-manager of [Urbit](https://github.com/urbit/urbit), spent much of the past few weeks testing and then shepherding `v0.8.0` out the door.

**Joe** `~master-morzod` has also been preparing `v0.8.0` for release, fixing numerous bugs, and simplifying Urbit's automagic DNS (`*.arvo.network`). He's also been looking into integrating [Jaque](https://github.com/frodwith/jaque) – a Graal/Truffle Nock interpreter intended to replace much of Vere – and an [`:acme`](https://github.com/urbit/urbit/blob/master/pkg/arvo/app/acme.hoon) rewrite.

**Philip** `~wicdev-wisryt` has been working on replacing `%jael` with [`%kale`](https://github.com/urbit/urbit/tree/philip/kale) and `:eth-watcher` with [azimuth-tracker](https://github.com/urbit/urbit/pull/1320).

**Ted** `~rovnys-ricfer` has made great progress integrating new `%ames` ["alef"](https://github.com/urbit/urbit/tree/alef-breach). It can nearly say `|hi` to itself.

**Elliot** `~littel-ponnys` has been working on an example social application that makes use of ring signatures in Arvo, called ["Safe"](https://github.com/urbit/urbit/tree/safe-prototype).

**Ben** `~pitmug-roptec` has been [rewriting](https://github.com/urbit/urbit/tree/bs/uterm/pkg/hs-urbit/lib) Vere's 'daemon' process – the part that interfaces with the host system – in Haskell toward improved maintainability. He's also working on a new language, called [Conq](https://github.com/urbit/urbit/blob/bs/conq-attila-hoon/pkg/hs-conq/lib/Language/Conq.hs).

**Mark** `~palfun-foslup` has been working on next-gen [Bridge](https://github.com/urbit/bridge/tree/mino) with **Matt** `@shrugs`, and [Peerlist](https://github.com/urbit/urbit/pull/1309), a mechanism for peer-discovery on the network.

**Isaac** `~novlud-padtyv` and **Logan** `~tacryt-socryp` shipped the [new Landscape](https://github.com/urbit/urbit/tree/master/pkg/interface), which features a brand-new interface designed around an OS-like home screen and the ability to integrate new applications. Landscape too [has been merged](https://github.com/urbit/urbit/pull/1367) into the Urbit monorepo.

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Azimuth Security Bounty Program]]></title>
            <link>https://urbit.org/blog/azimuth-security-bounty-program</link>
            <guid>https://urbit.org/blog/azimuth-security-bounty-program</guid>
            <pubDate>Sun, 21 Jul 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/azimuth-security-bounty-program-1.jpg)

Since launching [Azimuth](https://urbit.org/posts/azimuth-is-on-chain/), we’ve been running a private bounty program with [HackerOne](https://hackerone.com/). We’re now taking the program public and inviting you (and your friends) to help us make Azimuth as secure as possible.

[Go here](https://hackerone.com/tlon) to see the live program on HackerOne.

## What is Azimuth again?

Azimuth is [the Urbit public key infrastructure](https://urbit.org/posts/azimuth-is-on-chain/). It’s a set of Ethereum smart contracts that allow for cryptographic ownership and management of Urbit identities. It also provides a governance mechanism whereby galaxy owners are able to propose and vote on improvements.

People already [use Azimuth](https://github.com/urbit/bridge) to boot Arvo ships, spawn stars and planets for others and transfer points. But Azimuth is a general identity system, with great potential to be used beyond Arvo: there are primitives for reputation, payments and securing communication channels.

## Security program details

We had the Azimuth contracts audited by [Open Zeppelin](https://openzeppelin.org/), [Blockchain at Berkeley](https://blockchain.berkeley.edu/) and [Bloctrax](https://www.bloctrax.com/), but we don’t want to take any chances. We’re hoping that the HackerOne program will help us get more eyes on the contracts, identify vulnerabilities and get out in front of any problems. You can find more information about the program at [our page](https://hackerone.com/tlon) on HackerOne.

We’re interested in any vulnerability in the Azimuth contracts that would allow an attacker to either seize other user’s points, impersonate points or that would result in the platform becoming unusable.

The program page has links and instructions on how to set up a development version of Bridge and point it at either the Ropsten deployment of the contracts or at a local network to play with the contracts and look for vulnerabilities.

## Arvo is out of scope for now

We’re intentionally focusing our security efforts on Azimuth for now. Since Azimuth serves as our PKI layer, it’s the most crucial for the time being: it’s the source of truth for who owns what. We don’t want to have even a shred of a doubt that these cryptographic properties are secure.

Of course, we’re working toward a future where you have a computer connected to this Azimuth point, and the computer has to be as secure as its identity. To achieve this, we have some more hard work to do on Arvo and our interpreter, Vere. When the time comes, we’ll also reach out for help testing vulnerabilities throughout the entire stack.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.6.14 Update]]></title>
            <link>https://urbit.org/updates/2019-6-14-update</link>
            <guid>https://urbit.org/updates/2019-6-14-update</guid>
            <pubDate>Thu, 13 Jun 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2019.6.14-update-1.jpg)

**Jared** `~nidsut-tomdun` has been putting final touches on the Urbit `0.8.0` (formerly "cc-release") and pushed new versions of [azimuth-js](https://github.com/urbit/azimuth-js/releases) and [urbit-key-generation](https://github.com/urbit/urbit-key-generation/releases).

**Philip** `~wicdev-wisryt` improved his new async monad and its example apps. Read more about that [here](https://groups.google.com/a/urbit.org/forum/#!topic/dev/DDG6gHSG1Lc) and in the [original PR](https://github.com/urbit/arvo/pull/1183).

**Ted** `~rovnys-ricfer`, with **Philip**, made progress on new `%ames` architecture and implementation. Follow along with some of the recent discussion in [this post](https://groups.google.com/a/urbit.org/forum/#!topic/dev/y_gaSpn9mxM).

**Elliot** `~littel-ponnys` finished an initial implementation of ring signatures in Arvo, including a basic voting app, described in a [post](https://groups.google.com/a/urbit.org/forum/#!topic/dev/IG-FdVpEGX0) to urbit-dev. He also worked on a forthcoming Haskell rewrite of Vere with `~pitmug-roptec` and his multi-process Urbit "Nuevo" design.

**Joe** `~master-morzod` worked on some Hoon bugs, reviewed the `lighter-than-eyre` branch – which won't be released in 0.8.0 – and has been working to simplify the DNS magic that makes ship.arvo.network work.

`~rigdyn-sondur` is on the home stretch with [64-bit Vere](https://github.com/BernardoDeLaPlaz/urbit/commits/vere_64).

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit Grants and mid-2019 Gifts]]></title>
            <link>https://urbit.org/blog/urbit-grants-and-mid-2019-gifts</link>
            <guid>https://urbit.org/blog/urbit-grants-and-mid-2019-gifts</guid>
            <pubDate>Sun, 09 Jun 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/urbit-grants-and-mid-2019-gifts-1.jpg)

We are excited to announce the first developer star gifts of 2019. It’s been far too long since we last awarded our contributors. We got so busy working on things ourselves that we let this program languish — but we’ve got plans to make it much more organized going forward. More on that after the important part.

That is, our winners from the past nine months:

**Gold: 8 stars**

- Ben `~mirfet-hocbyt` [@bencalder](https://github.com/bencalder)
- Max `~ladres-forfex` [@max19](https://github.com/max19)

**Ben** discovered the bug in our @p rendering algorithm, nicknamed “the @pocalypse” around the office, and led to a few nights of lost sleep. It was a fantastic find, which was then resolved by **Max** with one of the greatest GitHub comments of all time: “[curious if this works](https://github.com/urbit/arvo/issues/1105#issuecomment-472585937).”

**Bronze: 1 star**

- Pyry `~dinleb-rambep` [@pkova](https://github.com/pkova)
- John `~dirwex-dosrev` [@jfranklin9000](https://github.com/jfranklin9000)
- Assaf `~rophex-hashes` [@asssaf](https://github.com/asssaf)

**Pyry** has been a [regular contributor](https://github.com/urbit/bridge/pulls?utf8=%E2%9C%93&q=author%3Apkova) to Bridge over the past few months, **John** has been consistently picking up changes [all](https://github.com/urbit/urbit/pulls?utf8=%E2%9C%93&q=author%3Ajfranklin9000) [over](https://github.com/urbit/arvo/pulls?utf8=%E2%9C%93&q=author%3Ajfranklin9000) [the place](https://github.com/urbit/docs/pulls?utf8=%E2%9C%93&q=author%3Ajfranklin9000), and **Assaf** found a [security issue](https://github.com/urbit/urbit-key-generation/issues/55) with our hierarchical wallet.

Thanks to all of you for helping bring Urbit to life. We don’t make it nearly easy enough to contribute, but all of you clawed your way in and made the system better. Thank you!

## Coming soon: Our new grant program

As always, we much prefer to talk about working code as opposed to unfinished work – however:

Making the process of rewarding contributors is something we’ve thought a lot about over the past few months. We’ve come up with a system that we like, and are hoping to put it up later this summer. It’s probably not perfect, but it’s a step in the right direction. We’ll be able to properly engage in a grant proposal process, post bounties as well as reward people directly with prizes.

Please [subscribe to our newsletter](http://eepurl.com/b7x7hj) to make sure you receive future announcements.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.5.31 Update]]></title>
            <link>https://urbit.org/updates/2019-5-31-update</link>
            <guid>https://urbit.org/updates/2019-5-31-update</guid>
            <pubDate>Thu, 30 May 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2019.5.31-update-3.jpg)

**Logan** `~tacryt-socryp` has been working with **Isaac** `~novlud-padtyv` on a new chat interface to replace Landscape and recently finished a chat wrapper API on top of Hall that enables significant performance gains, simplifies the API, and enables fine-grained unread counts per chatroom.

**Ted** `~rovnys-ricfer` published [an initial new Ames proposal](https://groups.google.com/a/urbit.org/forum/#!topic/dev/91oMaUwtVzE) to [urbit-dev](https://groups.google.com/a/urbit.org/forum/#!forum/dev) and abandoned the `aloe` branch for [`alef`](https://github.com/urbit/arvo/tree/alef), where the initial few thousand lines of code have now been checked in.

**Joe** `~master-morzod` worked on the DNS magic behind `arvo.network`, jet compilers with `~pilfer-pandex`, `cc-release` argument parsing, and rewrites of cue and mug.

**Elliot** `~littel-ponnys` finished a draft design of his multi-process Arvo "nuevo" design.

**Mark** `~palfun-foslup` [merged](https://github.com/urbit/azimuth/pull/17) support for delegated sending from arbitrary stars in Azimuth.

**Jared** `~nidsut-tomdun` released azimuth-js `v0.14.0`, pushed azimuth-solidity `v1.2.0` to NPM, continued work on `%gall`, and has been readying `cc-release`.

**Morgan** `~hidrel-fabtel` has been reaching out to community members. If you're interested in talking with us about your experience with Urbit so far and what you'd like to see in the future, please let us know at [support@urbit.org](mailto:support@urbit.org).

In other news, the [urbit-dev](https://groups.google.com/a/urbit.org/forum/#!forum/dev) mailing list has been lively, [urbit.org](https://github.com/urbit/urbit.org) now deploys automatically thanks to Netlify, and we're getting ready to breach the network for [cc-release](https://github.com/urbit/urbit/tree/cc-release) next week. Follow [@zodisok](https://twitter.com/zodisok) for updates.

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.5.17 Update]]></title>
            <link>https://urbit.org/updates/2019-5-17-update</link>
            <guid>https://urbit.org/updates/2019-5-17-update</guid>
            <pubDate>Thu, 16 May 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2019.5.17-update-1.png)

— from [Marabu](https://hundredrabbits.itch.io/marabu) by [Rekka & Devine](https://hundredrabbits.itch.io/)

**Ted** `~rovnys-ricfer` and **Philip** `~wicdev-wisryt` continued work on new `%ames` in the [aloe](https://github.com/urbit/arvo/tree/aloe) branch, **Elliot** `~littel-ponnys` has been designing a new, multi-process Arvo, known as "nuevo," and implementing primitives for ring signatures in Arvo, **Joe** `~master-morzod` finalized cc-release and started toward finishing new `%eyre`, ongoing in the [lighter-than-eyre](https://github.com/urbit/urbit/tree/lighter-than-eyre) branch, and **Mark** `~palfun-foslup` pushed [Bridge v1.4.1](https://github.com/urbit/bridge/releases).

In other news, the **Interface Team** started a [Twitter account](https://twitter.com/urbitwip) to share work in progress, there's been lively discussion on [urbit-dev](https://groups.google.com/a/urbit.org/forum/#!forum/dev), and we published [a roadmap](https://urbit.org/posts/2019-5-roadmap/).

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.5 Roadmap]]></title>
            <link>https://urbit.org/blog/2019-5-roadmap</link>
            <guid>https://urbit.org/blog/2019-5-roadmap</guid>
            <pubDate>Wed, 15 May 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/2019-5-roadmap-1.png)

We often get so busy that we forget to tell you what we’ve been up to. Here’s an update on what we’re doing and where we’re headed with each layer of the stack.

At a very high level we have two goals for 2019: make Azimuth easier to use, and get Arvo to a 1.0.

Next year we’ll begin to move away from some of the MEGACORP software we use in the office, and replace it with our own tooling. There’s some exciting work happening in that department, but we’ll cover that in a future post.

For some related recent thinking on all of this, see [The 100 Year Computer](/posts/essays/the-100-year-computer/), [The State of Landscape](/posts/essays/the-state-of-landscape/) and [Azimuth as MultiPass](/posts/essays/azimuth-as-multipass/).

For now, let’s just look at what’s on the immediate horizon:

## Azimuth

At lunch the other day someone on our team said something like, ‘We built a complete and working public key infrastructure, but we haven’t told anyone.’

It’s true. Azimuth is operational, secure, and well tested. It’s a pretty cool piece of technology and it’s out there in the world for anyone to use. It also doesn’t require that you use Arvo — Arvo happens to make use of Azimuth, but Azimuth itself is a completely separate system.

So the question is why haven’t we told the world about it?

I tend to think that in order for a technology to succeed it has to not only be an important technical innovation, it also has to be easy to understand as a product. And that’s our answer: we’ve undersold Azimuth because we want it to be easier to understand by _using_, not just by reading the code. Azimuth is quite an elegant piece of technology — but that doesn’t matter until it has a great user experience to match.

That’s why, in the near term, we’re focused on building on top of Azimuth ourselves. We can’t ask others to go down roads if we haven’t already been down them.

Here’s what we’re building first:

### Q2 2019

- A simplified onboarding flow for getting an Azimuth point that’s simple to share with friends over email, text or as a URL.
- A redesigned and improved Bridge for managing your points.
- An interface that allows you to easily send money between Azimuth points without running Arvo.

### Q3 2019

- Expanded Azimuth-centric example modules, documentation and developer tooling.

Still under consideration:

- An OAuth server or JWT flow for logging into any service with an Azimuth point.
- A mobile app for point to point payments using Azimuth.

### 2020

Azimuth is beginning to feel like [multipass](/posts/essays/azimuth-as-multipass/), with a variety of ways to use Azimuth points without ever booting Arvo

## Arvo

The Arvo interface has always been held back by Arvo’s technical immaturity. This is still true to some degree. The system has not stabilized completely.

But! We’ve been using Landscape quite a lot lately. I use it daily, in fact — even [on my phone](https://itunes.apple.com/us/app/landscape-urbit/id1393148862). An encrypted (although not audited — so let’s not call it ‘secure’), authenticated chat where I own the keys and can read the source code feels really nice to use. The interface isn’t as good as we’d like, but it’s not bad. Landscape is a great preview of where we’re going: a simple, permanent, self-sovereign computer.

There are still rough edges, and Landscape is not nearly general purpose enough, but we have plans:

### Q2 2019

- A new update to the Arvo interface that we’re calling Modulo. Modulo expands beyond chat and longform discussion to make your Arvo interface feel much more like the computer it actually is.
- Upgrades to our event persistence, networking, and DNS integration aimed at much better stability. Arvo instances don’t crash that often, but with these changes it should be very rare.
- Significant improvements to testing with a new simulation testing framework and integration testing pipelines.

### Q3 2019

- A significant overhaul to Gall, our application model, making it much simpler for users to write apps or ‘agents’ in Arvo.
- A new version of the compiler that makes us less reliant on jets. This will eliminate a major obstacle to achieving network continuity, or the ability for ships to upgrade themselves totally over-the-air, forever.
- A significant overhaul and stability update to Clay, our filesystem, making it possible for us to trust it for self-hosting, search it easily, and depend on it for long-term data storage.
- Tooling for hosting and hopefully a beta program for hosted Arvo instances run by Tlon.

### 2020

- A completely overhauled Arvo interface, Daigo, with a complete but simple set of messaging and collaboration tools. Modulo is meant to be fun to experiment with, but we aim to make Daigo part of our daily workflow.
- We come to work every day, use Arvo, go home.

## Community

We’ve often felt like it was far too early to invite others in to the system.

As long as we’re up front about the state of this 100 year computer -- that it’s live, but incomplete — I think it’s a good thing to welcome people on board. There’s plenty to play with, experiment with and explore.

Hoon school was the first effort in this direction. We intend to do a lot more:

### Q2 2019

- Scaling Hoon school up to include both a track for experts and for beginners, and allowing many more participants.
- Holding more meetings and events on Landscape, experimenting with Arvo-native discussion.
- A clear program for address space grants for developers + contributors.
- New documentation site with searchable library docs.

### Q3 2019

- Hoon School participants understand clearly how to build a Modulo agent, and invite others into it.
- The road toward building an Azimuth module is well understood, paved, and clear.
- We have clear instructions and tutorials for building Azimuth modules and using Azimuth as a login or reputation primitive.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Azimuth as Multipass]]></title>
            <link>https://urbit.org/blog/azimuth-as-multipass</link>
            <guid>https://urbit.org/blog/azimuth-as-multipass</guid>
            <pubDate>Wed, 15 May 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/azimuth-as-multipass-1.png)

Why can’t I just walk up to a door and have it open for me? Why can’t I simply arrive at a restaurant and have them know I’m there? Shouldn’t I be able to buy a ticket to a show with my Multipass then scan it at the entrance and use it to buy drinks?

Why should I have to log in with MEGACORP? Today, in most cases, it’s a different MEGACORP for every single context. It’s a MEGAMESS.

Why not just use one? Forget about how we get there for a moment: just imagine how simple it could be.

An Azimuth point is an identity and a wallet. Both a driver’s license and a credit card. Identity and money. Think about it as a ‘civilizational key’ for a new society. Concretely, it’s nice to imagine it as a physical object. A slick, card sized object with an e-ink screen. You can tap it to pay, tap it to enter, and plug it into a computer to boot your Arvo OS.

Worried about losing it? Just remember your ticket. If you use our wallet system, all you need to remember is something like `~ravmel-ropdyl` and `~habpem-sondem-pidbyt-solbyn`. A point and a ticket. That’s it.

Woke up in the desert, no idea how you got there, but can still remember your point and ticket? Great! Just get to an internet connection and re-ticket – you’ll be fine. Although probably dehydrated.

If you’re someone who’s worried about getting kidnapped, just use a child identity. Your Azimuth planet has ~4B of them, so you can always invalidate one if you lose it.

Perhaps part of how we ended up in the world we’re in is that we didn’t have something like Azimuth to begin with. Today, it’s backwards: everyone has an address on the network, but no one has an identity.

We think everyone needs an identity that can hold money and have packets routed to it. Start there, and it’s quite fun to imagine where you end up. A civilized digital society might even be possible after all.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The State of Landscape]]></title>
            <link>https://urbit.org/blog/the-state-of-landscape</link>
            <guid>https://urbit.org/blog/the-state-of-landscape</guid>
            <pubDate>Wed, 15 May 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/the-state-of-landscape-1.png)

The TL;DR is: if you’re really excited about living on Mars, Landscape is fun to try out. Come join `~dopzod/urbit-help`, experiment with creating your own chats and collections (did anyone find that easter egg, yet?), and see what you can do with the thing.

Landscape today is for the intrepid adventurer. So is much of the system. If you want to read about what we’re doing to make it more welcoming, [check out the 2019 roadmap](/posts/essays/2019-5-roadmap/).

## The Broad View

We thought a lot last year about how to avoid the pitfalls of modern social networks. The services we all use today each feel like _one place_. It’s as if everyone on MEGANET is living together in the same city.

In the real world, cities have their own cultures. So we thought: there must be some way to build more granular communities online. Living in a single world-city is kind of a bummer, honestly.

Landscape was our first experiment in this direction. It’s a ruthlessly simple interface for chat and discussion that runs on top of Arvo. You can connect to Landscape in a browser or in an app on your iOS device. All communication is pseudonymous and authenticated (as with everything in Arvo) with your Azimuth point.

Over the past few months, we’ve been running small experiments, experimenting with ways to support our own work and finding the limits of what we can do on the network. Originally, we built Landscape out of our desire to get away from using MEGACORP communication tools in our daily work. We thought: if we’re trying to build a whole new network and society, we had better go live there first.

Landscape is an experiment — it’s supposed to be fun, above all, and a good way to help focus our efforts on maturing the platform.

Anyway, let’s show off some of the specifics, and give an update on this experiment so far.

## A Quick Tour

Landscape is pretty simple. It lets you subscribe to chats, in the spirit of IRC, and ‘collections’, which are effectively forums or blogs with comments. You can also direct message with other running ‘ships’ or Arvo nodes.

For the most part, this happens through a web interface that you can access at `https://ship.arvo.network` or via `localhost:80`.

There’s also an iOS app, [available in the app store](https://itunes.apple.com/us/app/landscape-urbit/id1393148862), that you link to your ship the same way you log in through a browser.

## Landscape: The Bad Parts

What’s keeping us from asking others to use this thing more aggressively? Let’s walk through the reasons (while keeping in mind, they’re all [things we’re working on](/posts/essays/2019-5-roadmap/)):

### 1 - Arvo has rough spots

They have gotten a lot better, but there are still a few things that can crash your Arvo ship. This, of course, has nothing to do with your Azimuth point, which is completely separate and, as far as we know, secure.

The first (and most severe) is a bug in our event persistence that occurs very rarely. Basically, there are conditions under which you can cause events not to be properly written to disk and corrupt your event log. It’s pretty unlikely, but it’s unacceptable for a real product since it basically causes you to have to wait out the current network era.

The second is that Ames (our network protocol) has occasional connectivity problems. Originally, we thought we had found this issue as being related to [a timer bug](https://github.com/urbit/arvo/pull/1072). It may be, but the networking is in the process of a major overhaul — so we’ve implemented a few bandaids to make the situation workable. `|bonk` sometimes needs to be used to reset connections between peers, and `:ethmanage` sometimes need to be used to re-synchronize with the blockchain. It’s an ugly fix, but it usually works.

Relatedly, we have occasionally been seeing errors caused by the Arvo network being slow to register keys from the blockchain. If you’re a newly registered Azimuth point, and your keys were just put on-chain, it can take some time for that change to propagate. This can result in a confusing situation for new ships.

### 2 - There’s no ‘individual continuity breach’

One great thing about the Arvo network is that it’s more like a giant single computer than a network. When you talk to another ship, use remote files or sync data it’s almost the same as working with local data.

The main thing underlying this is _sequence numbers_. Your Arvo ship keeps track of every message it has exchanged with every other ship, and it never breaks that sequence. If our ships are talking, and we’re on packet `83910` but you reset and try to start again at `0` my ship just thinks you’ve lost your mind and won’t talk to you anymore.

We’d like individual resets to work, and we’re [working on it](https://github.com/urbit/arvo/pull/1169). But, for the time being, if you have any fatal error on your ship, it means you’ve got to sit this era out.

This is another unacceptable bug for anything we truly rely on.

### 3 - There are no push notifications, yet

What’s one thing that a chat application needs to do? Notify you of new messages. What does Landscape notify you about? Well, at the moment, basically nothing.

We implemented and tested a push notifications server for iOS, which is slated for release in the next few months (it depends on things in our `cc-release` branch). We’d also love to work on having your ship connect to your email provider and send you alerts over email. We’re thinking about how to do that.

## What We’ve Learned and What We’re Doing

Many of us spend all day on Landscape, use it from our phones, and find it really fun. The bugs above bite less than you might think and, in many cases, the experience is quite nice. It’s a passive, distraction-free way to interact with others around the office.

We operate one public channel, `~dopzod/urbit-help` for answering any of your questions about the system. And, from time to time, we have been creating topic-centric channels and announcing them publicly. This has been a lot of fun. Come join us if you’re feeling brave.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The 100-Year Computer]]></title>
            <link>https://urbit.org/blog/the-100-year-computer</link>
            <guid>https://urbit.org/blog/the-100-year-computer</guid>
            <pubDate>Mon, 13 May 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/essays/100-year-computer-1.png)

Around the Tlon office, we’re always looking for more concise ways to describe what we do. We kicked around ‘personal server’ for a long time. It’s pretty close. ‘Personal cloud computer’ did okay for a while, but it’s a little confusing.

One way to think about Urbit is as a 100-year computer.

A 100-year computer has to be durable, reliable and permanent. It has to never lose data or fail in unpredictable ways. It has to be continuous, meaning it should never need to be updated by the user. If I put it in a closet for 10 years and take it out, it should work again without any intervention.

And, perhaps most importantly, it should be easy and enjoyable to use. Both for a casual user and for a technical person. If it’s not enjoyable to use, and doesn’t actually _get used_, it’s never going to survive for 100 years.

In theory we could all be using Apple I’s today, but they’re a bit cumbersome. In large part that’s because they don’t update themselves. Those magnetic tapes don’t strike me as particularly durable either.

Imagine that a computer was something you kept forever. It would comfortably store your entire life: your writing, photos, blood tests, even your genome. Your computer would never show you ads, interrupt you against your wishes, or send your data to someone else without your permission.

Imagine a computer that was extremely valuable to you, that you’d pay thousands of dollars to recover, but you used _less_ than the one you do today.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.5.10 Update]]></title>
            <link>https://urbit.org/updates/2019-5-10-update</link>
            <guid>https://urbit.org/updates/2019-5-10-update</guid>
            <pubDate>Thu, 09 May 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2019.5.10-update-1.jpg)

**Ted** `~rovnys-ricfur` is rewriting `%ames`, Urbit’s encrypted peer-to-peer messaging protocol, in the [“aloe”](https://github.com/urbit/arvo/tree/aloe) branch. **Philip** `~wicdev-wisryt` has been working on a `bind` rune, [monadic pH tests](https://github.com/urbit/arvo/pull/1152), and `%ames` [“aloe”](https://github.com/urbit/arvo/tree/philip/aloe) with **Ted**. **Jared** `~nidsut-tomdun` is reworking `%gall` and has been pushing [Bridge](https://github.com/urbit/bridge/releases) updates with **Mark** `~palfun-foslup`. **Joe** `~master-morzod` has [cc-release](https://github.com/urbit/urbit/tree/cc-release) – the next major version of Urbit – just about ready to go. This bundles a new multi-process architecture, support for running the full bootstrap sequence, new event dispatch and persistence, a new build system, and more. **Elliot** `~littel-ponnys` merged new [event batching](https://github.com/urbit/urbit/pull/1259) (part of cc-release), which [makes Urbit performance less I/O bound](https://github.com/urbit/urbit/pull/1259#issuecomment-487785371). Finally, **Morgan** `~hidrel-fabtel` and **Alex** `~mignyt-mogseb` launched a public mailing list, [urbit-dev](https://groups.google.com/a/urbit.org/forum/#!forum/dev), a [new proposal system](https://github.com/urbit/proposals), and reimplemented [urbit.org](https://github.com/urbit/urbit.org) to enable fast builds and automatic deployment.

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.4.11 Update]]></title>
            <link>https://urbit.org/updates/2019-4-11-update</link>
            <guid>https://urbit.org/updates/2019-4-11-update</guid>
            <pubDate>Wed, 10 Apr 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here’s a short update from the team as of `~2019.4.11`:

![](https://media.urbit.org/site/posts/updates/~2019.4.11-update-1.jpg)

## Team

_Philip_ `~wicdev-wisryt` made progress on `%aqua`, simulated Arvo instances running in Arvo, and getting individual continuity breaches working, which will enable resetting of sunk ships. _Elliot_ `~littel-ponnys` and _Joe_ `~master-morzod` have been [readying](https://github.com/urbit/urbit/pull/1232) `cc-release` for release. _Ted_ `~rovnys-ricfur` has been [laying the groundwork](https://github.com/urbit/arvo/pull/1135) for future error handling and making progress on new `%ames`. _Ben_ `~pitmug-roptec` and `pilfer-pandex` continued work on Hoon's type system. Finally, _Jared_ `~nidsut-tomdun` is revamping `%gall`, currently `+mo` and `+ap`.

## Community

We conducted an Azimuth AMA and an "IDEA BLITZ" on Landscape. Excerpts from the IDEA BLITZ are collected in [a GitHub issue](https://github.com/urbit/proposals/issues/4), and archives are available at `~dopzod/azimuth-ama` and `~dopzod/idea-blitz`.

## April Fools

_Ted_ `~rovnys-ricfur` shared a [convincing argument](https://github.com/urbit/arvo/pull/1129) for uppercasing Hoon and someone launched [Urbit Classic](http://urbit-classic.org/), running 2016-era Arvo. To be clear, we don't recommend sending them Bitcoin.

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.3.27 Update]]></title>
            <link>https://urbit.org/updates/2019-3-27-update</link>
            <guid>https://urbit.org/updates/2019-3-27-update</guid>
            <pubDate>Tue, 26 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here’s a short update from the team as of `~2019.3.27`:

![](https://media.urbit.org/site/posts/updates/~2019.3.27-update-1.jpg)

## Team

_Philip_ `~wicdev-wisryt` [finished](https://github.com/urbit/arvo/pull/1120) Aquarium, which runs a virtual fleet of ships inside a host ship, and pH, an integration testing framework. `~rigdyn-sondur` [pushed](https://github.com/urbit/urbit/pull/1228) ncurses support. _Joe_ `~master-morzod` and _Elliot_ `~littel-ponnys` continued work on new `%eyre` (webserver) while Isaac `~novlud-padtyv` [integrated](https://github.com/urbit/arvo/pull/1119) Landscape. Finally, `~pilfer-pandex` and _Benjamin_ `~pitmug-roptec` made progress on a reimplementation of the compiler.

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.3.11 Update]]></title>
            <link>https://urbit.org/updates/2019-3-11-update</link>
            <guid>https://urbit.org/updates/2019-3-11-update</guid>
            <pubDate>Sun, 10 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here’s a short update from the team for the week of `~2019.3.11`:

![](https://media.urbit.org/site/posts/updates/~2019.3.11-update-1.jpg)

## `@p` Bug

The `@p` bug [is solved](https://github.com/urbit/arvo/pull/1110), thanks to [@max19](https://github.com/urbit/arvo/issues/1105#issuecomment-472585937) and _Jared_ `~nidsut-tomdun`.

## Team

_Ted_ `~rovnys-ricfer`, _Philip_ `~wicdev-wisryt`, and _Joe_ `~master-morzod` developed a proposal for formalizing the semantics around state persistence in a way that enables parallelism, event replay, and a new model for error handling. _Joe_ `~master-morzod` worked on integrating new `%eyre`. _Elliot_ `~littel-ponnys` worked on an elaborate proposal for resolving the `@p` bug involving constraint solvers, which turned out to be unnecessary, but was quite impressive nonetheless!

_David_ `~rapfyr-diglyt`, _Robert_ `~lodleb-ritrul`, and 23 students completed the first week of Hoon School. `~hadrud-lodsef` implemented automation for handling requests from the community. In the next few weeks we're looking forward to automating Urbit support, the Hoon School queue, and contributor onboarding, toward the end of allowing all of our community support systems to scale.

_Anthony_ `~poldec-tonteg`, _Jared_ `~nidsut-tomdun`, and _Morgan_ `~hidrel-fabtel` made progress on a plan to upgrade our open-source development processes. We’re moving toward making Tlon’s work more public and making it easier for contributors to get involved. As a first step, we’ve assigned maintainers for each of our repositories, and both repository guidelines and a new proposal system are in the works. _Morgan_ `~hidrel-fabtel` also started working on re-implementing the website to make content updates and external contributions easier.

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.3.04 Update]]></title>
            <link>https://urbit.org/updates/2019-3-4-update</link>
            <guid>https://urbit.org/updates/2019-3-4-update</guid>
            <pubDate>Sun, 03 Mar 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here’s a short update from the team for the week of `~2019.3.4`:

![](https://media.urbit.org/site/posts/updates/~2019.3.4-update-1.jpg)

## Network

We breached successfully. You can read about [what we fixed](https://github.com/urbit/arvo/pull/1101). Issues ocassionally crop up as people join the network, but it looks to be smooth sailing as we make our way toward [cc-release](https://github.com/urbit/urbit/tree/cc-release) and new %ames.

## `@p` Bug

The nice folks behind [@urbitlive](https://twitter.com/urbitlive) discovered a bug in `@p` leading to planet name-collisions. Due to a subtly incorrect implementation of the cryptographic algorithm we use to scramble planet names – used to dissociate them from their parent stars – a small percentage of people with different Azimuth points could end up with the same planet name. For example:

```
> `@p`3.108.299.008
~morlyd-mogmev
> `@p`479.733.505
~morlyd-mogmev
```

We [announced the bug on Twitter](https://twitter.com/urbit/status/1105850450559918082) today, and [a conversation](https://github.com/urbit/arvo/issues/1105) has been ongoing on GitHub. It appears we've settled on a solution, outlined in [this 3-line suggestion](https://github.com/urbit/arvo/issues/1105#issuecomment-472585937) from @max19, which elegantly corrects the implementation of the algorithm while preserving all existing planet names – a truly miraculous solution that came out of nowhere. Thank you Max!

Stay tuned for a post with a full report.

## Team

_Jared_ `~nidsut-tomdun` spent the week on the `@p` debacle and more than once generated all four billion planet names to check for collisions. _Ted_ `~rovnys-ricfer` spent much of the week thinking about redesigning the PKI only to realize that the existing design is quite good. _Logan_ `~tacryt-socryp` and _Isaac_ `~novlud-padtyv` started working on the next major revision to Landscape. _Ben_ `~pitmug-roptic` quietly [started working on](https://github.com/urbit/urbit/pull/1221) 64-bit Vere. `~pilfer-pandex` [brought the hammer down](https://github.com/urbit/docs/pull/399#issuecomment-472667240) on the pronunciation debate.

Tlon is at the beginning a new batch of work for 2019, so new proposals are popping up almost daily. _Morgan_ `~hidrel-fabtel` is working on revamping our proposal (“UP”) system so that the outside world can more easily participate in all of the work that’s going on. _Anthony_ `~poldec-tonteg` and _Jared_ `~nidsut-tomdun` are also working on standards for our repository documentation and open-source development process.

## Community

Our Austin meetup and San Francisco AMA were a blast. You can watch [the recording of the latter](https://www.youtube.com/watch?v=ndk2b69fA9A) on Youtube. Thank you for coming and for all of your questions!

Out there on the Internet, people are starting to build their own platforms around Urbit and Azimuth. There are now multiple planet stores and at least one active online community. It's exciting to watch the community start to grow all by itself.

Until next time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.2.26 Network Update]]></title>
            <link>https://urbit.org/updates/2019-2-26-network-update</link>
            <guid>https://urbit.org/updates/2019-2-26-network-update</guid>
            <pubDate>Mon, 25 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/posts/updates/~2019.2.26-update-1.jpg)

## Toward a Permanent Network

We conduct significant network upgrades to Arvo’s network protocol by “breaching” into discontinuous “eras.” Eventually, the network will reach a final era, after which no more major upgrades will be made. In the meantime, the network should be considered under test.

We are currently in the third era since [launching Azimuth](/posts/essays/azimuth-is-on-chain) and much work lies ahead. We expect network instability and regular breaching throughout the next few months. If you’re using the network today: hang in there!

## Recent Progress

Some recent process improvements should accelerate the path to maturity. Arvo updates are now continuously integrated on `~zod`, Tlon’s galaxy, through which we distribute Arvo updates. Moreover, we’re working on an integration testing framework, tentatively named pH, that allows us to test across virtual networks of ships and dramatically improve debugging.

## Getting Involved

In the meantime, there are a few things you can do to get involved.

### Get an Azimuth point

We’re working on making the process smoother, but right now you can get an Aizimuth point from a friend. You can also generate your sigil using [sigil-js](https://github.com/urbit/sigil-js), or grab it from the Azimuth points metadata API.

### Try Arvo

Arvo isn’t ready for prime time, but you can definitely experiment with it. Follow the [Getting Started](/docs/getting-started) guide to boot a ship and access Landscape, our experimental messaging app.

### Join Hoon School

If you’re interested in learning how to write software for Urbit, we’ll be running online classes to teach the language, Hoon, and more in coming months. If you’re interested to join, [shoot us an email](mailto:support@urbit.org) and we’ll add you to the waitlist.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.2.25 Update]]></title>
            <link>https://urbit.org/updates/2019-2-25-update</link>
            <guid>https://urbit.org/updates/2019-2-25-update</guid>
            <pubDate>Sun, 24 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here’s a short update from the team for the week of `~2019.2.25`:

![](https://media.urbit.org/site/posts/updates/~2019.2.25-update-1.jpg)

## Network

The network remains frothy, but functional. Many connectivity issues have been resolved with a `|bonk` or simply by waiting.

We published [Operating a Star](https://urbit.org/docs/getting-started/operating-a-star/) and founded a city for star operators. [Contact us](support@urbit.org) for access to the latter.

Expect a breach next week. We’ll announce the date and instructions on [@zodisok](https://twitter.com/zodisok) once scheduled.

## Team

Work continues on _Elliot_'s `~littel-ponys` [lighter-than-eyre](https://github.com/urbit/urbit/tree/lighter-than-eyre) branch. _Ted_ `~rovnys-ricfer` made great strides toward the design for new `%ames`. Most notably, _Ben_ `~pitmug-roptic` got a [Nix](https://nixos.org/nix/) build working and [merged it](https://github.com/urbit/urbit/pull/1196) into the [cc-release](https://github.com/urbit/urbit/tree/cc-release) branch. Finally, support for push notifications is [coming along](https://github.com/urbit/urbit/pull/1203) thanks to _Logan_ `~tacryt-socryp`.

## Community

The Hoon School pilot begins Monday. We've received a lot of interest since announcing it last week and we can't wait to get started. [Contact us](mailto:support@urbit.org) if you want to be added to the waitlist for future iterations.

If you're in Austin on March 8th, _Anthony_ `~poldec-tonteg` and _Alex_ `~mignyt-mogseb` are hosting [a meetup](https://www.meetup.com/urbit-sf/events/259307805/) at [Garage](https://www.garagetx.com/) from 5–7pm.

In San Francisco on March 26th, _Galen_ `~ravmel-ropdyl` is speaking on [a panel](https://www.eventbrite.com/e/the-future-of-free-speech-online-registration-57429323653) hosted by [Lincoln Network](https://joinlincoln.org/) at [Galvanize](https://www.galvanize.com/campuses/san-francisco).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.2.11 Update]]></title>
            <link>https://urbit.org/updates/2019-2-11-update</link>
            <guid>https://urbit.org/updates/2019-2-11-update</guid>
            <pubDate>Sun, 10 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here’s a short update from the team for the week of `~2019.2.11`:

![](https://media.urbit.org/site/posts/updates/~2019.2.11-update-1.jpg)

## Network

The network has been frothy since [the transition](https://urbit.org/posts/essays/azimuth-is-on-chain/), with _Isaac_ `~novlud-padtyv`, _Joe_ `~master-morzod`, _Philip_ `~wicdev-wisryt`, _Ben_ `~pitmug-roptic`, and _Ted_ `~rovnys-ricfer` working non-stop to fix first memory and then `%ames` connectivity issues. Their efforts have paid off and we now appear to be sailing calm seas.

If you haven’t booted into the new era, follow [Getting Started](https://urbit.org/docs/getting-started/) and feel free to `;join ~dopzod/urbit-help` if you need help or want to learn more about the system. See [Messaging](https://urbit.org/docs/learn/arvo/arvo-internals/messaging/) if you don’t know what that means.

If you’re having connectivity issues, make sure you're running urbit 0.7.3, try updating again, [try this fix](https://twitter.com/zodisok/status/1096982801373491202), or if you're stumped, [let us know](mailto:support@urbit.org).

To stay up to date on network status, follow [@zodisok](https://twitter.com/zodisok) on Twitter.

## Team

_Ted_ `~rovnys-ricfer` and _Joe_ `~master-morzod` got an `%ames` rewrite to compile and are working on documentation and unit tests. _Elliot_ `~littel-ponys` is rewriting `%eyre`, our webserver, which is some of the gnarliest code in Arvo. Outbound web requests are now working, which has allowed us to delete old `%eyre` from the [lighter-than-eyre branch](https://github.com/urbit/arvo/tree/lighter-than-eyre), and work continues porting individual `%gall` applications over to `%light`. We’re looking forward to moving Landscape onto new `%eyre` soon. _Logan_ `~tacryt-socryp` is rewriting the HTTP client in Vere (Arvo’s interpreter) to better support HTTP/2. This will allow us to provide push notifications in the heretofore rumored Landscape iOS app. Finally, _Gavin_ `ridlur-figbud` and _Jimmy_ `fallyn-balfus` are working on a new design system to enable fast UI prototyping. We’re very excited to share more about that in the near future!

Shout-out to _Philip_ `wicdev-wisryt` for [this heroic weekend PR](https://github.com/urbit/arvo/pull/1072) that fixed persistent connectivity issues on the network after [Thursday’s breach](https://twitter.com/zodisok/status/1096225302210957312).

## Media

Palladium, a magazine on governance futurism, talk about Urbit through the second half of [Palladium Podcast Ep. 2](https://palladiummag.com/2019/02/18/palladium-podcast-ep-2/) in a conversation about their recently published article [Facebook’s Political Problems are Inherent to Centralized Social Media](https://palladiummag.com/2019/02/14/facebooks-political-problems-are-inherent-to-centralized-social-media/). Worth a listen.

## Meetups

If you're in San Francisco on March 1st, we're hosting [an AMA with Galen Wolfe-Pauly](https://www.meetup.com/urbit-sf/events/259144802/), Tlon's CEO.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2019.2.5 Update]]></title>
            <link>https://urbit.org/updates/2019-2-4-update</link>
            <guid>https://urbit.org/updates/2019-2-4-update</guid>
            <pubDate>Mon, 04 Feb 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2019.2.5`:

![](https://media.urbit.org/fora/updates/2019.2.4-update.jpg)

Welcome to the other side. The Urbit PKI, Azimuth, now fully [migrated to the Ethereum blockchain](https://urbit.org/posts/essays/azimuth-is-on-chain/). This migration means that all address-space-holders have cryptographic ownership of their assets. The guide to getting on the network can be found [here](https://urbit.org/docs/getting-started/).

Azimuth is one of three layers of the Urbit project, alongside _Arvo_ and _Aegean_. Arvo is the Urbit operating system. Aegean is something more abstract; a pattern for building “cities”: Urbit communities whose members run the same custom suite of software on their Arvo servers. Our [Primer](https://urbit.org/primer/) explains these concepts in depth.

An integration of this size is not without its difficulties, though. ~zod labored mightily for a few days then `bail: meme`d (Arvo for “ran out of memory”). _Joe_ `~master-morzod`, _Ted_ `~rovnys-ricfer`, and _Isaac_ `~novlud-padtyv` discovered the problem: `~zod` had so many neighbors that Vere ran out of memory upon restart. [One fix](https://github.com/urbit/urbit/pull/1167) changed how Vere put header metadata on the event log, allowing it to be traversed both forwards and backwards, and [another fix](https://github.com/urbit/urbit/pull/1180) conserves memory by clearing the cache more often. A [third improvement](https://github.com/urbit/urbit/pull/1171) brings an important memory diagnostic tool, `|mass`, back to Arvo. Our champions breached the network to implement these changes, and problems seemed to be solved. _However_, they ran into new issues with event-playback, and they’ve been debugging that ever since.

(There’s also a new Twitter account, [@zodisok](https://twitter.com/zodisok), that tweets out updates about `~zod`’s network status and any relevant pull-requests. It also provides a bit more insight into the challenges of building your own tools to maintain a network. Follow it to stay in the loop.)

_Will_ `~hadrud-lodsef`, _Gavin_ `~ridlur-figbud`, and _Jared_ `~nidsut-tomdun` are making incremental changes to our Azimuth front-end, Bridge: UI fixes, new wallet support, adding conditional star-release capabilities for galaxies, and integrating a wallet-generator feature. The Bridge crew will try to implement these changes on a weekly schedule, and you can keep track of them in the Bridge repo’s new [CHANGELOG](https://github.com/urbit/bridge/blob/master/CHANGELOG) file.

BONUS: _Mark_ `~palfun-foslup` aka The Dutch Destroyer decided that full bitcoinification was not happening fast enough for his liking and submitted a PR that added bitcoin rpc support to Arvo. Watch the demo [here](https://twitter.com/mdfang/status/1092171862178701313).

See you next week.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A Founder's Farewell]]></title>
            <link>https://urbit.org/blog/a-founders-farewell</link>
            <guid>https://urbit.org/blog/a-founders-farewell</guid>
            <pubDate>Sun, 13 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![Curtis Yarvin portrait](https://storage.googleapis.com/media.urbit.org/site/posts/essays/farewell.png)

After 17 years, I've left the Urbit project.

I've resigned as CTO, board member, and voting shareholder of
Tlon (Urbit's corporate sponsor). I've also reassigned my
personal galaxies to urbit.org (Urbit's embryonic foundation,
still in Tlon's custody).

My family still has a few thousand Urbit stars (in long timelock
contracts), plus a nonvoting minority in Tlon. This isn't
authority, just compensation: I have zero central power over
either Urbit or Tlon. Nor will I contribute code to Urbit, nor
write nor speak publicly about it. I am actually done here.

From the very start, I knew Urbit could not succeed until it
ceased to be mine and became the world's. Urbit works; its PKI
is on the Ethereum mainnet; it's open source; in every way,
technical, legal, and mathematical, it is the world's.

(What _is_ Urbit? Please read the [primer](/primer).)

Let's talk about: why I've left; the state of Tlon; and the state
of Urbit. If there's any time left, we'll read some poetry.

## Why I left

No one had the power to fire me. (If anyone wanted to, they kept
it to themselves.) I wanted to quit; I could; I should have; I did.

I'm a thinker, not a doer; an explorer, not a leader; an author,
not a maintainer. My goal was always to fire myself at the
first possible opportunity. I'm super happy to reach it.

Any creator is a sort of parent – where control is dependence,
powerlessness is independence, and independence is victory.
There are a lot of ways to light a fire. The last step is just
getting out of the way – which must be done not too late, not
too soon, and just right. No one can beat Satoshi in this act;
anyone should be delighted to follow him.

I worked full-time on Urbit, alone and self-funded, for eleven
years. From 2002 to 2013, I wrote an end-to-end clean-slate
system-software stack: an axiomatic interpreter that fits on a
T-shirt, a typed functional language that doesn't use abstract
math, and a purely functional operating system. I didn't patent
any of this; I put it all in the public domain. (Not a valid
open-source license; Urbit is now MIT licensed.)

By 2013 I had a stack that worked well enough to make [a
video](https://vimeo.com/75312418), then raise a 1.5M seed round. Urbit in 2013 was a
working product – in fact, Urbit has had a live global network
since November 2013. But in a new platform, the distance between
_working_ and _compelling_ is nontrivial. Especially for a seed
company with just a few young engineers, building something like
nothing ever built before.

Urbit in 2013 had roughly the same feature set as Slack in 2013,
but less polished, and decentralized. It was pretty buggy and
slow. But had we put all our resources into debugging and
optimization, it would not have taken five years.

My instinct was always that Urbit's delivery schedule should be
as long as possible. For me, there are always two Urbits: the
Urbit that exists, and the Urbit that should exist. To invent
the latter I have to inhabit it. When I look at the present,
I try as hard as possible to look at it from the perspective of
the future – that's where my head should be.

This always makes me think Urbit sucks. And the last thing you
want to do is evangelize anything that sucks. This is a bias,
but that doesn't make it wrong. For instance: the 2013 Urbit had
a shell and a persistent distributed chat – but the shell was
mixed in with the kernel, and the chat with the network protocol.
As seen from the 2019 Urbit, this is very lame indeed.

The conventional wisdom is to ship your embarrassing "MVP." For
several reasons, Urbit occupies a unique strategic position.
Urbit just isn't relevant until Urbit is, if not perfect,
uniformly excellent. It can't just work. It has to work right.
Urbit has to be amazing – which is hardly a useless discipline.

I still did not think it would take five years to make Urbit
work right – or to get the resources to make it work right
(which only happened in 2018). But founders always delude
themselves, or no one would do it.

Urbit is not uniformly excellent quite yet. There are a few
medium-sized cleanups in the near-term pipeline. But this is a
matter of months, not years. I don't see any unknown unknowns.
The adventure isn't over – but the exploration is over.

A clean-slate system software stack, from fundamental interpreter
to social network, through typed functional language and
deterministic OS, is an enormous architectural journey – so
long and winding that it's easy for anyone to get lost in any
detail. Isn't that any explorer's first job: not getting lost?

But once the route is marked, there is a second duty: getting out
of the way. It's time for surveyors, not explorers, to map,
measure and smooth every wrinkle on the map. That's how system
software matures. Lines first ripped in one long slash are
polished, straightened and refined across years and decades.

And Urbit is too deep and interesting for one technical leader.
Every part of it needs its own owner. But others can't build a
real sense of ownership while the founder is still around. I'm
not even the best engineer on the project; I just got here first.

This codebase is very young and very general; there is a lot of
fun left to be had with it; others deserve to have that fun.

I have no successor as "BDFL." Technical leadership passes to
Tlon as a company. Urbit is open source and anyone may play, but
anyone who wants to catch up to Tlon still has a lot to learn.
Not that that should stop them!

I can't make Urbit technically transparent in one speech. But
maybe I can shed a little light on the strategy, organization,
history and future of the company and the project. It's easier
to be frank on the way out.

## Tlon, boiling oceans since 2013

First of all: why did we do what we did?

An ambitious system software project can inhabit one of four
institutional forms: bigco, startup, academia, or community.

None of these is a fit for a clean-slate system software stack.
The startup is the least worst. I'd do it again.

A normal startup lifecycle (Tlon actually got into YC, but
declined – this was either cool or lame) looks nothing like a
normal system-software lifecycle. Nor is Urbit normal. But
while Silicon Valley is absurd, it still fits Marianne Moore's
line: "with a perfect contempt for it, one discovers that there
is in it after all a place for the genuine."

The less said about big companies and big science, the better.
But the choice between startup and community is interesting.
Let's talk a little about why Tlon, this corporation, exists,
then a little more about what it actually is.

### Tlon, from cathedral to bazaar

I used to think I could give Urbit directly to the world – that
I could just post the code and an open-source community could
take it from there. That'd probably work now, but it's not yet
the right thing – and not because nobody wants a revolution.

I've never been an open-source person myself. But the model has
fascinated me since I encountered Nethack in the '80s. Now that
open-source software is a mature field, we can see what kinds
of problems the open-source "bazaar" mode is and isn't good at,
versus the corporate "cathedral" mode.

One problem open source isn't good at is creative collaboration
on large and novel systems. For example, if we consider the set
of people creating Google's new Fuchsia OS, and the set of people
contributing npm modules, we see that it's almost impossible to
imagine something like Fuchsia as a community effort – but this
is not for lack of talent-hours. Imagine a bazaar creating a
feature film, and you'll get the picture. (And Fuchsia seems
like a fairly traditional OS.)

Why is creative work so hard for bazaars? We could take this as
an axiom – but it's worth understanding.

The path from concept to product is an annealing process. Your
code starts as a gas and ends as a metal. It must cool gradually
under precise control. When parts cool too fast, flaws appear.
Where flaws appear, the code must be reheated: ie, rewritten.

Except for ASCII and a few algorithms, Nock, Hoon and Arvo didn't
really rely on anything from 20th-century CS. We didn't drop any
off-the-shelf parts into the oven; the whole stack is made from
gas. So the code in Urbit has been rewritten at least once; the
best code has been rewritten four or five times; perhaps some has
been rewritten ten, fifteen, even twenty times.

In 2002, I started out with no idea what I was doing. Urbit was
interstellar vapor. I did have a decent grounding in 20th
century CS, academic and practical. In the '90s I was a grad
student in OS at Berkeley, then spent eight years on system
software projects (a language, an OS and a browser) in industry.
What I wanted, I did not know; what I knew, I did not want.

In a long annealing process, it's important to triage the order
in which you solve problems. There are three kinds of problems:
problems you can't solve now, problems you don't have to solve
now, and hard problems. Unless you postpone anything that isn't
a hard but solvable problem, your gas will never turn into steel.
There are lots and lots and lots of ways to go nowhere fast.

Somehow it's 2019. Urbit is hot iron under the hammer. It is
solid, but not yet hard. It has shape, but can yet be shaped.
It is done, but ought to be finished. It is a sword; you don't
want to get stabbed with it; it is not Excalibur, the blade to
end all blades.

The bazaar is great. But cathedrals still exist for a reason.
The challenge for an ambitious system-software project is not
whether to choose the cathedral or bazaar model, but when and
how to transition from cathedral to bazaar.

A cathedral – the same classic pyramid org-chart no doubt used
by the builders of the actual pyramids, or the actual cathedrals
– is economically less efficient than a bazaar. Why?

Even on the world's most fun project, working for some dumb boss
is no fun. The bazaar succeeds because the project extracts free
labor from contributors – not by cheating them, but in exchange
for fun, status, experience, etc. But mainly fun, honestly.

Whereas a cathedral costs a giant ton of money. But in exchange,
the cathedral gets _cohesion_ – the capacity for intelligent
coordinated action. Bazaars can coordinate, but not easily.

Because a cathedral can coordinate, a cathedral can _create_ –
acting at a scale above individual action. A bazaar is very
useful, but a bazaar does not create. It can grow; it can heal,
harden, extend, and expand; but creation requires an individual
or a coordinated group.

But a bazaar can get a lot more done, a lot faster and a lot
cheaper. So the right starting point for a bazaar is an existing
system which is very clear, very final, and very simple. So any
new system should be created by a cathedral and perfected by a
bazaar. Since these institutions share little or no structure,
the transition is by no means straightforward.

### Tlon, just a little startup

Tlon is Urbit's little corporate cathedral. It's about 20
people, about 15 of them engineers. Everyone is working on
Urbit, but not everyone is writing Hoon; there is client-side
work, Ethereum work, etc.

The team is comfortably funded and more than competent. One Tlon
engineer is a 10-year, level 6 Google veteran; another is a YC
alum; these people are great, but not really outliers. And not
to be credentialist – there are plenty of dropouts, too.)

Today, there's almost no part of the Urbit codebase that I still
know better than anyone else. There are even design areas that
others know better. When we transitioned from Nock 5 to Nock 4,
all I contributed was a suggestion. The same for our Ethereum
address collection, which our customers absolutely loved.

Who's responsible for growing and maintaining this team? Who's
the stone at at the top of the pyramid? Not me: if you gave me a
goat to feed, the goat would die. The stone that holds the arch
together is Tlon's CEO and my cofounder, Galen Wolfe-Pauly.

Tlon was founded in 2013; Galen led it through its long seed
stage, with only a few engineers, to 2018, when he finally
secured the resources to do the project justice. (Although way
too much of Tlon's energy in 2018 had to go into Ethereum.)

Galen's previous project was the social meta-network Ost. He has
an architecture degree from Cooper Union; he is a great designer,
a good front-end engineer, and a pretty good surfer. (He also
runs the @urbit Twitter.)

Galen sets Tlon's product vision and is responsible for both
visual appearance and human experience. Basically, Galen is the
Steve Jobs of Urbit, with only two differences: Galen's not an
asshole, and Steve wasn't short.

Galen is joined in the new leadership team by Erik Newton
(operations, legal) and Anthony Arroyo (product, engineering).
Erik used to run a divorce-law firm and still is a relationship
coach. Anthony was a grad student in comparative literature and
managed engineering prototypes at Applied Minds.

With my departure, Galen is in exclusive control of Tlon and
holds the only board seat. Tlon did take seed funding from VCs.
But outside investors have never held any management role.

## Urbit, in the rear-view mirror

Since I'm not going to talk about Urbit again, let me say a few
words that might otherwise go unsaid.

### Urbit, a level and neutral platform

Urbit's distribution and sponsorship hierarchy of galaxies,
stars and planets is _not_ designed as a political structure,
or even a social structure. The actual social layer is in
userspace -- one layer up.

Socially and politically, Urbit is a flat network of planets.
Galaxies and stars are plumbing. No one cares which star is your
sponsor, any more than your Facebook friends care who your ISP
is, or you care what data center Facebook is in.

The sponsorship hierarchy and the senate of galaxies (which can
amend Urbit's Ethereum constitution) are _technical_ governance
mechanisms. They exist to react to unanticipated technical
issues or conflicts (like denial-of-service attacks). Because
sponsorship has an escape mechanism, it is not a _feudal_ bond
(like your relationship to Facebook).

Urbit is a decentralized network of social networks. No one can
regulate it. Urbit is made to blossom into an endless garden
of human cultures, each of which must regulate itself, none of
which can bother the others. The soil in which these flowers
grow must be level and neutral.

### Urbit, anything but a fair distribution

Who got those galaxies, anyway?

Urbit has no mining mechanism and needs none. My model was: I
own the whole space, since I made it; on the other hand, it's
worthless until I find a way to give it away.

In the end, I am probably the only individual with a fair amount
of Urbit address space (no galaxies, a few percent of all stars).
Tlon plus urbit.org also have about the right amount (slightly
less than half). The rest are held by third parties – all of
whom have either much more, or much less, than they deserve.

But although the distribution of Urbit space was thoroughly
unfair, it was always _honest_ and never _corrupt_. Everyone
who has galaxies or stars did _something_ for Urbit. Some gave a
lot of money, some gave a little; some contributed a lot of code,
some just showed up. We paid a lawyer by bartering a pair. A
bunch went to contest winners who solved a trivial Nock problem
in 2010.

What's unfair: the standards changed wildly across time. What's
honest: they were always the same across _people_. Granted, you
often had to be in the right place at the right time. This is
another problem with life that we can't fix.

Every real system of property is unfair. Who deserves to own
Manhattan? Who does own it? If property be not unfair – if it
is not the result of respecting past accidents – it is not
property at all, but something else. I certainly would not do it
this haphazardly again, but the outcome is no tragedy.

When you live in Manhattan, you simply don't worry about who
owns it or why; and nor does it matter. Are they Jews? Muslims?
Christians? Communists? Italians? You don't care and you don't
have to. You know it's basically random and probably unfair.
Randomness, even blatant unfairness, creates a kind of neutral,
peaceful, even promising urban anonymity.

Property is always and everywhere a kind of amnesty. It says:
whatever happened in the past, this is now what is. When we all
agree that everyone has what they now have, however they got it,
we have a formula for peace. When we say that everyone should
have what they deserve, we can never expect everyone to agree –
which means we have planted permanent seeds of discord.

And randomness is a virtue – it disrupts hidden patterns. The
galaxy owners include famous VCs and total nobodies; a Zen monk
and a former Orthodox nun; a blockchain industry leader and a
permaculture farmer. If they do have to all agree on something,
they should have little to agree on but the truth.

## Urbit, a technical report card (January 2019)

As a system-software stack, the fundamental thesis of Urbit is
that technical simplicity can flow all the way up to the top of
the stack, where it becomes human usability. If we can build a
purely functional OS, we can build a zero-maintenance server,
which is easy to understand because how it works is simple.
With this problem solved – nothing else matters.

Unfortunately, I still have to give Urbit an "incomplete" here.
No grade is available, because usability depends on a lot of
fit-and-finish issues that are naturally back-loaded. I would
still much rather run an Urbit ship than a Mastodon instance.
But still, Urbit today can't quite promise zero maintenance.

So we have to look at smaller indicators. One way to get anyone
to grade their own work is to ask them for three ways they've
succeeded, and three ways they've failed.

### Urbit, three battles won

I did once want to be a real computer scientist. Before my
expulsion for sordid & disturbing behavior, I was once a
19-year-old PhD student in CS at Berkeley. I even made an
embarrassing bet with Raph Levien as to which of us would win the
Turing Award – my money is definitely on Raph at this point.
You can even go and read my Usenix '93 paper on ASLR-secured
RPC, which won Best Student Paper and has like 50 citations.

Well. That whole scene is a bad trip, kids. Avoid it. Also, if
you start out as Rimbaud, you might end up as Lebowski. On the
other hand, to have any excuse for boiling the ocean, you do have
to make some serious CS problems just go away. Here are three.

#### Validation

20th-century languages underrate the centrality of communication
to computing. Their type systems expect all data to live in a
single memory forever. They don't consider data serialization
and validation to be core competencies of a programming language.

So serialization/validation is handled either ad hoc, or by
intermediate data description systems which have inherent
impedance mismatches with the language proper. Not only is work
done over and over – but most network security breaches exploit
seams in custom or complex deserialization and validation code.

In Urbit there is one kind of data, a noun, which is an atom
(unsigned integer) or a cell (ordered pair of nouns). There is
one serialization model, which maps noun to atom to noun, in a
page of code. And a type defines a set of nouns by defining a
function of an arbitrary noun, whose range is that set – which
means any data type is also its own data validation function.

#### Idempotence

20th-century computers have two brains: one fast and temporary,
the other slow and permanent. When one of these two-brained
computers hears a packet, and sends an acknowledgment, that only
means the temporary brain heard it. Acks are not end-to-end
transactions.

This means you can't write a command protocol where your commands
get executed exactly once. You can only choose "at least once"
or "at most once." This problem is as ridiculous and frustrating
as it sounds.

You can address it in three ways: (a) make all your commands
formally idempotent, so that repeating them has no additional
effect; (b) insert a layer of stateful middleware — a message
queue; (c) be fine with "almost always once." Guess which
approach is most popular?

Your Urbit ship has one permanent brain. Its acks are end-to-end
transactions — no packet is acknowledged until all its direct
effects are finalized. Every message channel is its own message
queue. And every message is executed once.

#### Dependencies

20th-century languages are all at least vaguely based on a
formalism from the '30s called the "lambda calculus." The
fundamental operation in lambda calculus is variable reduction
from name to value. So lambda languages all have a symbol table
or environment which binds names to values.

Modern build systems assemble large programs out of small files
by reusing this symbol table for global function names, a process
called "linking." Unfortunately, linking causes a problem known
as "dependency hell," involving baffling, unpredictable upgrade
failures. The fundamental problem is the "diamond dependency" —
when a build requires two different versions of one symbol.

Urbit does not use the lambda calculus, an environment or symbol
table, or linking. Because it pushes name resolution out of the
fundamental interpreter and up into the language, it can play
many more namespace juggling tricks. And its build system has no
trouble including multiple versions of the same library.

### Urbit, three battles unwon

As I mentioned earlier, triage is essential on any long journey.
You have to keep moving forward, even when you have no idea where
you're going – which means attacking the hardest problems you
can solve right now.

Unfortunately, this is a different standard than the usual rule
for shipping a product: solve the most important problems first.
This principle of triage is a general case of Knuth's apothegm
against premature optimization. Urbit, in fact, was absurdly
slow for a long time, but after a couple of engineer-months of
focused optimization it seems fine now.

But there are other areas where Urbit today is surprisingly weak.
All look careless, but all are the result of careful triage.
When you find a weakness due to triage, you may think you are
judging Urbit's quality. You are just judging its maturity –
which doesn't make your judgment wrong, of course.

#### Opacity

Urbit's notorious opacity is the problem that makes people
complain the most. It's not an unwarranted complaint.

At least, it's not all an unwarranted complaint. Part of the
complaint is just about novelty. Novelty is of course inherent
in any clean-slate stack. I do regret making 0 true and 1 false.
On every other count, however, I offer all critics of Urbit's
novelty none but the most vulgar gesture.

But novelty is not the only problem. Urbit's external
documentation has gotten much better in 2018 – in particular,
it's now much easier to learn the language. Its _internal_
documentation, and general code quality, remains at best poor to
average. Worse: the worst code is the oldest, deepest code,
which is also the most fundamental. Not only is it not
commented, it is full of cryptic, meaningless names.

There is now a new style guide, which should enable all reference
documentation to migrate into the codebase. But this style guide
is so new that none of the codebase complies with it. The guide
demands "space-rated" code that documents every variable and
every line – and almost none of the codebase is space-rated.

Urbit's internal opacity persists for two reasons, one good and
one bad. The bad reason is just laziness. The good reason is
justified fear of _premature explanation_, which like premature
optimization ruins the annealing process.

When you don't know exactly what you're doing, preserve as much
ambiguity as possible. For example, a name that means something
is a commitment to one specific explanation; a name that means
nothing is no commitment at all. A cryptic name is productive
procrastination; it lets the hard problem of naming get solved
later, and hence better.

#### Impermanence

Your Urbit ship needs to be _permanent_. That means it doesn't
lose data, sink, or get wedged, or rot. It's not complicated.
I wish Urbit today could make this promise, but it can't.

There are are two problems here: short-term permanence and
long-term permanence. Short-term permanence means your ship
can't fail or lose data except via OS or hardware failure.
Long-term permanence means you can put your ship on a USB stick
in a box for 50 years, or 100, or 500, and when you turn it on
in a modern interpreter it will upgrade itself and work fine.

There aren't any significant structural obstacles to each of
these milestones. But we can't claim them yet. We haven't
really even worried about them. This is another triage case:
in this case, the issue is _premature reliability_.

Permanence also includes security. Except for the on-chain PKI,
in which case you're trusting Ethereum, you shouldn't yet trust
Urbit's security at all. Sorry!

#### Duplication

Triage can procrastinate in the other direction. It can skip
problems that are too hard to solve. When you procrastinate,
always come back – in this case, when the problem is easier.
Here's one way Urbit has skipped a problem that was too hard.

Urbit, as you may recall, is a single-level store. It has only
one brain. And yet, we resisted the natural unification of
_documents_ and _applications_ and _secrets_ that a one-brained
computer obviously suggests.

Instead, Urbit today is built more the Unix way (if not the
Windows way). It has separate subsystems for tracking and
updating these three kinds of data. This was my design. Like
Urbit's opacity or impermanence, this was always obviously lame.

Why do it the lame way? Because, before understanding the union
of these problems, we had to understand each problem by itself.
We didn't – not even close.

No one else ever built a purely functional operating system. No
one is going to go straight from zero to the right thing. You
have to solve a hard problem, learn from it, and do it again.

Now that the team has built and used the specialized subsystems,
it's probably time to go ahead and generalize. The problem now
strikes me as almost straightforward. The constraints are clear
and so are the tools. None of this was true a year ago.

On the low end, triage keeps you moving forward by stopping you
from wasting time on easy problems. On the high end, triage
keeps you moving forward by keeping you from leaping too far
ahead, and falling down an impossible rathole.

## Further reading

What will I do personally? I'll spend more time with my kids.
I'll finish reading my 1911 Britannica – I am only on the B's.
I have no other long-term plans.

But I won't be back to Urbit. I am leaving not just the project
but the field – no less than Satoshi, or Everett, or Rimbaud.
Will Satoshi weigh in on the next Bitcoin Cash fork? Did Rimbaud
fly back from Ethiopia for his book-release tour? (Did anyone
want him back?) It's not so bad to be a middle-aged Rimbaud.

Is there more to say? Of course, but not in prose. Read
Bunting's _Chomei at Toyama_ and _Notes on a Fly-Leaf_; Cavafy's
_Il Gran Rifiuto_, Keeley & Sherrard translation; Canto XV of the
Inferno, Pinsky translation. You might learn something.

## Apologies and acknowledgments

I apologize to anyone who has too little Urbit space. I refuse
to guilt-trip anyone who has too much.

I appreciate my friends by not naming them. I disarm my enemies
by inviting them to lunch – but only if they come unarmed.

I thank everyone who has ever worked on Urbit and everyone who
will work on it in the future; our backers, great and small; my
cofounder, Galen, and his family; my parents, wife and kids.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Azimuth is On-Chain]]></title>
            <link>https://urbit.org/blog/azimuth-is-on-chain</link>
            <guid>https://urbit.org/blog/azimuth-is-on-chain</guid>
            <pubDate>Sun, 13 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/site/arvo-4.svg)

The Urbit address space is now live on the Ethereum blockchain. We’re calling the PKI ‘Azimuth’ and you can find it at [`0x223c067f8cf28ae173ee5cafea60ca44c335fecb`](https://etherscan.io/address/0x223c067f8cf28ae173ee5cafea60ca44c335fecb) or [`azimuth.eth`](https://etherscan.io/address/azimuth.eth). Owners of Azimuth ‘points’ (galaxies, stars or planets) can use [Bridge](https://github.com/urbit/bridge/releases) to manage them and view their balance now.

Sometime in the next few days, owners of Azimuth points will be able to boot Arvo, the Urbit OS, from their Azimuth point and request access to one of our 'cities': private communities for chat and discussion. These new cities use Landscape, a brand new UI for using Urbit in the browser.

This means you can boot a deterministic OS from an identity you own, join a totally independent, decentralized and self-governing network and run a clean, simple UI. Pretty exciting. Is it ready for ordinary users? Definitely not.

Since 2013, you've been able to boot an Urbit and join our test network. And, since 2013, we've always had our sights set on building a personal server that can both last 100 years and be delightful to use. Urbit isn't meant just to be as good as the MEGACORP software we use today. It's meant to be much, much better.

But Urbit is not a 'product' in the conventional sense. Urbit is a public thing. It's meant to belong to everyone. For the past six years, much of our work was research and design work. Which means lots of weird ideas thrown away, and others rewritten or redesigned many times over. Our work has always been open source, but we tend to be pretty quiet about it.

With Azimuth on the blockchain, it's time for us to start engaging with the world more directly.

We aren't calling this a launch. There's no keynote. There's no dancing on stage. I mean, it's 2019. You must be pretty sick of being marketed to. We'll try to stick to the specifics here. What's new, what we've been up to and what works. There's too much to fit into a single post, so we'll keep it pretty light for now. Each of these sections will probably get its own post in the near future.

> Note: As of `~2019.1.14` we're in the process of rebooting the Arvo network. We expect it to be back online before the end of the week. We'll update this post and [tweet](https://twitter.com/urbit) when the network is online and stable.

## Rethinking the stack

We've started to talk about Urbit as a stack of three parts: Azimuth, the address space and identity layer on Ethereum; Arvo, the OS and overlay network; and Aegean, a pattern for building decentralized communities on the Arvo network.

We tried to capture this separation in [the primer](/primer), a new overview of Urbit. Explaining Urbit has always been challenging. A monolithic project that is OS, network, language, VM and UI barely makes sense. Separating the layers helps, we think.

Let's step through them to see what's new.

## Azimuth

![](https://media.urbit.org/site/bridge-0.png)

As a quick refresher: Urbit addresses, now called Azimuth 'points', are short names like `~diblun-tidduc`. You own your Azimuth point with a private key and can use it as a routable network address on the Arvo network. You can read more about Azimuth in [the primer](/primer#what-azimuth-is). If you're curious who owns all this address space, you can find that [in there too](/primer#azimuth-distribution).

In late 2017 we decided to migrate the yet-to-be-named Azimuth to a system of Ethereum contracts. After a year of coding, testing, auditing and migrating — they're now fully deployed to the Ethereum mainnet.

Azimuth is basically two parts, a database of who owns which points, and a set of rules about what points and their owners can do. That set of rules is called Ecliptic, and can be found at [`0x6ac07b7c4601b5ce11de8dfe6335b871c7c4dd4d`](https://etherscan.io/address/0x6ac07b7c4601b5ce11de8dfe6335b871c7c4dd4d) or [`ecliptic.eth`](https://etherscan.io/address/ecliptic.eth). The top-level Azimuth points, the galaxies, can vote on upgrades to the Ecliptic contract, but they can't edit the database of who owns what.

The ownership database contract is called Azimuth, which you can find at [`0x223c067f8cf28ae173ee5cafea60ca44c335fecb`](https://etherscan.io/address/0x223c067f8cf28ae173ee5cafea60ca44c335fecb) or [`azimuth.eth`](https://etherscan.io/address/azimuth.eth). For those of you who own address space, you can use the `getOwnedPoints` function in the 'Read Contract' tab to check your balance. The function returns the number (not the phonemic string like `~ravmel-ropdyl`) of your points. Each Azimuth point is an ERC-721, non-fungible piece of digital property.

To manage your points, we built [Bridge](https://github.com/urbit/bridge/releases), a completely custom interface for interacting with our Solidity contracts. Interface quality is really important to us, and we couldn't find anything in the 'crypto' world that met our standards. Bridge is good, but crypto UX is a hard problem. We've already got some ideas for improvements.

If you're curious, you can find the source for the contracts in the [`urbit/azimuth`](https://github.com/urbit/azimuth) repo. The Bridge source is in the [`urbit/bridge`](https://github.com/urbit/bridge) repo.

We had the source for our contracts audited by Open Zeppelin, Blockchain at Berkeley and Bloctrax. Did we miss something? We sure hope not — but we'd happily compensate anyone who can find bugs. Please reach out to security@urbit.org if you find something of concern. We'd be happy to hear from you.

![](https://media.urbit.org/site/sigils.svg)

Azimuth names have always had a pronunciation system. `~ronryd-nidseg` is 13,695,781, for example. Now, they also have a visual system. We call these strange crests from another planet 'sigils', and you'll notice them used throughout all our new interfaces. You can find the source in the [`urbit/sigil-js`](https://github.com/urbit/sigil-js) repository. Building these was a lot of fun — we'll save the details for a future post.

So, how do you get an Azimuth point? We've left that question unanswered intentionally. Azimuth points are meant to be like digital land, not currency. They should change hands slowly. In order to get an Azimuth point, you'll need to find someone who already has one and is willing to part with it.

## Arvo

![](https://media.urbit.org/site/fast-lux-3.gif)

Arvo boots from Ethereum, is no longer embarrassingly slow, and has a brand new build system. [Our documentation](https://urbit.org/docs/learn/arvo/hoon) has also improved quite a lot. Hoon, Arvo's programming language, has had a lot of work done to its type system and compiler. We built new tooling for generating static sites (you're probably reading this on one right now) that are much, much faster and easier to use.

It's tough to talk about the progress we've made on Arvo without writing a long technical post. We'll save that for later. In a way, what's remarkable about Arvo is that it has become _less_ remarkable. It's more stable, faster, and the code quality has improved.

There's plenty of work to do, though. Should you be building on top of Arvo? Probably not yet. The kernel and kernel modules are really where the work still lies. We build things on top of Arvo, and in doing so it's pretty clear that the system can be better. Clay (the filesystem) and Gall (the application model) are due for a rewrite. A complete rewrite of the web server, Eyre is almost finished.

## Aegean

![](https://media.urbit.org/site/landscape-inbox.png)

Aegean is a pattern for building 'cities': groups of people running the same 'agent' on their Arvo servers. Agents aren't just 'apps' or programs. An agent rolls together the tools that a community needs. Today, our companies, communities, cults, cliques all have to duct tape together separate MEGACORP apps and services to compute together.

Aegean reverses this pattern. A community on Arvo is a city: just a bunch of people running the same agent. Each city is in control of its own codebase: the interface, application code _and_ data storage. This means a community can have complete agency over how to compute together.

Aegean cities can be completely different without impacting one another at all. Cities share the neutral infrastructure of Arvo and Azimuth — but they may never even know others exist. An archipelago of hypercultures.

It's important to note: the pattern of these cities is _not_ the pattern of Azimuth. The network hierarchy should impact the society of Urbit as much as the electrical grid impacts the life of the street in Manhattan. It matters when the power goes out — but most of the time groups form and dissipate continuously.

Before we can let the ocean of cities grow we have to homestead a few of our own.

Our first agent is called [Landscape](https://github.com/urbit/urbit/tree/master/pkg/interface), an agent for chat and longform discussion. We are using Landscape to run a few experimental cities over the next month or so. If you have an Azimuth point, you'll need to [request access](mailto:support@urbit.org) to join.

Anyone can create their own city, of course. The source is open. But we're not going to encourage you to just yet. Feel free to explore, but also be patient. We've got a lot planned around this. If Azimuth is done and Arvo is young, Aegean is just being born.

## Tlon

![](https://media.urbit.org/site/office-1.jpg)

So who is behind all of this? A team of collaborators and contributors. Many of us work at [Tlon](https://tlon.io) — the company we started in 2013 to advance Urbit platform development. Tlon has attracted an incredible group of smart, talented people who want the world to be able to own and control their computers. I'm proud to work alongside them.

One important omission on `tlon.io` is Curtis. As of today, he's no longer working on Urbit. [His own words](/posts/essays/a-founders-farewell) are the best way to understand his thinking. It's an achievement for the team, I think, that he can depart with confidence.

One major reason for that confidence is that Erik and Anthony have now become COO and CPO respectively. Having thoughtful, organized people leading the project is a huge benefit to the whole team. I'm very glad to have them on board.

## Looking ahead

I certainly forgot at least a thing or two. We'll dive in to more detail in the coming weeks.

There's a lot for you to explore. Have fun!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Governance of urbit.org]]></title>
            <link>https://urbit.org/blog/governance-of-urbit</link>
            <guid>https://urbit.org/blog/governance-of-urbit</guid>
            <pubDate>Thu, 10 Jan 2019 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/governance-1.svg)

## Summary

Long before Urbit first appeared as a prototype in 2013, we considered Urbit address space to be property. Granted, Urbit property ownership was only reflected as a text file in a github repository – but it was always designed to be cryptographically owned, and we've always taken that file seriously.

If you've ever looked at that text file, you've probably noticed that there has been a pool of Urbit assets there marked "urbit.org" since the beginning. Now that we're moving our property registry out of that repository and onto the Ethereum blockchain, we wanted to be as clear as we can be about what the plan is for those urbit.org addresses.

The TL;DR is that "urbit.org" will likely split into a separate entity from Tlon in the future. For now though, Tlon and urbit.org have the same mandate, so separating them doesn't make sense. For the time being, Tlon will continue to manage and use urbit.org assets directly for platform development. As a first step toward making urbit.org independent we've started to develop a board of advisors who we hope will one day manage those assets independently.

## Background

The history of a few lines in a text file doesn't give a whole lot of context. So, first, let's fill in a few more of the details.

In 2013 Curtis and Tlon each contributed 32 galaxies to a pool newly called "urbit.org." The idea at the time was to set aside address space to fund "platform development" – in the spirit of the IETF or the Mozilla foundation. This was long before anyone had heard of a Swiss blockchain foundation or anything of the sort. Our view was that it was going to take a lot of resources to build a system as robust and far reaching as Urbit intends to be, and 64 galaxies (25% of the total network) seemed sufficient. It was thought at the time that urbit.org might eventually take the form of a separate foundation, but we were simply too small and under-resourced a team to figure out the right legal structure at the time.

Tlon – as distinct from urbit.org – has always been imagined as a future service provider in the urbit ecosystem. But Urbit is still young, so those services aren't really needed yet.

Instead, what is needed is platform development. So Tlon has acted, in a way, as urbit.org was supposed to, by taking on the bulk of platform development efforts. This work consists of everything from kernel development to interface design and documentation. Tlon has sold (and granted) both its own galaxies, and some of those originally designated as urbit.org galaxies towards this end. We'll continue to do this for the foreseeable future, since Urbit's development needs (though finite) remain ongoing. We can't predict exactly how long this will continue, although we wish we could!

## Future plans

As Urbit becomes more widely used, we expect to make the Tlon/urbit.org separation real.

We've considered the foundation model, but have come to the conclusion that it doesn't really make sense. For one, it's quite expensive in terms both of administrative overhead, and the associated legal costs. For another, there just isn't anyone we trust enough to take over high level management of such an organization (see Tezos). Finally, our view is that foundations are not entirely effective in their mandates (see [this article](https://nadiaeghbal.com/foundations) from our friend Nadia).

One step we're pursuing is the creation of a board of advisors to guide our use of the urbit.org assets at Tlon. We're in discussions with several potential board members now. Our goal with this structure is to include more voices outside of Tlon in the process of governing the urbit.org assets, and to make their advice transparent to the public.

As with all of our projects, we think it's better to walk before we run. For now, Tlon will continue to act as urbit.org and use both pools of resources for ongoing platform development. Next, we'll create a board to advise on the use of those resources. Eventually, Tlon and urbit.org will likely become separate entities. We'll get there – one step at a time.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.12.18 Update]]></title>
            <link>https://urbit.org/updates/2018-12-18-update</link>
            <guid>https://urbit.org/updates/2018-12-18-update</guid>
            <pubDate>Mon, 17 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.12.18`:

![](https://media.urbit.org/fora/updates/2018.12.18-update.png)

With December comes a promise of the land going to sleep to awaken renewed. We
at Tlon carry spirit of the season with us, even amid the perpetual 60-degree
weather of San Francisco.

The Urbit network has, indeed, been renewed. _Logan_ `~tacryt-socryp`
performed a breach on the network, wiping the slate clean. All urbits must be
booted again with their original tickets, which means that your crashed ships
now have a second chance at life. If your ship is now experiencing connectivity
troubles, don't worry: deleting your old pier should fix everything.

On the infrastructure side, _Elliot_ the Wonderworker `~littel-ponnys` brought
us a gift-sack of miraculous performance improvements. He started by fixing
memory management, slashing the amount that is required to be pre-allocated for
cells. Next, he found multiple places where the compiler was called
unnecessarily, replacing such calls with less-expensive caching. Also redundant
were many type-checker calls, which were squashed as well. Elliot _also_ updated
the atom parser to remove a big chunk of latency from its operations. And, if
that wasn't enough, he wrote new jets that shaved precious milliseconds from the
web interface. Yes, five separate fixes, all of which add up to Urbit becoming
much, _much_ faster. The once-characteristic CLI input lag is now almost
imperceptible.

_Morgan_ `~hidrel-fabtel` and _Jimmy_ `~haptyl-wanwes` are hard at work
overhauling the site for the New Year, both in terms of web design and the
presentation of content. The new website will also include Jimmy's primer,
which neatly explains Urbit in layman's terms.

The docs boys -- _Rob_ `~lodleb-ritrul`, _Josh_ `~taglux-nidsep`, and _David_
`~rapfyr-diglyt` -- are helping out on this front. The documentation is being
completely reorganized so that it's more accessible and less overwhelming. A
great deal of new tutorial content will be included, and it's good enough that
it might put a dent in Urbit's arcane reputation.

And finally, rejoice! The great Ethereum address-space migration has begun!

If you own address space, you should have received an email with instructions
about how to register an Ethereum address with us so that we can grant you
cryptographic ownership of your address space. If you haven't received an email
a) check your spam folder and, if that doesn't work, b) send an email to
[registration@urbit.org](mailto:registration@urbit.org).

See you next week.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.11.20 Update]]></title>
            <link>https://urbit.org/updates/2018-11-20-update</link>
            <guid>https://urbit.org/updates/2018-11-20-update</guid>
            <pubDate>Mon, 19 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.11.20`:

![](https://media.urbit.org/fora/updates/2018.11.19-update.jpg)

The dreams of the keys crew are finally escaping their heads. After months of
excruciating reworking and fine-turning, _Will_ `~hadrud-lodsef`, _Gavin_
`~ridlur-figbud`, _Morgan_ `~hidrel-fabtel`, and _Jimmy_ `~haptyl-wanwes`
have completed the client-side tools for registering Ethereum addresses to
receive and access their purchased ships. The registration process begins with
the emails that we've begun to send out to ship-owners. The first batch has been
sent, and the next batches will go out in the coming week. If you own address
space, keep an eye out for an email from the urbit.org domain.

Address registration points towards the real prize: the full ledger of Urbit
ships nesting in the cozy, decentralized embrace of the Ethereum-based PKI. To
this end, _Mark_ `~palfun-foslup` added some Ethereum-facing cryptographic
functions [in the form of jets](https://github.com/urbit/urbit/pull/1028). And
they do what exactly what jets are supposed to do: take things from "unusably
slow" to "actually pretty good." This means that we can start deploying
Constitution transactions.

Performance isn't always a matter of engineering challenges being surmounted,
though. Occasionally it's a matter of hearing the cracking of joints in
something that's turning the wrong way. _Elliot_ `~littel-ponnys` felt something
so ghastly: a 200-millisecond delay on every Ford build. So the search began.
What was uncovered was two otherwise-benign lines that didn't get along with
_Paul's_ `~fodwyt-ragful` recently merged Vere changes. Elliot handled the
Arvo side, Paul charged the Vere flank, and the build-system bug was vanquished.

Yes, Urbit is a mission fearsome and sprawling, but we at Tlon live for the
hunt. Tearing up and replacing the entire stack just isn't enough, so we put our
own, meticulous spin on the concept of a cryptocurrency wallet. The _Urbit
Hierarchical Deterministic Wallet_ is a _system_ of related key-pairs that have
distinct powers. That's because you want it to be easy to, say, authenticate
packets without having to risk a chunk of your net worth. It's _deterministic_
because key-pairs of a lower tier can be derived from those of a higher-tier,
making the whole system a nice balance of usability and security. Sound cool?
Check out the details in Tlon's
[Urbit Proposal](https://fora.urbit.org/proposals/posts/~2018.11.8..19.31.59..ba77~/)
on the matter.

See you next week.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.11.6 Update]]></title>
            <link>https://urbit.org/updates/2018-11-6-update</link>
            <guid>https://urbit.org/updates/2018-11-6-update</guid>
            <pubDate>Mon, 05 Nov 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.11.6`:

![](https://media.urbit.org/fora/updates/2018.11.7-update.jpg)

_Gavin_ `~ridlur-figbud`, _Will_ `~hadrud-lodsef`, and _Jimmy_ `~haptyl-wanwes`
have been working tirelessly on the front-end tooling for bootstrapping our
[PKI on Ethereum](https://urbit.org/blog/2017.9-eth/). The fruits of their labor
are nearly ripe: all that's left is finalizing the copy and the documentation.

_Philip_ `~wicdev-wisryt`, a powerful Hoonist, is making sure that the Arvo
level of the stack is ready for the Great PKI Migration. Previously, every time
a ship booted, it would need to process every Ethereum block all the way up to
the present. This was _slow_, and we prefer life in the fast lane. So Philip
souped up `%jael`, our keys vane. When a child boots now, its parent sends it a
snapshot of the blockchain, rather than each individual event. And if we ever
need to revert some events because of a chain reorganization, we can just
restore an earlier snapshot instead of starting from scratch.

Landscape is the charming, user-facing bow on the top of all of this, and it's
just completed the first round of internal user-feedback testing. The entire
company came together to raise interface hell, providing _Isaac_
`~davtyr-nimren` and _Chris_ `~sigtus-hossyn` with a lot of useful data on the
performance and reliability characteristics of the web-facing Arvo
infrastructure, by way of the profiler in the Arvo interpreter.

Pretty sweet.

Or, _probably_ sweet. They tell you in college that it's never a compiler error,
but some of the "interesting" results of our profiling may, in fact, be
artifacts of a compiler error. _Ted_ `~rovnys-ricfer` and _Elliot_
`~littel-ponnys` are spelunking the lowest depths of the stack, illuminating any
profiler bugs with their combined brilliance. It's unlikely that our heroes will
find any Balrogs, but you can never be too sure.

It won't be long now, Martians.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.10.24 Update]]></title>
            <link>https://urbit.org/updates/2018-10-24-update</link>
            <guid>https://urbit.org/updates/2018-10-24-update</guid>
            <pubDate>Tue, 23 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.10.24`:

![](https://media.urbit.org/fora/updates/2018.10.24-update.jpg)

The heroic efforts of _Mark_ `~palfun-foslup` have ensured that the Ethereum
testnet Constitution is transacting properly, all in the face of the testnet
itself encountering a consensus-failure bug. We can now test various pieces of
our tooling and Urbit functionality against really existing blockchain state.

On the Landscape side, _Logan_ `~tacryt-socryp` and _Chris_ `~sigtus-hossyn`
finished integration between the mobile app and its desktop counterpart so that
there is a QR-code pairing functionality. These interfaces are now in shape for
internal testing.

_Ted_ `~rovnys-ricfer` has brought important changes to our build system,
Ford. The latest, fastest version of that system is titled Ford Fiesta, and
it's shaping up to have all the Spartan utility that its name indicates: stack
traces, new Ford-specific runes, and a parser for those runes. Ted also tweaked
Clay and Gall so that they use Ford Fiesta for builds.

In one of our cavernous basement labs, we've been poking away at a replacement
for our beleagured HTTP server, `%eyre`. This new beast, dubbed `%light`, has
benefited from the talents of _Elliot_ `~littel-ponnys`. A test version of this
new vane can now hold a connection open and send a steady stream of HTTP data to
the client. Big things have small beginnings...

See you next week.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.10.12 Update]]></title>
            <link>https://urbit.org/updates/2018-10-12-update</link>
            <guid>https://urbit.org/updates/2018-10-12-update</guid>
            <pubDate>Thu, 11 Oct 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/fora/updates/2018.10.12-update.png)

It's an exciting time here at Tlon.

The Keys team is toiling to make the Urbit Wallet air-tight and foolproof. The
Urbit Wallet, a cousin to the more typical cryptocurrency wallet, is an original
system for securing cryptographic assets. It's original enough to demand its own
Manual, a document that _Will_ `~hadrud-lodsef`, _Rob_ `~lodleb-ritrul`, and
_Morgan_ `~hidrel-fabtel` are in the process of perfecting. The Wallet Manual
will be a one-stop shop for information on using the Urbit Wallet system, both
general concepts and technical details.

Someone claiming to have solved a sufficiently large task with their first
attempt is probably lying. The Keys team are an honest bunch, and they've
decided to simplify our in-house wallet-generation software into something that
produces one Urbit Wallet for each ship. That wallet generator provides secret
keys to users in the form of PDFs, and these PDFs have been redesigned by
_Gavin_ `~riglur-figbud` so that they are more informative and easier to
organize.

Gavin and _Jimmy_ `~fallyn-balfus` are designing the UI flows for software
that takes the grief out of accessing your ships on the blockchain. This is
distinct from the aforementioned wallet-generation software which helps you
secure your ships on the blockchain, but we will soon to merge the two apps into
a combined application known as Bridge.

Our foreign correspondents are lending their talents to the Bridge mission.
New Zealand's _Jared_ `~nidsut-tomdun` has been working on the attendant
key-derivation library, and is also creating the library for displaying
Urbit Wallet tickets as human-memorable strings. _Mark_ `~palfun-foslup`, our
beloved Dutchman, worked with Jared to develop a JavaScript interface to the
Urbit constitution.

The infrastructure team has labored clanking towards the goal of making Vere
less clanky. Two of _Paul's_ `~fodwyt-ragful` changes -- a custom-bytecode
Nock interpreter and a new jet dashboard -- have been integrated, resulting in a
faster and more robust Urbit. Nock itself was updated, too, with the notable
addition being the Nock 12 "edit" operator. Paul, _Ted_ `~rovnys-ricfer`, and
_Joe_ `~master-morzod` joined forces to make this happen, and borrowed our
resident logician _Josh_ `~taglux-nidsep` from the docs team to check it for
correctness.

All of the above points to the big enchilada: using the Constitution as the
address registry for the Urbit network. Mark has capped off this week's progress
by booting the Urbit testnet (with all the new Landscape features) against an
Ethereum testnet, so now we can do our best to break it. Things are about to get
real.

See you next week.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.9.11 Update]]></title>
            <link>https://urbit.org/updates/2018-9-11-update</link>
            <guid>https://urbit.org/updates/2018-9-11-update</guid>
            <pubDate>Mon, 10 Sep 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
I've gone short on words and long on links for this update, since sometimes the
code speaks for itself.

![](https://media.urbit.org/fora/updates/2018.9.11-update-1.jpg)

After much gnashing of teeth and abuse of git, we now have a
[release candidate](https://github.com/urbit/arvo/tree/release-candidate)
branch (NB run with the
[correct](https://github.com/urbit/urbit/tree/release-candidate) vere branch).
This branch brings together, for the first time, a few long-running
lines of development. `%ford-turbo`, our new and improved [reactive build
system](https://github.com/urbit/arvo/blob/release-candidate/sys/vane/ford.hoon),
totally replaces `%old-ford` on this branch (take a look at those comments!).
Proud papa _Joe_ `~master-morzod`
[hard work](https://github.com/urbit/arvo/blob/release-candidate/app/acme.hoon)
on HTTPS proxying is baked right in (meaning that ship.urbit.org is graduating
from novelty to utility). `%jael` now actually [holds your
secrets](https://github.com/urbit/arvo/blob/release-candidate/sys/vane/jael.hoon)
and is being used to boot ships. _Curtis'_ `~sorreg-namtyv` swansong as the
auteur behind `hoon` is now included (a crispy new styleguide is also in the
works). Various niceties related to our new web ui are in here (_au revoir_ old
Fora and Webtalk), as well as an actually existing
[test](https://github.com/urbit/arvo/blob/release-candidate/gen/test.hoon)
framework and all kinds of crypto goodies. This release candidate will get the
testnet treatment for a little while, while we confirm that it's good enough for
you, dear Martian.

Much of the Infrastructure team is living the life of the fireman: making chili
with your friends interspersed with someone yelling at you to put out a fire.
Except, instead of making chili, _Ted_ `~rovnys-ricfer` is redesigning the Ford
Rune language (why should `~sorreg-namtyv` get all the fun?) and _Elliot_
`~littel-ponnys` is bringing `%eyre` into the new Millenium. _Mark_
`~palfun-foslup` and _Joe_ `~master-morzod`, though, continue in their quest to
make Ethereum safe for Martians and _Ben_ continues his grueling (for some value
of gruel) pair programming regime with _Curtis_ `~sorreg-namtyv`.

_Chris_ `~sigtus-hossyn`, _Isaac_ `~davtyr-nimren`, _Jimmy_ `~fallyn-balfus` and
_Logan_ `~tacryt-socryp` continue refining our new web UI, Landscape. Fonts have
been argued over, tables overturned over line heights. But it will all be worth
it in the end.

The Keys crew (_Will_ `~hadrud-lodsef`, _Morgan_ `~hidrel-fabtel` and _Gavin_
`~ridlur-figbud`) are forming like Voltron to get our address space ported
over and make sure that we can generate our HD wallets in a secure, usable
way. They are joined by the newest edition to Tlon: _Jared_ `~nidsut-tomdun`.
_Jared_ is down south New Zealand way, bringing Tlon ever closer to our goal of
`%amesing` over the entire globe. Say `|hi`!

Next year on Mars!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.8.30 Update]]></title>
            <link>https://urbit.org/updates/2018-8-30-update</link>
            <guid>https://urbit.org/updates/2018-8-30-update</guid>
            <pubDate>Wed, 29 Aug 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/fora/updates/2018.8.29-update-1.jpg)

Here is a smattering of the exciting things going on at Tlon this week.

Now that we know what the infrastructure for transferring our current
property registry will look like, _Will_ `~hadrud-lodsef`, _Morgan_
`~hidrel-fabtel` are getting the logistics in order. Primary to this is securely
generating new keys and securely transferring existing assets. Since Tlon owns a
_bit_ of address space, we're particularly interested in making sure this
transfer goes down smoothly!

The Landscape team has been busy integrating changes to Collections (our new
concept for writing, reading and subscribing to static files... like this one!).
Our very own Canadian visionary _Isaac_ `~davtyr-nimren` did a redesign recently
that makes this system more general and takes advantage of the permissions in
our file system, `%clay`.

Of course, what kind of a square only chats from their desk? Don't most of us
want to chat from our soylent-powered electric scooters as well? Luckily,
wunderkinder _Logan_ `~tacryt-socryp` and _Jimmy_ `~haptyl-wanwes` have been
grinding on Landscape mobile, including new features such as slick navigation
an improved DM flow and, maybe most importantly, a QR-based device pairing flow.

![](https://media.urbit.org/fora/updates/2018.8.29-update-2.jpg)

_Mark_, resident solidity jurist, is busy updating `%jael` (our vane for
handling secrets) to accomodate our newest Constitution.

_Joe_ `~master-morzod` is making good use of his time in the office to make
everyone else feel unproductive. Not only is he the maestro behind the
mergepocalypse that I mentioned last week, he is also finishing up work on
booting a ship using a keypair generated by, you guessed it, the front end key
tools mentioned above.

Ford Turbo is getting a good work out from its integration with the updates we
made to `%arvo` to accomodate Landscape. Dynamic duo _Ted_ `~rovnys-ricfer` and
_Elliot_ `~littel-ponnys` are fixing these bugs and updating the test suite to
account for these cases.

Last but not least _David_ `~patpex_ponleg` joins the Docs crew. _David_ has
experience teaching programming, and has even used Hoon in his classes. We're
happy to have him help us teach the world to hoon. Come and say hi to him on
`%talk`, or even better, ask him to help you with your hoon homework ;)

Next year on Mars!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.8.23 Update]]></title>
            <link>https://urbit.org/updates/2018-8-23-update</link>
            <guid>https://urbit.org/updates/2018-8-23-update</guid>
            <pubDate>Wed, 22 Aug 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/fora/updates/2018.8.23-update-1.jpeg)

At Tlon, oars have been bent for some time towards getting the [Urbit PKI
bootstrapped on Ethereum](https://urbit.org/blog/2017.9-eth/). Well:
The end is in sight! We're not ones to curse an estimate with "dates," so let's
say it's "forthcoming."

This effort has spurred all kinds of updates to the system, most of which
were long in the coming and all of which will have benefits far beyond the
Ethereum roll out. We're excited to share them with y'all.

We've finalized our suggested wallet derivation scheme. This was a monumental
effort that included the expertise of a lot of different parts of Tlon,
thanks to _Morgan_ `~hidrel-fabtel`, _Curtis_ `~sorreg-namtyv`, _Will_
`~hadrud-lodsef` and _Mark_ `~palfun-foslup`! Look forward to a full public
announcement of this derivation scheme once the audit has taken place.

Now that that's all wrapped up, we are finalizing work on client-side tools
for generating and decrypting these wallets in a usable way. _Gavin_
`~ridlur-figbud` and _Will_ `~hadrud-lodsef` have been leading this effort, with
a non-trivial wasm assist from _Chris_ `~sigtus-hossyn` and _Mark_
`~palfun-foslup` (codenamed the Dutch Destroyer). We now have parity between the
front end crypto tools and their Hoon-side cousins.

A key part of this is also the Wallet application, which will allow you to
manage your assets easily. _Morgan_ `~hidrel-fabtel` has changed the Wallet
application architecture a bit to accommodate our wallet deriviation scheme and
we're working on getting those changes implemented. _Robert_ `~lodleb-ritrul`
is on loan from the Docs team to help us make sure that all of our documentation
and copy around these tools is crystal clear.

A thread connecting these projects is our concept of the Sigil, some of the
cryptic shapes you may have seen gracing these very updates. An urbit ship is
unique cryptographic property and a Sigil is the visual equivalent of your
pronounceable shipname. Sigils will grace our applications for interacting
with the Urbit Constitution, our new Landscape UI and many other places we've
dreamt up. Work on these Sigils has reached a good point and we're working on
integrating them into these applications.

Webtalk is not long for this world, into the breach will step: Landscape.
After a lot of prototyping and design iteration, we've settled on a feature
set that will help the Urbit community (that's you!) communicate and
collaborate to reach our next incarnation. Landscape will be on your computer
and in your pocket. _Chris_ `~sigtus-hossyn` and _Jimmy_ `~haptyl-wanwes` have
been hard at work hitting the details of the design implementation, including
nuances like disconnected and reconnected states and other interaction concepts
that we think you'll like. _Logan_ `~tacryt-socryp` has been doing double duty
on Mobile and improving `%hall` support for DMs. Needless to say, Sigils are
present throughout.

![](https://media.urbit.org/fora/updates/2018.8.23-update-2.jpg)

What about Arvo, you say? Well, the latest news is a veritable supercollision
of a merge between our various long running lines of work.
[Ford Turbo](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/),
whose development you've all been following closely, is now in the process of
being integrated with the rest of the our code, complete with not one but two
caches (thanks _Ted_ `~rovnys-ricfer`). _Elliot_ `~littel-ponnys` is taking on
the task of integrating Ford Turbo with various affordance we've added in
support of Landscape. _Joe_ `~master-morzod`, meanwhile, is integrating updates
to ames and the boot process occasioned by the Ethereum bootstrap. And finally,
_Curtis'_ `~sorreg-namtyv` long-anticipated improvements to Hoon are being
incorporated into all of the above.

The last of these changes will be of particular interest to new learners of
hoon, since one of their benefits is the ability to pretty print type
information; a useful tool when working in the %dojo.

_Josh_ `~taglux-nidsep` is closing out a revision of the docs to be released
very soon. We hope that the new docs and friendlier Goon will make the task of
learning Hoon less of a task and more of an adventure.

Next year on Mars!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.8.8 Update]]></title>
            <link>https://urbit.org/updates/2018-8-8-update</link>
            <guid>https://urbit.org/updates/2018-8-8-update</guid>
            <pubDate>Tue, 07 Aug 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.8.8`:

![](https://media.urbit.org/fora/updates/~2018.8.8-Update-1.jpeg)

The Interface team spent another week completing the new Urbit frontend. _Gavin_
`~ridlur-figbud` finished up his project for putting an image to your `@p`
("pat-P") (image is teaser). _Galen_ `~ravmel-ropdyl` and _Jimmy_ `~haptyl-wanwes`
did another round of design reviews for a couple of our interfaces. _Chris_
`~sigtus-hossyn` implemented Landscape functionality to reconnect to your Urbit
after a long period of disconnection (we _never_ leave `:talk`, so we of course
wouldn't know about that). _Logan_ `~tacryt-socryp` fixed some more iOS bugs and
implemented mobile in-app caching of Collections, making the app more
feature-complete. _Isaac V_ `~davtyr-nimren` continued the Collections redesign
(code [here](https://github.com/urbit/arvo/tree/collections-redesign)).

The Infrastructure team put another week in forming a more perfect kernel. _Ted_
`~rovnys-ricfer` continued bug hunting in his Ford Turbo cache implementation.
_Elliot_ `~littel-ponnys` has Ford Turbo integrated with all of Arvo now, but
some last steps are still needed to be able to fully remove old Ford from the
system. You can find Ted and Elliot's code
[here](https://github.com/urbit/arvo/branches/all?utf8=%E2%9C%93&query=ford-turbo),
and their technical updates are posted to Fora
[here](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/).
As Ford Turbo has approached completion, we've realized major performance
bottlenecks in our Hoon compiler. So we've called upon _Paul_ `~fodwyt-ragful`
to help make Hoon really fast. Ted's parallelism UP has also some gotten
comments since it was posted last week -- check out the proposal
[here](https://fora.urbit.org/proposals/posts/~2018.7.28..19.57.33..7ed3~/).

The Keys team got us another week closer to getting on chain. _Joe_
`~master-morzod` now has ships booting from the keys in our testnet contract.
_Travis_ `~rigdyn-sondur` finished implementing our much-needed `secp256k1`
crypto jet (code [here](https://github.com/urbit/secp256k1)). _Mark_
`~palfun-foslup` nearly completed his `argon2-wasm` library for key
generation/derivation. Our man _Chris_ `~sigtus-hossyn` is helping him integrate
it with our other front end libraries (code [here](https://github.com/urbit/argon2-wasm)). _Anthony_ `~poldec-tonteg` and _Morgan_ `~hidrel-fabtel` are busy folding all of this new functionality into
Urbit Wallet to help you manage your ships. _Robert_ `~lodleb-ritrul` is working
on the copy for all of these apps, so that their functionality is crystal clear
to users.

Lastly: We're throwing a party next Friday, August 17th. Link: [meetup.com: Urbit IRL ~2018.8](https://www.meetup.com/urbit-sf/events/253292678/). Be there!

See you on Talk, Martians.

---

Photo credit: Tlon
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.7.30 Update]]></title>
            <link>https://urbit.org/updates/2018-7-30-update</link>
            <guid>https://urbit.org/updates/2018-7-30-update</guid>
            <pubDate>Sun, 29 Jul 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.7.30`:

![](https://media.urbit.org/fora/updates/~2018.7.30-Update-1.jpg)

The Keys team worked more this past week on specifying and implementing the plan
to get the Urbit constitution on the Ethereum blockchain. _Anthony_
`~poldec-tonteg` and _Morgan_ `~hidrel-fabtel` have nearly completed updating
the specification for Wallet. _Will_ `~hadrud-lodsef` and _Keaton_
`~tonlur-sarret` have a better idea of how to create a smooth experience for
current address-space holders to generate their Ethereum keys and get them to us
to put in the contract. _Mark_ `~palfun-foslup` and _Travis_ `~rigdyn-sondur`
spent the week implementing more crypto jets (code:
[`urbit/argon2`](https://github.com/urbit/argon2)), and Mark is also working
on an `argon2` WebAssembly library (code:
[`urbit/argon2-wasm`](https://github.com/urbit/argon2-wasm)),
which will help us generate private keys during onboarding. _Robert_
`~lodleb-ritrul` is now working with us to write user documentation for all of
the processes that will be part of our key generation and management
applications. We can't wait for Urbit ownership to be cryptographically real.

![](https://media.urbit.org/fora/updates/~2018.7.30-Update-2.png)

The Infrastructure team spent the week making the Urbit computer more beautiful.
_Curtis_ `~sorreg-namtyv` worked more on Hoon improvements and started work on
the Tlon-official Hoon style guide. _Ted_ `~rovnys-ricfer` and _Elliot_
`~littel-ponnys` completed several Ford Turbo design changes and got all their
tests passing again, now working on completing caching implementation and Eyre
integration
(code [here](https://github.com/urbit/arvo/branches/all?utf8=%E2%9C%93&query=ford-turbo),
technical updates [here](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/)).
_Joe_ `~master-morzod` got full HTTPS support working on the testnet! Ted also
wrote up a new UP on his thoughts on Urbit parallelism. Check that out [here](https://fora.urbit.org/proposals/posts/~2018.7.28..19.57.33..7ed3~/).

The Interface team worked more on Landscape, our application to allow better
communication and collaboration. _Galen_ `~ravmel-ropdyl`, _Gavin_
`~ridlur-figbud`, and _Jimmy_ `~haptyl-wanwes` continued their iterative design
revision feedback process, and Landscape is looking good. _Chris_ `~sigtus-hossyn`
and _Logan_ `~tacryt-socryp` continued implementing the latest desktop/mobile
features to get the product ready to ship, as well as extending support for the
latest backend Landscape API's that _Isaac_ `~davtyr-nimren` has been improving.
Urbit is becoming more usable by the day.

Last but not least, the Documentation team continued doing `~zod`'s work helping
teach Urbit to the world. _Josh_ `~taglux-nidsep` extended his new Hoon docs to cover Hoon cores, an introduction to the Hoon standard library, and a couple of Hoon examples with very detailed walkthrough commentary (drafts [here](https://github.com/joshuareagan/doc-drafts)). And _Robert_ `~lodleb-ritrul` extended the current Hoon-standard-library documentation on random atom generation and atom scrambling, as well as the Hoon cores for computing modular and signed-integer arithmetic (`urbit/docs` pull requests [here](https://github.com/urbit/docs/pulls)). Very soon you'll actually be able to understand how Urbit works.

Also: we'll be hosting another party this month on Friday, August 17th. Save the date! Link: [meetup.com: Urbit IRL ~2018.8](https://www.meetup.com/urbit-sf/events/253292678/)

Okay! Have a great week.

---

Photo credit: [Studio Olafur Eliasson](http://olafureliasson.net/)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.7.20 Update]]></title>
            <link>https://urbit.org/updates/2018-7-20-update</link>
            <guid>https://urbit.org/updates/2018-7-20-update</guid>
            <pubDate>Thu, 19 Jul 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.7.20`:

![](https://media.urbit.org/fora/updates/~2018.7.13-Update-1.jpg)

The Keys team spent another week moving fast to get us on chain. _Anthony_
`~poldec-tonteg` and _Morgan_ `~hidrel-fabtel` worked on a new design for
Wallet, which will manage your Urbit address-space ownership. _Curtis_
`~sorreg-namtyv` and _Mark_ `~palfun-foslup` fortified the Constitution more.
_Will_ `~hadrud-lodsef` and _Keaton_ `~tonlur-sarret` worked to make sure that
existing address-space owners can safely and easily register their ownership
within the new system. More on this soon.

The Infrastructure team was hard at work this week. _Joe_ `~master-morzod`
merged much of his HTTPS work into the `collections` branch of Arvo and is onto
broader Arvo integration testing (code [here](https://github.com/urbit/arvo/tree/collections)).
_Ted_ `~rovnys-ricfer`
and _Elliot_ `~littel-ponnys` cleaned up new Ford (code
[here](https://github.com/urbit/arvo/branches/all?utf8=%E2%9C%93&query=ford-turbo)),
trimming off several hundred lines
of code and making it easier to reason about while staying within our desired
performance goals. _Curtis_ `~sorreg-namtyv` finished the new implementation of
the `?=` ("wut-tis") rune and designed the type analysis infrastructure for the
new noun printer. _Mark_ `~palfun-foslup` produced an Urbit-specific variant of
the Argon2 password-hashing function (code [here](https://github.com/urbit/argon2)).
_Travis_ `~rigdyn-sondur`, an old friend of Tlon, has also been writing crypto
jets this week, and those will go in the kernel soon.

The Interface team has had another great week of making Urbit more usable.
_Jimmy_ `~haptyl-wanwes` has been working on a new urbit.org, written in Sail.
_Galen_ `~ravmel-ropdyl` and _Gavin_ `~ridlur-figbud` have been reviewing and
finalizing some Landscape design edits and coordinating with the frontend team.
_Chris_ `~sigtus-hossyn` and _Logan_ `~tacryt-socryp` have been implementing the
updated designs on desktop and mobile and churning through issues. _Isaac_
`~davtyr-nimren` worked on a better backend JSON interface for the Collections
app and made sure that Collections is using all of the permissioning that Clay now offers.

And the Documentation team continued their quest to teach the world Hoon. _Josh_
`~taglux-nidsep` worked more on his new Hoon tutorials (drafts [here](https://github.com/joshuareagan/doc-drafts)).
_Robert_ `~lodleb-ritrul` successfully documented the Hoon standard library cores
for date/time and hashing (PR's [here](https://github.com/urbit/docs/pulls)).

Keep on Hooning, Martians. See you in `/urbit-meta`.

---

Photo credit: [OMA](http://oma.eu/news/from-ciam-to-cyberspace-architecture-and-the-community)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.7.13 Update]]></title>
            <link>https://urbit.org/updates/2018-7-13-update</link>
            <guid>https://urbit.org/updates/2018-7-13-update</guid>
            <pubDate>Thu, 12 Jul 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.7.13`:

> "A complex system that works is invariably found to have evolved from a simple
> system that worked. A complex system designed from scratch never works and
> cannot be patched up to make it work. You have to start over with a working
> simple system."

-[John Gall](<https://en.wikipedia.org/wiki/John_Gall_(author)>)

![](https://media.urbit.org/fora/updates/~2018.7.13-Update-1.jpg)

The Infrastructure team -- _Curtis_ `~sorreg-namtyv`, _Anthony_ `~poldec-tonteg`, _Joe_ `~master-morzod`, _Ted_ `~rovnys-ricfer`, _Elliot_ `~littel-ponnys`, _Mark_ `~palfun-foslup` -- worked on improving the core of the Urbit system:

- Curtis worked on improving Hoon: [`research-tome` Arvo](https://github.com/cgyarvin/arvo/tree/research-tome),
  [`research-tome` Vere](https://github.com/cgyarvin/urbit-1/tree/research-tome)
- Joe continued to implement in-Urbit HTTPS integration: [`https-acme-wip`
  Arvo](https://github.com/urbit/arvo/tree/https-acme-wip), [`https-proxy-config`
  Vere](https://github.com/urbit/urbit/tree/https-proxy-config)
- Ted and Elliot continued the state-machine reimplementation of new Ford: [`ford-turbo-state-machine`
  Arvo](https://github.com/urbit/arvo/tree/ford-turbo-state-machine),
  [updates](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/)
- Mark made crypto additions to the kernel: [`crypto-additions` Arvo](https://github.com/urbit/arvo/tree/crypto-additions)

The documentation team -- _Josh_ `~taglux-nidsep` and _Robert_ `~lodleb-ritrul` --
improved how we communicate how Urbit works:

- Josh continued work on the new Hoon tutorials: [`master` doc drafts](https://github.com/joshuareagan/doc-drafts)
- Robert put in more work improving the Hoon standard library doc: [docs pull
  requests](https://github.com/urbit/docs/pulls)

The Interface team -- _Galen_ `~ravmel-ropdyl`, _Anthony_ `~poldec-tonteg`, _Jimmy_ `~haptyl-wanwes`, _Gavin_
`~ridlur-figbud`, _Chris_ `~sigtus-hossyn`, _Isaac V_ `~davtyr-nimren`, _Logan_ `~tacryt-socryp`, and _Keaton_
`~tonlur-sarret` -- worked on Landscape (formerly MVE):

- Galen, Jimmy, and Gavin have continued work on Landscape's visual design
- Keaton worked on Landscape cloud onboarding on DigitalOcean
- Chris improved the desktop client, still in private alpha
- Logan improved networking in the iOS TestFlight app, still in private alpha
- Isaac V has been rearchitecting the Landscape backend
- Anthony has been getting the latest Landscape code onto the testnet: [`testnet`
  Arvo](https://github.com/urbit/arvo/tree/testnet)

The Constitution/Keys team -- _Mark_ `~palfun-foslup`, _Curtis_ `~sorreg-namtyv`, _Morgan_ `~hidrel-fabtel`, _Will_ `~hadrud-lodsef`, _Anthony_ `~poldec-tonteg`, and _Ben_ `~mirfet-hocbyt` -- worked to make Urbit computing cryptographically real:

- Curtis, Morgan, and Will have been fortifying the current proposed key ceremony, still in private draft mode
- Ben has been cleaning up Wallet: [`mercury` Wallet](https://github.com/urbit/etherwallet)
- Mark has updated our Constitution to ERC721 compliance, among other updates, and built out more of Jael: [`master`
  Constitution](https://github.com/urbit/constitution) [`research-constitution`
  Arvo](https://github.com/Fang-/arvo/tree/research-constitution)

We're alive and growing.

---

Photo credit: [Superstudio](https://en.wikipedia.org/wiki/Superstudio)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.7.3 Update]]></title>
            <link>https://urbit.org/updates/2018-7-3-update</link>
            <guid>https://urbit.org/updates/2018-7-3-update</guid>
            <pubDate>Mon, 02 Jul 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://media.urbit.org/fora/updates/~2018.7.2-Update-1.jpg)

Here's a short update from the team at Tlon for the week of `~2018.7.2`

The interface team -- _Galen_ `~ravmel-ropdyl`, _Jimmy_ `~haptyl-wanwes`, _Logan_
`~tacryt-socryp`, _Gavin_ `~ridlur-figbud`, _Chris_ `~sigtus-hossyn`, _Anthony_
`~poldec-tonteg`, and _Isaac V_ `~davtyr-nimren` -- worked more on MVE. Chris
deployed a new _command palette_ for MVE to our internal testnet which we've been
playing around with and are excited to ship soon. Isaac is re-architecting
Collections a bit. Logan has been buffing up his read/unread code for Hall/Talk.
The design team has been working for a while with our `@p` ship-naming scheme
for a cool new thing. Gavin made this visualization program of the current `@p`
syllables which we've been pretty entranced by:

![](https://media.urbit.org/fora/updates/~2018.7.2-Update-2.jpg)

The constitution team -- _Mark_ `~palfun-foslup`, _Curtis_ `~sorreg-namtyv`,
_Morgan_ `~hidrel-fabtel`, _Will_
`~hadrud-lodsef`, _Anthony_ `~poldec-tonteg`, and _Ben_ `~mirfet-hocbyt` -- worked more on fortifying our summer
key-ceremony gameplan. Mark completed a BIP32 key-derivation library in Arvo. Will has a solid outline for our ETH launch
plan, which we're now getting some feedback on from our crypto nerd friends. Ben, Anthony, and Galen have been scheming a
MyUrbitWallet redesign while we're still awaiting our final contract audits. Overall, everything here is coming together.
The latest [constitution](https://github.com/urbit/constitution), [Urbit wallet](https://github.com/urbit/etherwallet),
and [Arvo](https://github.com/Fang-/arvo/tree/research-constitution) code can all be found on GitHub. We're still a short
while away from launching all of this, but we'll keep you posted.

![](https://media.urbit.org/fora/updates/~2018.7.2-Update-3.jpg)

_Joe_ `~master-morzod` continued his HTTPS work, moving his development to an actual testnet to sort out the bugs
entailed by generating LetsEncrypt certificates and dynamically changing server configs on running ships. In doing so,
he's helped track down some of our gnarlier bugs (like [this one](https://github.com/urbit/arvo/issues/740)) and provided
some more food for thought for the inevitable Gall and Eyre redesigns. He's also chipping away at a UP describing all
this new, exciting functionality. We'll let you know when that comes out. Joe's
[Vere](https://github.com/joemfb/urbit/branches) and [Arvo](https://github.com/joemfb/arvo/branches) work-in-progrsss is
on GitHub.

_Curtis_ `~sorreg-namtyv` worked mostly on internal Tlon things this week, but you might get a kick out of his current
rendition of renamings for some of Hoon's symbols, pointed out in this recent Fora post: [_Symbol
renaming_](https://fora.urbit.org/general/posts/~2018.7.2..01.08.03..c4af~/).

_Ted_ `~rovnys-ricfer` and _Elliot_ `~littel-ponnys` continued work this week on new Ford. They've been hitting several
frustrating bugs, and the code they had wasn't as easy to reason about as they were hoping. So to help tackle all this,
they decided to start re-architecting parts of new Ford to track the statuses of builds with per-build state machines.
This will entail a pretty significant reorganization of the `+ford-state` date structure, but they're confident this will
simplify new Ford's semantics and help them get this project fully across the finish line. Ted and Elliot's latest
work-in-progress can be found is [here](https://github.com/urbit/arvo/branches/all?utf8=%E2%9C%93&query=ford-turbo), and
you can read their technical Fora updates [here](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/).

Finally, _Josh_ `~taglux-nidsep` and _Robert_ `~lodleb-ritrul` continue to strengthen our documentation. Josh is well
into Chapter 2 of his new tutorials, and Rob has a couple new standard-library documentation sections which turned out to
not be documented at all until now. Josh's in-progress work is [here](https://github.com/joshuareagan/doc-drafts); Rob's
latest pull requests are [here](https://github.com/urbit/docs/pulls).

And that's the way it is. Have a great week!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.6.21 Update]]></title>
            <link>https://urbit.org/updates/2018-6-21-update</link>
            <guid>https://urbit.org/updates/2018-6-21-update</guid>
            <pubDate>Wed, 20 Jun 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.6.21`

![](https://media.urbit.org/fora/updates/~2018.6.13-Update-1.jpg)

The interface team -- _Galen_ `~ravmel-ropdyl`, _Jimmy_ `~haptyl-wanwes`,
_Gavin_ `~ridlur-figbud`, _Chris_ `~sigtus-hossyn`, _Anthony_ `~poldec-tonteg`, and _Isaac_ `~davtyr-nimren` -- worked
more on MVE. We're getting incrementally closer to being able to release a public beta. Life has been active on the
testnet as the team coordinates to fix the last known bugs and design issues.

_Logan_ `~tacryt-socryp` noticed a lacking feature in Hall: read vs. unread messages, a common feature in most messaging
applications. Logan decided to embark on his first real Hoon project and successfully implemented this last week. You can
check out the code [here](https://github.com/loganallenc/arvo/tree/hall-unread), to be merged into MVE soon.

The constitution team -- _Mark_ `~palfun-foslup`, _Curtis_ `~sorreg-namtyv`, _Morgan_ `~hidrel-fabtel`, _Will_
`~hadrud-lodsef`, _Anthony_ `~poldec-tonteg`, and Texan _Ben_ `~mirfet-hocbyt` -- has been continuing to work to get us
on chain by the end of the summer. Mark has been fortifying some of the contracts and Arvo-side cryptography and Jael
functionality, while Ben and Anthony continue to finalize the control flow of our `MyUrbitWallet` fork. Curtis, Morgan,
and Will are striding forward on designing the key-launch ceremony, more details of which we'll publish soon. The latest
[constitution](https://github.com/urbit/constitution), [Urbit wallet](https://github.com/urbit/etherwallet), and
[Arvo](https://github.com/Fang-/arvo/tree/research-constitution) code with the latest Jael work can all be found on
GitHub.

_Curtis_ `~sorreg-namtyv` worked more on Hoon, continuing to improve face-wrapping (variable naming) around values. He's
also been working on a couple of new runes, like `^#`, whose designs aren't yet fully complete, but when they are, we'll
document and share with y'all. Curtis' research [Arvo](https://github.com/cgyarvin/arvo/tree/research-tome) and
[Vere](https://github.com/cgyarvin/urbit-1/tree/research-tome) code can be found on GitHub.

_Joe_ `~master-morzod` worked more on HTTPS this past week and got some of his work merged into the `urbit/arvo`
`collections` branch, which will go live with the MVE release. Included in the PR are new moves in Eyre and Ames to
support his reverse TCP proxy, HTTPS server configuration changes, and child-ship IP address changes. Additionally added
is a dynamic-DNS Gall app, which brings us closer to our envisioned ideal of getting `your-ship.urbit.org` to connect
directly to your ship's IP address, rather than going through Tlon's intermediary proxying ships. Our next step is to
deploy this to our internal testnet before releasing it into the wild. Joe's work can be found
[here](https://github.com/urbit/arvo/pull/752) on GitHub -- very exciting.

_Ted_ `~rovnys-ricfer` and _Elliot_ `~littel-ponnys` now nearly have a fully-integrated Ford Turbo. They can boot a ship
with a Clay that exclusively uses Ford Turbo and not old, slow Ford. Gall integration is also complete. Now they're
focused on finishing the caching implementation, as well as a new `%walk` schematic to perform a graph-search through the
available marks for data conversion. Ted and Elliot's work is [here](https://github.com/urbit/arvo/tree/ford-turbo) on
GitHub, and their more detailed updates are [here](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/)
as comments to their original Fora post.

And last, but not least, _Josh_ `~taglux-nidsep` and _Robert_ `~lodleb-ritrul` have continued their much-needed
doc-improvement work. Josh's in-progress drafts of his new Hoon tutorials are
[here](https://github.com/joshuareagan/doc-drafts), and Rob's latest pull requests improving the standard library docs
are [here](https://github.com/urbit/docs/pulls). If there's anything you feel should be documented and currently isn't,
feel free to write us a comment below.

May `~zod` be with you all. Have a great rest of your week.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.6.14 Update]]></title>
            <link>https://urbit.org/updates/2018-6-14-update</link>
            <guid>https://urbit.org/updates/2018-6-14-update</guid>
            <pubDate>Wed, 13 Jun 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.6.14`:

![](https://media.urbit.org/fora/updates/~2018.6.13-Update-1.jpg)

_Ted_ `~rovnys-ricfer` and _J_ `~leb / ~ribben-donnyl` had a great time in Boulder, CO last week at LambdaConf 2018. Ted
gave his same Ford talk he gave at the last meetup to a small group there. We should see the video recording of that
published in a few months when the editing process is finished. J's talk on Hoon was a success. He posted to Fora this
week with a link to his slides and talk turned into article form for Martian consumption. Check it out
[here](https://fora.urbit.org/general/posts/~2018.6.10..19.25.23..6f16~/)!

J also designed some [new T-shirts](https://urbit.threadless.com/). What a fan! We're working on designing some new
official ones ourselves, but until then, feel free to score one of these.

We breached again last Friday. People were hitting a [nasty Vere issue](https://github.com/urbit/urbit/issues/996)
between versions from a breaking change, but breaching fixed it. We posted a short reminder of post-breach steps to Fora
[here](https://fora.urbit.org/general/posts/~2018.6.9..08.37.48..f79a~/). Let us know if you're hitting any issues
getting back up and running in the new continuity era.

_Ted_ `~rovnys-ricfer` and _Elliot_ `~littel-ponnys` reunited this week after LambdaConf. Gall and Dojo on the
`ford-turbo` branch now both use new Ford. Next up is Clay, in tandem with one big necessary algorithm change: adding
support for the promotion of one-time builds, useful for things like generators. As usual, their code progress is
[here](https://github.com/urbit/arvo/tree/ford-turbo).

The interface team -- _Galen_ `~ravmel-ropdyl`, _Anthony_ `~poldec-tonteg`, _Jimmy_ `~haptyl-wanwes`, _Gavin_
`~ridlur-figbud`, _Chris_ `~sigtus-hossyn`, _Isaac_ `~davtyr-nimren`, and _Logan_ `~tacryt-socryp` -- has commenced
internal private alpha MVE testing on web and mobile. Our alpha Urbit iOS app is shipped to Apple's TestFlight, and we've
all been having a blast testing it out on our phones. New web Talk in MVE even supports image display. We can't wait to
ship this all soon -- just need to fix the last of bugs and design issues here and there first.

![](https://media.urbit.org/fora/updates/~2018.6.13-Update-2.jpg)

_Curtis_ `~sorreg-namtyv` worked more on Hoon. He's been working on generalizing name binding by replacing `+toga` in
`hoon.hoon` as part of the new Hoon doc integration. That work in progress is
[here](https://github.com/cgyarvin/arvo/tree/research-tome). He's also been working on designing the "launch ceremony"
for Urbit/Ethereum private keys with _Morgan_ `~hidrel-fabtel` and _Will_ for when we go on chain with our Urbit
constitution on ETH very soon. We'll publish details about all of this once we've squared everything away.

_Mark_ `~palfun-foslup` worked more on locking down the Urbit constitution by incorporating feedback from our audits and
putting more safeguards around how address space is transferred. Martian soil is too valuable to be lost through a
fat-fingered Ethereum transaction or, worse, malice! We've also been working with some contributors out Texas way to get
our MyEtherWallet fork up to speed with the latest, greatest contract work. You can check out those changes
[here](https://github.com/urbit/etherwallet/pull/29)

_Joe_ `~master-morzod` is cranking away at setting up a reverse TCP proxy (and all of the associated machinery), so that
we can scrap the Ames-based proxy currently done by ship.urbit.org and move over to real, live HTTPS termination for all
ships. This is a major undertaking and has required `~master` to touch a lot of different parts of the system: Eyre,
Vere, Ames -- you name it. Once his head is above water, he's going to write something up for us and tell us what he's
seen in his wanderings through the system.

And _Josh_ `~taglux-nidsep` and _Robert_ `~lodleb-ritrul` have spent yet another week making the docs more awesome.
Josh's new Hoon tutorials (WIP link: [here](https://github.com/joshuareagan/doc-drafts)) are nearing completion. Rob
opened up a couple more PR's improving the standard-library docs. You can check the latest `urbit/docs` pull requests
[here](https://github.com/urbit/docs/pulls).

There's also a third set of Hoon exercises which Josh posted to Fora
[here](https://fora.urbit.org/answers/posts/~2018.6.7..20.54.43..2261~/). Give them a shot!

No Mars Talk this week. Ted and Josh will return next week to talk about treaps, and where we're using them in Arvo.

That's it for this week!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.6.6 Update]]></title>
            <link>https://urbit.org/updates/2018-6-6-update</link>
            <guid>https://urbit.org/updates/2018-6-6-update</guid>
            <pubDate>Tue, 05 Jun 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from the team at Tlon for the week of `~2018.6.6`:

![](https://media.urbit.org/fora/updates/~2018.6.6-Update-1.jpg)

We hired somebody! We're happy to welcome to Tlon:

- _Will_ `~hadrud-lodsef` -- Will studied CS at Stanford and worked for years in VC. Among other things, he likes
  ceramics and decentralized systems. He's going to work on a mix of things for us, from operations to Urbit private-key
  distribution and management.

The interface team -- _Galen_ `~ravmel-ropdyl`, _Anthony_ `~poldec-tonteg`, _Isaac V_ `~davtyr-nimren`, _Jimmy_
`~haptyl-wanwes`, _Chris_ `~sigtus-hossyn`, _Logan_ `~tacryt-socryp`, and _Gavin_ `~ridlur-figbud` -- is narrowing in on
an alpha version of MVE, nearing readiness to start testing internally. Anthony and Isaac have been getting our internal
testnet set up, and Logan is ready to submit our alpha iOS app to Apple's TestFlight. We'll keep you posted about public
beta testing, on the way soon.

_Isaac V_ `~davtyr-nimren` finished an [in-Urbit static-site generator](https://github.com/urbit/arvo/pull/745) this
week. When merged, this will give you the option to easily host your urbit's static files through a production-ready Unix
web server like Nginx in tandem with Arvo's web server, Eyre. This way, you can still host fast collections while we
continue to work on Arvo's performance.

_Ted_ `~rovnys-ricfer` has been at LambdaConf 2018 this week spreading the good news of `~zod` and
non-lambda-calculus-based functional programming. Our good friend and galactic senator Justin LeBlanc `~leb` gave a talk,
_Hoon and You - A Functional Programming Perspective_. Hopefully we can get slides and a video for you soon.

_Elliot_ `~littel-ponnys` worked more on new Ford. It's now working as its own separate vane in the kernel, `%turbo`, and
it reloads itself on Arvo `|reset`s and `|reload`s. While old `%ford` still exists, the next steps are to integrate
`%turbo` with the rest of the system. Elliot has been working on a separate Dojo, _Dontjo_, that uses Turbo instead of
old Ford. New Ford work is [here](https://github.com/urbit/arvo/tree/ford-turbo), and Fora updates are
[here](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/).

_Mark_ `~palfun-foslup` has been wrapping up Urbit-on-ETH constitution work this week. We're just about in our final lap,
finalizing our audit reports, fixing the last of known bugs, upgrading the contracts to latest Solidity and OpenZeppelin
versions, and rounding our our test coverage, code comments and documentation, and ERC721 compliance. The latest contract
code can be found [here](https://github.com/urbit/constitution). We'll come out with an official email blast and
urbit.org post with more information when we're all ready to go.

_Curtis_ `~sorreg-namtyv` has been working more on Hoon. Notably, one new change on the table is switching the model-arm
rune from `+=` to `+$`, keeping it more in line with the `$` family of Hoon syntax relating to models. The feedback from
the community in `/urbit-meta` on this was positive. Additionally, he's been rethinking the `+toga` data structure for
dealing with faces (variable names) on Hoon values. His research branch is
[here](https://github.com/cgyarvin/arvo/tree/research-tome). We'll have more to report next week.

_Joe_ `~master-morzod` has been continuing work on the HTTPS project. Notably this week, Joe's been working on an
in-Urbit reverse TCP proxy, so that planets behind private networks / NATs can still have their data served to
`ship.urbit.org` via their star over Ames. With this last feature, in addition to Joe's mostly-completed `libh2o`,
LetsEncrypt, and dynamic-DNS Gall-app implementations, the fast and secure direct `ship.urbit.org` feature of MVE should
be primed to get tested into existence, then shipped. Joe's latest work-in-progress is
[here](https://github.com/joemfb/arvo/tree/reverse-proxy-notification).

_Josh_ `~taglux-nidsep` and _Robert_ `~lodleb-ritrul` blazed through more doc this week. Josh's [new Hoon
tutorials](https://github.com/joshuareagan/doc-drafts) are starting to come together. Rob has been improving the
standard-library docs and has open [several pull requests](https://github.com/urbit/docs/pulls), to be reviewed and
merged this week. The docs are getting better.

If you haven't already, give Josh's Hoon exercises a shot! (aka Hoon Bootcamp) You can find exercise set #1 on Fora
[here](https://fora.urbit.org/answers/posts/~2018.5.24/) and set #2
[here](https://fora.urbit.org/answers/posts/~2018.6.1/).

With Ted out this week and Josh focused on doc work, they're going to push back Mars Talk to next week. So, look out for
next week's update for the time and topic of Season 2, Episode 7.

One last reminder: [_there is no Urbit ICO_](https://urbit.org/updates/2018.5.29-no-ico). Anything else that you've heard
is wrong. Don't get scammed!

We hope you've been enjoying these weekly updates, now [actually weekly](https://urbit.org/blog/weekly-updates/).
`/urbit-meta` has been really active lately. Don't be shy to pop in and meet everybody.

See you around!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.5.30 Update]]></title>
            <link>https://urbit.org/updates/2018-5-30-update</link>
            <guid>https://urbit.org/updates/2018-5-30-update</guid>
            <pubDate>Tue, 29 May 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's an update from the team at Tlon for the week of `~2018.5.30`:

![](https://media.urbit.org/fora/updates/~2018.5.30-Update-1.jpg)

We had a great meetup last Friday. Thanks to Ted for talking about Ford, Grayson and Morgan for DJing, and everyone for
showing up! We'll keep you updated about the next one.

We performed a [continuity breach](https://urbit.org/docs/using/admin/#-continuity-breaches) last week. This means that,
if you haven't already, you need to recreate your urbit. The good news is: the network is faster, people are hanging out
in in `/urbit-meta`, and a couple of infrastructure changes were made to make `urbit.org` authentication and proxying a
bit more snappy. See [this post](https://fora.urbit.org/general/posts/~2018.5.26..03.57.28..7b26~/) for help getting set
back up.

_Curtis_ `~sorreg-namtyv` has been working more on data printing in Hoon. Still work-in-progress, the end result will
have new, simpler ways to express Hoon types, data you want to print, helpful conversion arms accessible via the standard
library, and a couple new runes. If you like deep language code and compiler internals, you can check out Curtis's
research branch [here](https://github.com/cgyarvin/arvo/tree/research-tome).

The interface team -- _Galen_ `~ravmel-ropdyl`, _Anthony_ `~poldec-tonteg`, _Logan_ `~tacryt-socryp`, _Chris_
`~sigtus-hossyn`, _Jimmy_ `~haptyl-wanwes`, and _Gavin_ `~ridlur-figbud` -- has been working more on MVE. We'll have more
to show in the next couple weeks.

_Isaac V_ `~davtyr-nimren` worked on Arvo and Collections last week. He implemented a query parameter in Eyre to support
setting the longpoll timeout duration manually, which solves an issue in the way of us doing background refreshes in our
iOS app we're developing. He also got Clay permissions logic into Collections so that the tool will support read-only,
write-only, and private/invite-only collections in addition to public ones. Lastly, Isaac's been working on a static-site
generator in Urbit to support more performance-ready web serving over Nginx in tandem with Eyre. The first step was
modifying Kiln to support batch-writing multiple files to Clay at once. Isaac's work-in-progress can be found
[here](https://github.com/ixv/arvo/branches) -- check it out if you're looking to start hacking near the border between
Arvo's interface and infrastructure.

_Ted_ `~rovnys-ricfer` and _Elliot_ `~littel-ponnys` finished _all_ of the new Ford Turbo schematics (Ford build types)
and a bunch more cranes (Ford runes). Their next step is to integrate new Ford with the current master kernel by loading
it in as a separate vane, then incrementally connecting the wires needed for it to start working together with real Arvo.
You can find Ted and Elliot's work [here](https://github.com/urbit/arvo/tree/ford-turbo). If you're into functional
programming, build systems, or just want to read the best Hoon code we have on display currently, check it out, and the
updates they've been posting to their Urbit Proposal
[here](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~).

_Mark_ `~palfun-foslup` worked on Jael, Urbit's new secret-storage vane, which we're also expanding to include the logic
for querying the state of the [Urbit consitution](https://github.com/urbit/constitution) which will go live on the
Ethereum blockchain in the coming months. Mark has been implementing the necessary Arvo `+gift`s and `+task`s of Jael's
to properly interface with the Urbit constitution via the Ethereum API, then update the local urbit's state of the land
registry and other contract data so that it can use it for networking and in other services. You can find Mark's
work-in-progress [here](https://github.com/Fang-/arvo/tree/research-constitution). Check it out if you're excited by
blockchains, or also just want to see what good, documented Hoon code looks like.

_Joe_ `~master-morzod` worked more on the HTTPS project. This week was mostly about refactoring the existing code by
adding comments, renaming some things, and improving the style. Safe to say that when this project is done, we think it
will be understandable. The ASN1 and PKCS libraries are mostly complete; progress will continue to finish up the last of
the libraries and necessary styling, then integrate this into current Arvo/Vere. Joe's work-in-progress is
[here](https://github.com/joemfb/arvo/tree/acme-wip).

_Josh_ `~taglux-nidsep` and _Robert_ `~lodleb-ritrul` made a bunch more progress on the docs. Josh has been adding more
to his [new WIP Hoon tutorials](https://github.com/joshuareagan/doc-drafts), and both Josh and Rob have gifted us with
several [pull requests](https://github.com/urbit/docs/pulls) documenting the simple but elusive `=,` rune and refactoring
much of the existing standard library doc. The docs are a great place to start learning and contributing. [Check them
out](https://github.com/urbit/docs) on GitHub, and [submit an issue](https://github.com/urbit/docs/issues), tagging Josh
and Rob, if you're confused by anything, or think something is documented wrong.

Josh and Ted also did a [Mars Talk](https://www.youtube.com/watch?v=IgQo5aSezK4) this week -- Season 2, Episode 6 -- to
help people get started with Hoon. They went through some simple onboarding steps and basic math functions to introduce
some of the fundamental concepts in Hoon. If you're new to Hoon and not sure where to start, check out that episode, and
feel free to leave comments below here for feedback.

Overall, work continues to wipe the slate of computing clean. More news next week.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[There is no Urbit ICO]]></title>
            <link>https://urbit.org/updates/2018-5-29-update</link>
            <guid>https://urbit.org/updates/2018-5-29-update</guid>
            <pubDate>Mon, 28 May 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
FYI: We are not conducting an ICO of any kind. Anything you have heard to the
contrary is wrong. Please be careful of scams.

Any future information about the distribution of address space will come from
urbit@urbit.org or [https://twitter.com/urbit](https://twitter.com/urbit).
Accept no substitutes!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.5.23 Update]]></title>
            <link>https://urbit.org/updates/2018-5-23-update</link>
            <guid>https://urbit.org/updates/2018-5-23-update</guid>
            <pubDate>Tue, 22 May 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's a short update from Tlon for the week of `~2018.5.22`:

![](https://media.urbit.org/fora/updates/~2018.5.22-Update-1.jpg)

We're hosting a meetup [this Friday](https://www.meetup.com/urbit-sf/events/250889557/) at the SF office. Ted will give a
quick update on new Ford, and then it'll be time to relax, listen to music (our friend Grayson will be playing records),
and talk IRL. Feel free to bring your laptop, and we'll install Urbit for you and give you a tour of Arvo.

This week, the interface team -- _Galen_ `~ravmel-ropdyl`, _Gavin_ `~ridlur-figbud`, _Jimmy_ `~haptyl-wanwes`, _Chris_
`~sigtus-hossyn`, _Isaac V_ `~davtyr-nimren`, _Logan_ `~tacryt-socryp`, and _Anthony_ `~poldec-tonteg` -- has continued
building the new Arvo frontend. Here's a teaser of something the desktop guys have been working on:

![](https://media.urbit.org/fora/updates/~2018.5.22-Update-2.jpg)

_Joe_ `~master-morzod` fixed an important performance issue in Vere where galaxy IP resolution has been happening
synchronously. This now works asynchronously, which should help take some load off of our stars. He also got support for
`/.well-known/*` LetsEncrypt paths working in Eyre and refactored a lot of parsing and cryptography code in Arvo as part
of his HTTPS-implementation work on his [personal WIP Arvo fork](https://github.com/joemfb/arvo/tree/acme-wip), to be
brought onto master soon.

_Keaton_ `~tonlur-sarret` got a demo AMI (Amazon Machine Image) working on Amazon Web Services with the Urbit binary
pre-installed, avoiding the need for the user to manually build from source. He plans on documenting this more and
working on a clean-slate onboarding system with _Morgan_ `~hidrel-fabtel` for our summer MVE release. But for now,
consider this a proof-of-concept for one way to get an Urbit running in the cloud more easily. You can follow the short
bulleted steps [here](https://gist.github.com/keatondunsford/8c19bc232650ec1adbb9b6c38954cd90) to get up and running .

_Ted_ `~rovnys-ricfer` and _Elliot_ `~littel-ponnys` are getting their new beautiful build system closer to the finish
line. New Ford supports nearly all of the functionality laid out in the original [Urbit
Proposal](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/) and passes all current tests. This past
week, Ted and Elliot have implemented more schematics and a bunch of the `+cranes`, or Ford runes. If you're into build
systems, check out their more detailed updates they've been posting as comments to the UP.

_Mark_ `~palfun-foslup` has been working on getting the Urbit/ETH integration logic into Jael, Arvo's new secret-storage
vane, to go live in the summer MVE release. Part of this is implementing direct support for querying the Ethereum
blockchain for the state of the the Urbit constitution smart contract. In this model, Urbit ships can choose to either
get this state directly from their parent stars or galaxies, or they can query the blockchain themselves. An important
step towards making Urbit address-space ownership real, Mark's work-in-progress can be found
[here](https://github.com/Fang-/arvo/tree/research-constitution).

_Josh_ `~taglux-nidsep` and _Robert_ `~lodleb-ritrul` have been continuing to do ~zod's work to improve the state of the
Urbit documentation. Josh has been writing a [new Hoon tutorial series](https://github.com/joshuareagan/doc-drafts) to
supersede the current Urbytes, while Robert has been blazing a trail through the current standard library docs, making
sure they're up-to-date and [improving them](https://github.com/urbit/docs/tree/rmariani-patch-6) as he goes. There's
been a lot of activity on GitHub recently. Don't be shy: [submit your first docs pull
request](https://github.com/urbit/docs), a classic rite of passage for the neophyte Hoon programmer.

Lastly, Josh, Ted, and Keaton will be live on Mars Talk tomorrow night, Wednesday at 8:30PM PST. We'll post the Hangouts
link in Talk. Tune in!

Overall, summer is getting closer, and we're excited about the work that's getting done. More this week.

See you on Friday!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.5.16 Update]]></title>
            <link>https://urbit.org/updates/2018-5-16-update</link>
            <guid>https://urbit.org/updates/2018-5-16-update</guid>
            <pubDate>Tue, 15 May 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Summer is around the corner, and the community has been working hard to make Urbit real. Here's an update on what new and exciting things have been happening:

> _Meta_: We're going to start posting these to the new _Updates_ section in Fora now -- and actually weekly!

On [Mars Talk last week](https://www.youtube.com/watch?v=gBd0TZyz_HE), _Anthony_ `~poldec-tonteg`, _Joshua_ `~taglux-nidsep`, _Ted_ `~rovnys-ricfer`, and _Keaton_ `~tonlur-sarret` talked about Sail, a DSL for representing XML/HTML data in Hoon. We built a simple web page with Sail and highlighted what features Sail gives you, like Hoon's type system, the Ford build system, and full access to Hoon programming inline. Check it out!

Tlon hired someone this week! We're excited to have with us:

- _Isaac V_ `~davtyr-nimren`

Isaac has solid Hoon and frontend chops, having already implemented server-side rendering of Tree pages for us a short while back. He'll be taking on some of the Collections/Streams work to help us get ready for our summer release.

_Galen_ `~ravmel-ropdyl`, _Anthony_ `~poldec-tonteg`, _Chris_ `~sigtus-hossyn`, _Gavin_ `~ridlur-figbud`, and _Jimmy_ `~haptyl-wanwes` have been working more on the new interface projects. Here's another leak:

![New visual leak](https://media.urbit.org/fora/updates/~2018.5.15-Update-1.png)

_Logan_ `~tacryt-socryp` almost has a complete demo of the new Urbit iOS app working. This includes TouchID login authentication, an encrypted local database, full support for the Talk/Hall API for Streams, and automatic background fetching, among other features.

_Curtis_ `~sorreg-namtyv` has been working more on several important major language feature improvements to Hoon: namely, pretty-printing of typed data, and simplifying the type system. Work can be found on his [research branches](https://github.com/cgyarvin/arvo), but we plan on publishing a more formal post of the changes and major documentation updates when they roll out in the coming months. More soon!

_Ted_ `~rovnys-ricfer` and _Elliot_ `~littel-ponnys` have made a bunch of progress on Ford Turbo. In addition to having a proof-of-concept solution for the main performance bottleneck of current Ford, they've now finished writing over half of the schematics (build types), implemented proper cache reclamation support, and they've gotten basic Clay integration functioning properly. You can find their work [here](https://github.com/urbit/arvo/tree/ford-turbo). They're posting more detailed updates as comments to their original [Urbit Proposal](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/).

_Mark_ `~palfun-foslup` has been wrapping up Urbit/ETH integration, and is now working on getting Jael, the new Arvo secret-storage vane, to compile. This would be a great addition to the summer release.

_Joshua_ `~taglux-nidsep`, _Robert_ `~lodleb-ritrul`, and _Keaton_ `~tonlur-sarret` have been getting lots of
documentation work done. They've seen several PR's go through to improve the Hoon standard library docs, simplify the
Hoon demo, update our examples to the latest syntax, improve the Urbit installation process, and more. Josh's
work-in-progress is happening [here](https://github.com/joshuareagan/doc-drafts/). The main docs are [on
GitHub](https://github.com/urbit/docs): if there's a piece of doc that's confusing to you, don't hesitate to file an
issue. Or better, submit a pull request.

_Joe_ `~master-morzod` is making strides on full HTTPS support for individual ships. He's implemented LetsEncrypt
support, ASN.1, and has Dynamic DNS functioning on our testnet. When all this work is done, `your-ship.urbit.org` should
connect automatically to the IP of the Unix machine your urbit is running on, rather than connecting to one of Tlon's
ships, which currently proxies Urbit network data through one of our stars, is slow, and is basically a straight-up
man-in-the-middle. Combined with private Collections and Streams, Urbit will be a lot more secure and usable within the
year.

Overall, we're making progress. More next week!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.4.14 Update]]></title>
            <link>https://urbit.org/updates/2018-4-14-update</link>
            <guid>https://urbit.org/updates/2018-4-14-update</guid>
            <pubDate>Fri, 13 Apr 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Replacing the internet is hard. Luckily, we have great people helping us do it. Here's what's new this week in Urbit:

We hired more people! Tlon is pleased to have with us:

- _Erik_ `~patnes-rigtyn` - Erik is our new head of operations. He'll be keeping us all fed and organized, as well as
  helping us with some legal things.
- _Joe_ `~master-morzod` - Joe... well, [you know Joe](https://joemfb.github.io/ez-urbits/). He's going to help us make
  Urbit easier.
- _Logan_ `~tacryt-socryp` - Logan is going to build us a mobile app, work on which has already begun! Very exciting,
  indeed.

_Ted_ `~rovnys-ricfer` and _Elliot_ `~littel-ponnys` have been working more on [new
Ford](https://fora.urbit.org/proposals/posts/~2018.3.15..04.24.35..a47f~/). They turbocharged the `+execute` algorithm to
use a worklist data structure. This will not only be simpler to reason about, but in the future, it will allow future
support for parallelization of builds at the Vere level in MapReduce fashion. Their work is on
[GitHub](https://github.com/urbit/arvo/tree/ford-turbo).

_Curtis_ `~sorreg-namtyv` has been working hard to make Hoon's type system less confusing, as well as working on the
problem of data inspection in Hoon. Now that his "structure-to-type" code is mostly done (going from an abstract type
definition to its real compiled internal representation), he'll soon be done with his "type-to-structure" reverse
converter for getting abstract structure data out of any sets of values. More soon, but all of this will supersede the
current mold system and help make Hoon easier to understand, we think.

_Galen_ `~ravmel-ropdyl`, _Anton_ `~pittyp-datfyn`, _Jimmy_ `~haptyl-wanwes`, _Gavin_ `~ridlur-figbud`, _Chris_
`~sigtus-hossyn`, and _Logan_ `~tacryt-socryp` have been putting in more hard work on the new Urbit frontend. It's all
coming together really nicely, and things seem to be on schedule for a big mid-to-late summer release.

We haven't posted an obscure graphic in a while. Here's one for the update to tide you over:

![](https://media.urbit.org/fora/updates/~2018.4.13-Update-1.png)

What it's for is totally top secret.

_Keaton_ `~tonlur-sarret` deployed sections to Fora, which will help categorize discussion content better and lead to better curation of StackOverflow-like questions and Urbit Proposals (UPs). He also merged some important pull requests into the system and deployed them to the network.

_Mikolaj_ `~ponmep-litsem`'s contributor work on moving Vere from Make to the [Meson](https://github.com/mesonbuild/meson) build system was merged this week. This solves several issues with bundling of dependencies, as well as making binary builds generally faster. Great work!

_Joe_ `~master-morzod` got his [HTTP pull request](https://github.com/urbit/urbit/pull/942) finally merged, which rewrites Vere's HTTP client and server to use the `h2o` library. This is great, as it will allow for full TLS termination in Urbit, which sets us up for full HTTPS connections to direct IP addresses of Urbit ships at `your-ship.urbit.org`, to be fully implemented soon.

_Robert_ `~lodleb-ritrul` has made a number of helpful PR's to the [Urbit docs](https://github.com/urbit/docs).

_Mark_ `~palfun-foslup` worked more on the Urbit constitution and put out some important fires caused by code-update syncs over the network and type mismatches. Computers are hard!

_Joshua_ `~taglux-nidsep`, Ted, Keaton, and Joe went on [Mars Talk](https://www.youtube.com/watch?v=EZKNLcdRbE0) to discuss the Facebook data scandal, the greater battle for privacy and personal computing, and Urbit's role in all of this. We think it turned out great.

All in all, life has been good over here. Now it's time for a good weekend. See you all on the network!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.4.7 Update]]></title>
            <link>https://urbit.org/updates/2018-4-7-update</link>
            <guid>https://urbit.org/updates/2018-4-7-update</guid>
            <pubDate>Fri, 06 Apr 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
As always, the Urbit community has been working hard this week to replace the internet. Here's a summary:

We're hosting [Hoon School](https://www.meetup.com/urbit-sf/events/249019207/) at our San Francisco office this Sunday. Come, bring your laptop, and we'll get you started building things in Urbit's language -- Hoon.

Tlon has brought on two new interns! We're excited to have with us:

- _Gavin_ `~ridlur-figbud` - Gavin's going to help us with some promising frontend design projects.
- _Robert_ `~lodleb-ritrul` - Robert's going to work with us on revamping our documentation, examples, and blog, writing
  high-quality original content. He has submitted several pull requests to the docs already this week, which have been
  merged.

_Galen_ `~ravmel-ropdyl`, _Anton_ `~pittyp-datfyn`, _Chris_ `~sigtus-hossyn`, and _Jimmy_ `~haptyl-wanwes` have been
continuing to advance the state of the new Urbit frontend.

_Mark_ `~palfun-foslup` has been working hard with _Curtis_ `~sorreg-namtyv` to bring the Urbit constitution into its
final, launchable state. He believes it's ready for its final security audit, which keeps us on track to launch it this
summer. You can find the latest contract code [here](https://github.com/urbit/constitution).

_Ted_ `~rovnys-ricfer` and _Elliot_ `~littel-ponnys` have assembled a basic prototype of the main engine of the new Ford
redesign. They've been improving the design as they go, posting updates as comments to the [original Fora
post](https://fora.urbit.org/posts/~2018.3.15..04.24.35..a47f~/). Their code can be found
[here](https://github.com/urbit/arvo/tree/ford-turbo).

Lastly, big shoutout to _Mikolaj_ `~ponmep-litsem` for his work on [Plato](http://plato.urbitetorbi.org:8080/plato.html),
which now allows remote Hoon code execution without logging in. This is a big step towards improving our developer
onboarding, as it will allow newcomers to experience interactive Urbit programming in the browser quickly without having
to wait to boot their own ship. See Mikolaj's original thread on GitHub [here](https://github.com/urbit/docs/issues/239).

We look forward to teaching some of you this Sunday the beginnings of the art of Martian functional programming. To all
else, we'll see you on the network. Have a great weekend, everybody!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.3.24 Update]]></title>
            <link>https://urbit.org/updates/2018-3-24-update</link>
            <guid>https://urbit.org/updates/2018-3-24-update</guid>
            <pubDate>Fri, 23 Mar 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
We've had a busy past few weeks here at Tlon -- here's an update:

We hired some people! We've added to the full-time team:

- _Chris_ `~sigtus-hossyn`
- _Jimmy_ `~haptyl-wanwes`
- _Morgan_ `~hidrel-fabtel`
- _Anthony_ `~poldec-tonteg`
- _Elliot_ `~littel-ponnys`

Tonight we're hosting a [meetup](https://www.meetup.com/urbit-sf/events/248852261/) at the Tlon office. It's a party.
Morgan is DJing. Galen's showing Beat Takeshi movies on the back wall. Bring your laptop, and we can write Fizzbuzz in
Hoon together. Or just relax, have some drinks, and talk to the weird array of people who also want to replace the
internet.

_Curtis_ `~sorreg-namtyv` is in the Netherlands this week visiting _Mark_ `~palfun-foslup`. They're self-auditing the
last parts of the [Urbit Constitution](https://github.com/urbit/constitution). While sitting in Gatwick Airport, Curtis
also wrote up some ideas he's been thinking about. Check out these essay drafts, posted to Fora:

- [The Urbit public record draft](https://fora.urbit.org/posts/~2018.3.23..03.42.41..ab6d~)
- [Spirit and practice of digital homecoming draft](https://fora.urbit.org/posts/~2018.3.22..19.46.35..3499~)

_Galen_ `~ravmel-ropdyl`, _Anton_ `~pittyp-datfyn`, _Chris_ `~sigtus-hossyn`, _Jimmy_ `~haptyl-wanwes`, and _Anthony_
`~poldec-tonteg` have been working more on the new Urbit frontend.

_Ted_ `~rovnys-ricfer`, _Elliot_ `~littel-ponnys`, and _Keaton_ `~tonlur-sarret` authored and published an Urbit Proposal
(UP) on New Ford:

- [UP 4 - Ford Turboencabulator](https://fora.urbit.org/posts/~2018.3.15..04.24.35..a47f~)

It's a monster post, but if you're a systems geek and want to read into the redesign of this important kernel module,
check it out.

Ted's and Elliot's daily Ford progress can be tracked here:

- [`urbit/arvo 'ford-turbo'`](https://github.com/urbit/arvo/tree/ford-turbo)

_Joshua_ `~taglux-nidsep`, Ted, and Keaton debuted _Mars Talk, Season 2_ on Wednesday night. To reboot the show, we gave
a high-level overview of the Urbit stack for new developers:

- [Mars Talk Season 2, Ep. 1: High-Level Overview of the Urbit Stack](https://www.youtube.com/watch?v=UaRZVxthVeY)

Subscribe to [Josh's channel](https://www.youtube.com/channel/UC3c0F4NhOD1LT5A1ShXEWiQ), and tune in weekly for all your
latest and greatest educational content and Urbit news.

See some of you at the meetup tonight, and the rest of you Hoons on the network.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.3.5 Update]]></title>
            <link>https://urbit.org/updates/2018-3-5-update</link>
            <guid>https://urbit.org/updates/2018-3-5-update</guid>
            <pubDate>Sun, 04 Mar 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
_Galen_ `~ravmel-ropdyl`, _Anthony_ `~poldec-tonteg`, _Chris_ `~sigtus-hossyn`, _Jimmy_ `~haptyl-wanwes`, and _Anton_
`~pittyp-datfyn` have continued the push toward the new Urbit frontend.

_Curtis_ `~sorreg-namtyv` has been working more on simplifying default value calculation in the Hoon type system.

_Ted_ `~rovnys-ricfer` and _Keaton_ `~tonlur-sarret` have a design for a better Ford caching and rebuilding architecture,
and are now converting it to a UP to be reviewed by the community.

_Mark_ `~palfun-foslup` submitted a [pull request](https://github.com/urbit/arvo/pull/651) that implements the _Keccak_
family of cryptographic hashing functions in Hoon, including `SHA-3`, `shake`, and `rawshake`. We'll need `keccak` to
integrate Urbit with Ethereum.

Also, [moons](https://urbit.org/docs/using/admin/#-moons) are back! You can run the `+moon` generator from your galaxy,
star or planet to create a ticket for a new moon. If you run your ship in the cloud and SSH in to use Talk, try booting a
moon on your laptop and using that for Talk instead. Messages you send from your moon will appear to have been sent from
your usual (parent) identity.

_Iceman_ `~littel-ponnys` wrote some deep thoughts on Clay, Urbit's filesystem, in this [meaty Fora
post](https://fora.urbit.org/posts/~2018.2.25..02.28.04..bd6d~/).

P.S. We're hiring! If you're interested, email `galen@tlon.io`.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.2.24 Update]]></title>
            <link>https://urbit.org/updates/2018-2-24-update</link>
            <guid>https://urbit.org/updates/2018-2-24-update</guid>
            <pubDate>Fri, 23 Feb 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
This week was another busy one at the Tlon office. Here's what we were up to.

This week we performed another [continuity breach](https://urbit.org/docs/using/admin/#-continuity-breaches). Now that we've fixed most of the bugs in new Talk, we think the network is going to be pretty smooth for a while. If you haven't already, follow our [setup](https://urbit.org/docs/using/setup) doc again to reboot your planet in this new continuity era. If you'd like a planet, [email me](mailto:keaton@tlon.io)!

We're hosting a [Meetup now](https://www.meetup.com/urbit-sf/events/247797527/) at the Tlon office. _Josh_ `~taglux-nidsep` is in town, and we all need a drink after the breach. Bring your laptop, stop by for a beer, and let us install Urbit for you. Or just relax and talk to people.

_Mark_ `~palfun-foslup` had a number of PRs merged this week for various bug fixes to Talk and Hall.

_Joe_ `~master-morzod` fixed several issues with Urbit's terminal.

_Anton_ `~pittyp-datfyn` made a one-line fix in Ford that fixed a major bug in cache performance. As a result, the website and Fora feel snappier.

_Ted_ `~rovnys-ricfer` and _Keaton_ `~tonlur-sarret` continued working on the new Ford design.

_Galen_ `~ravmel-ropdyl`, _Jimmy_ `~haptyl-wanwes`, and _Chris_ `~sigtus-hossyn` worked more on the new frontend.

_Curtis_ `~sorreg-namtyv` is finishing up work on Hoon type defaulting, and has started working on a new design for the Hoon pretty printer.

Josh, Ted and Keaton took a hiatus from Mars Talk this week to discuss future plans. We'll be back next week, better than ever.

Have a great weekend!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.2.17 Update]]></title>
            <link>https://urbit.org/updates/2018-2-17-update</link>
            <guid>https://urbit.org/updates/2018-2-17-update</guid>
            <pubDate>Fri, 16 Feb 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's what we've all been up to this week:

_Curtis_ `~sorreg-namtyv` this week, on behalf of `urbit.org,` [awarded Winter 2018 star grants](https://fora.urbit.org/posts/~2018.2.13..20.22.22..bddb~) to Urbit's top recent contributors. The winners this term were:

- _Gold_, _64 stars_: Joe Bryan `~master-morzod`
- _Silver_, _32 stars_: Joshua Reagan `~taglux-nidsep`
- _Silver_, _32 stars_: Mikolaj `~ponmep-litsem`
- _Bronze_, _16 stars_: Assaf Berg `~rophex-hashes`
- _Bronze_, _16 stars_: Matt Levan `~mastyr-bottec`
- _Bronze_, _16 stars_: Anthony Arroyo `~poldec-tonteg`

Thank you all again for helping bring Urbit to life!

_Galen_ `~ravmel-ropdyl`, _Jimmy_ `~haptyl-wanwes`, and _Chris_ `~sigtus-hossyn` have been progressing further on the new Urbit frontend.

_Anton_ `~pittyp-datfyn` has been working hard on making Urbit-flavored markdown, and subsequently, Fora, a lot less slow than it currently is.

_Mark_ `~palfun-foslup` submitted an [`urbit/arvo` pull request](https://github.com/urbit/arvo/pull/610) that implements permissions for Urbit's Clay filesystem, which Ted merged this week. Among other things, this will play a pivotal role in the new _Collections_ app actively being worked on, so that an Urbit user can store private notes, create invite-only fora and blogs, and collect a private archive of typed documents, all while maintaining referential transparency in the global immutable namespace.

_Ted_ `~rovnys-ricfer` and _Keaton_ `~tonlur-sarret` have been working on a design for the data structures and control flow for the next version of Ford, Urbit's build system. We'll post to Fora once we've revised it some more.

_Joshua_ `~taglux-nidsep` rejoined [Mars Talk this week](https://www.youtube.com/watch?v=--hvpMqIeSA) as host with Ted and Keaton for Episode 21. We decided to take a break from deep technical talk to chat about the proposed _Nock 4K_ spec (a cosmic event in the Urbit universe), Josh's dissertation, Vere parallelism, and Urbit as a personal command center to call out to Earth blockchains.

Have a great weekend, everyone!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.2.9 Update]]></title>
            <link>https://urbit.org/updates/2018-2-9-update</link>
            <guid>https://urbit.org/updates/2018-2-9-update</guid>
            <pubDate>Thu, 08 Feb 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
_Galen_ `~ravmel-ropdyl`, _Jimmy_ `~haptyl-wanwes`, and _Chris_ `~sigtus-hossyn` continue work on the new Urbit front-end.

_Ted_ `~rovnys-ricfer` and _Mark_ `~palfun-foslup` finished their month-long project of labelling the Arvo issues.

`~palfun` says:
After moving over Arvo-related issues from the Vere repository, Arvo hit >100 open issues. Knowing a lot is wrong is the
first step towards making a better product, but a big ol' pile of issues isn't really conducive to that. After
[proposing](https://github.com/urbit/arvo/issues/572) a set of labels for our repositories to use, `~rovnys` and I set
out to show all the issues some love.
Today we finally made it through the last of them! You can now look for issues that are
[easy](https://github.com/urbit/arvo/issues?q=is%3Aissue+is%3Aopen+label%3A%22difficulty+low%22) or [good for
contributors](https://github.com/urbit/arvo/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+contributor+issue%22) to
tackle. There's plenty of labels now for all your filtering needs. Internally, we'll try to get eyes on issues labeled
[RFC](https://github.com/urbit/arvo/issues?q=is%3Aissue+is%3Aopen+label%3A%22request+for+comments%22) and [help
wanted](https://github.com/urbit/arvo/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22) every so often.
While contributors can't add labels themselves, we'll make sure your issues get tagged correctly. Enjoy!

_Curtis_ `~sorreg-namtyv` has been helping Ted and _Anton_ `~pittyp-datfyn` with Ford. He's also continued his work on
improving default values for types in Hoon.

_Keaton_ `~tonlur-sarret` has been working on a super-secret project that he cannot discuss. Loose lips sink ships ...

_Mark_ `~palfun-foslup` has submitted a PR for Clay permissions. We just completed a second round of review, and Mark is
now doing more testing.

_Iceman_ `~littel-ponnys`, _Joe_ `~master-morzod`, and Ted [had some
fun](https://fora.urbit.org/posts/~2018.2.9..21.50.49..709f~/) discussing various forms of persistence in Clay and Gall
in `urbit-meta`.

Keaton and Ted demoed some Urbit web app examples in [Mars Talk Episode 20](https://www.youtube.com/watch?v=emWy1Afe4qY).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.2.5 Update]]></title>
            <link>https://urbit.org/updates/2018-2-5-update</link>
            <guid>https://urbit.org/updates/2018-2-5-update</guid>
            <pubDate>Sun, 04 Feb 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
_Galen_ `~ravmel-ropdyl`, _Jimmy_ `~haptyl-wanwes`, and _Chris_ `~sigtus-hossyn` worked on the upcoming frontend overhaul, including the new homepage, the _Collections_ and _Streams_ apps, and the primer. _Ted_ `~rovnys-ricfer` and _Anton_ `~pittyp-datfyn` continued to work on Ford.

_Curtis_ `~sorreg-namtyv` worked on fixing the defaulting behavior in Hoon. "The future is not wonky," he declares.

_Keaton_ `~tonlur-sarret` tested Isaac V's Fora implementation using his static `ren/tree`. It works.

_Mark_ `~palfun-foslup` gave a presentation at the FOSDEM open source conference in Belgium. Video can be found [here](https://www.youtube.com/watch?v=U-QBW6QIDto).

_Isaac V_ `~davtyr-nimren` completed the initial version of the static `ren/tree` replacement. The _Collections_ and _Streams_ apps are now being built on top of this foundation. See the [`mve` branch](https://github.com/urbit/arvo/tree/mve) of Arvo to track development.

_Paul_ `~fodwyt-ragful` [fixed a performance issue](https://github.com/urbit/urbit/pull/920) in unifying large nouns.

_Iceman_ `~littel-ponnys`'s testing framework has been merged into master. To use the framework to write unit tests, see the [user guide](https://github.com/urbit/arvo/blob/master/web/testing.umd). This pull request also includes a Hoon port of [Haskell's Prelude](https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html), which is [now available](https://github.com/urbit/arvo/blob/master/lib/new-hoon.hoon) as an alternate version of the Hoon standard library, including [unit tests](https://github.com/urbit/arvo/tree/master/tests/new-hoon). Discussion of this subject can be found on [Fora](https://fora.urbit.org/posts/~2017.10.17..04.09.16..7eb8~/).

On [Mars Talk Episode 19](https://www.youtube.com/watch?v=q3Fjnv0RcR0) (our 20th episode!) this week, Keaton and Ted explained Ford, Urbit's functional reactive build system.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.1.13 Update]]></title>
            <link>https://urbit.org/updates/2018-1-13-update</link>
            <guid>https://urbit.org/updates/2018-1-13-update</guid>
            <pubDate>Fri, 12 Jan 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
This week:

**Galen** `~ravmel-ropdyl`, **Curtis** `~sorreg-namtyv`, and **Jimmy** continued work on the upcoming Urbit primer for the website.

**Keaton** `~tonlur-sarret` is almost done converting the documentation to Urbit-flavored markdown, building on the work of **Isaac** `~davtyr-nimren`.

**Ted** `~rovnys-ricfer` has been working with Anton on better Ford caching performance.

**Anton** `~pittyp-datfyn` has been doing some work with **Joe** `~master-morzod` on [automated Vere memory verification](https://github.com/urbit/urbit/pull/915).

**Mark** has a [PR to fix a talk / Gall bug](https://github.com/urbit/arvo/pull/538) and is now working on updating Clay's API to support multiple files per request, which will support the Ford caching improvements.

**Iceman** `~littel-ponnys` has submitted a [PR implementing a unit testing framework](https://github.com/urbit/arvo/pull/539) for Hoon, which had been in the works for a long time.

**Mikolaj** `~ponmep-litsem` has been making lots of good contributions recently, including reporting several GitHub issues and work on an Elm web frontend for Urbit, which he's using to implement [Plato](https://github.com/mikolajpp/plato), an in-browser Hoon editor.

Finally, in [Mars Talk this week](https://youtu.be/oX7TFJ5qzr4) Ted wrote a Gall app using a timer from Behn with help from Keaton and **Josh** `~taglux-nidsep`.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.1.6 Update]]></title>
            <link>https://urbit.org/updates/2018-1-6-update</link>
            <guid>https://urbit.org/updates/2018-1-6-update</guid>
            <pubDate>Fri, 05 Jan 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Short week this week as we recover from the holidays. The biggest news item is that our fork of MyEtherWallet is now
complete!

Feel free to download it and try it out: https://github.com/urbit/etherwallet

Thanks to _Anthony_ `~poldec-tonteg` for building it and to Mark for testing it.

_Mark_ `~palfun-foslup` has diagnosed [a tricky bug](https://github.com/urbit/arvo/issues/533) involving what appeared to
be one-way communication in Gall. More updates on that forthcoming.

_Galen_ `~ravmel-ropdyl` has been working on the Urbit primer that will become the new urbit.org landing page. That's in
review now.

_Curtis_ `~sorreg-namtyv` has been helping out with the primer and has begun work on an HTTP cache in Vere to help with
web performance. That should synergize nicely with upcoming Ford fixes.

_Ted_ `~rovnys-ricfer` has been modernizing his and Anton's work on Ford caching to work with new Hoon and Arvo.

_Keaton_ `~tonlur-sarret` has been helping Ted with Ford. With Mark's help, he also moved Fora onto a standalone ship to
improve the loading times of the rest of urbit.org. All the old links still work, but Fora's true home is now at
[https://fora.urbit.org](https://fora.urbit.org).

_Isaac_ `~davtyr-nimren` has made some [more
progress](https://github.com/ixv/arvo/commit/bc52d9fc494399c2063cfa7817046d180b6f78d5) on the new static webpage serving
(`ren/tree`).

Early 2018 should see a lot of usability improvements. We're looking forward to being able to ship them soon.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.12.22 Update]]></title>
            <link>https://urbit.org/updates/2017-12-22-update</link>
            <guid>https://urbit.org/updates/2017-12-22-update</guid>
            <pubDate>Thu, 21 Dec 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
This past week:

_Mark_ `~palfun-foslup` has continued to fix bugs in new `:talk`. We've finally reinstated our public chat stream [urbit.org/stream](https://urbit.org/stream), which had been down since the breach, and as far as we know all the major, show-stopping `:talk` bugs have now been fixed. All currently known `:talk` bugs can be found on our [github issues page](https://github.com/urbit/arvo/issues). Mark, with some help from Ted, has also been working on reproducing and diagnosing [an old Clay bug](https://github.com/urbit/arvo/issues/501) that popped up again recently involving failed filesystem syncing across ships. We now know how to fix the bug, so that's up next for Mark.

_Ted_ `~rovnys-ricfer` submitted a [PR](https://github.com/urbit/urbit/pull/910) that fixes a long-standing performance bug in Urbit's event-processing model, where effects wouldn't be performed until the whole queue of input events had been processed. The PR is currently in review. He's also resumed work on the Ford caching fixes that he and Anton had been working on before the breach. It's a difficult project, but once it lands, the dreaded 504 errors when loading urbit.org should finally cease.

_Anton_ `~pittyp-datfyn` has been working on the `:collections` app, which will replace and generalize `:fora`. This work is nearing completion. This work will likely land with the frontend overhaul that Galen is leading.

_Isaac_ `~davtyr-nimren` has contined to make progress on the new version of `ren/tree`, Urbit's web publishing frontend. The new system has now matured enough that Keaton has been able to translate several of our docs pages to it.

_Keaton_ `~tonlur-sarret` has been chugging along on converting Urbit's documentation to the new `ren/tree`. He also booted up a new web ship to run urbit.org, since the old one had gotten verklempt.

_Galen_ `~ravmel-ropdyl` has continued work on the revamped Urbit frontend, including a base.css and a redesigned look and feel and more diagrams, explanations, and blog posts. _Jimmy_ and _Chris_ are working with him on this project. He's also been working with Anton on the `:collections` app.

_Anthony_ `~poldec-tonteg` has fixed several more bugs with [Urbit's fork of myetherwallet](https://github.com/urbit/etherwallet).

_Curtis_ `~sorreg-namtyv` has continued working on Hoon performance. Performance of his branch is currently estimated at 30% faster than master.

_Joshua Reagan_ `~taglux-nidsep` and Ted had Mark and Keaton on [Mars Talk episode 13](https://youtu.be/CfdoGY0u044) and they live-coded a Gall app.

We also threw what was generally considered to be a pretty good party last night. It was a nice way to end the year. Happy holidays from Mars!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.12.16 Update]]></title>
            <link>https://urbit.org/updates/2017-12-16-update</link>
            <guid>https://urbit.org/updates/2017-12-16-update</guid>
            <pubDate>Fri, 15 Dec 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Greetings, intrepid Martians. Thanks for bearing with us these past couple weeks as we pushed through the breach into a new continuity era. It's been a bit of a bumpy ride, but the turbulence is finally beginning to calm down.

Last Thursday night, we performed the continuity breach, bringing with it some deep changes to the Hoon language, a parser for a new markup language for web publishing, and an entirely new `:talk` app. Those changes had been in the works since the beginning of the summer, and we spent the past month or so preparing the breach itself. We pushed the breach out knowing there would likely be some bugs, with the explicit intent of using the deployment to find and fix those bugs as soon as possible.

Here's what's been going on since the breach:

- Urbit is somewhat slower than it was -- Galen may have exaggerated when he said it's 300x slower, but it is noticeable. _Curtis_ `~sorreg-namtyv` is working on fixing a major performance issue in the Nock output of the Hoon compiler involving constants not getting folded at compile-time. I assure you, no one is more upset about Urbit being slow than the people who work on it all day long ... we'll fix it.
- New `:talk` is working, more or less. There are a few bugs that we're still working on, including some fixes for urbit.org/stream, which is currently down. _Mark_ `~palfun-foslup` has been putting out fires like crazy, and due to his efforts, with some help from _Ted_ `~rovnys-ricfer` and _Anton_ `~pittyp-datfyn`, new `:talk` is getting under control.
- _Keaton_ `~tonlur-sarret` has updated the docs for new Hoon, and also improved the links and organization. _Joshua_ `~taglux-nidsep` has also made some docs improvements.
- _Isaac_ `~davtyr-nimren` is progressing on server-side rendering for web publishing, using the new `udon` markup language. Latest code (still a work in progress) can be found [here](https://github.com/ixv/arvo/tree/153ae2e35e77c7453601f84f956be3fe4509c104/ren/tree).
- _Ted_ has started working on designing a system to run automated stress tests of a fleet of Urbits, sort of like a DIY botnet. This should help us hit more bugs _before_ pushing code to the live network, many of which only appeared at "web scale."
- _Anthony_ `~poldec-tonteg` now has a working alpha of an [Urbit fork of myetherwallet](https://github.com/urbit/etherwallet) (design by _Galen_), with usage instructions. We haven't gone live on Ethereum yet, but you can still check this out to see a glimpse of the future.
- _Galen_ `~ravmel-ropdyl` and _Jimmy_ have been working on an Urbit primer to help explain whatever it is we do here.

There have also been two Mars Talk episodes since our last update:
[What is Urbit? Panel Discussion](https://www.youtube.com/watch?v=hqACJVSJc5s&t=3703s)
[Learning about Clay, Urbit's Filesystem](https://www.youtube.com/watch?v=aJqNmUMYHHg)

We're holding a [meetup](https://www.meetup.com/urbit-sf/events/245925902/) at our office next week. No presentations this time, just a party.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.12.2 Update]]></title>
            <link>https://urbit.org/updates/2017-12-2-update</link>
            <guid>https://urbit.org/updates/2017-12-2-update</guid>
            <pubDate>Fri, 01 Dec 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
This week Tlon has mostly focused on testing the upcoming continuity breach. We also fixed some compiler problems, made
progress on restructuring web publishing to use server-side rendering, and have started working on closing some of arvo's
oldest open pull requests. From the community, we're excited to report that `~master-morzod` has an initial
implementation of SSL termination in vere.

_Ted_ `~rovnys-ricfer` has been working on the [urbit fleet
repo](https://github.com/urbit/fleet/tree/e20400315bbea2091579b7beaa36eb50bbbd2796), which we use for spawning testnets.
The repo now works with the new `urbit` command-line arguments that are part of the breach, and it's now at the point
where we can launch ships from galaxies all the way down to comets. We've been using it to test various aspects of
Urbit's multi-ship functionality, such as `:talk` and filesystem syncing. Turns out there is a bug with filesystem
syncing in master, so we're going to have to fix that before breaching.

_Anton_ `~pittyp-datfyn` has knocked out a bunch of items in our breach checklist. Some highlights:

- Fixed single-sign-on
- Cleaned up a bunch of old unused code
- Reorganized `:hood` libraries
- Lots of testing

_Keaton_ `~tonlur-sarret` has been working with Anton on the breach checklist. He also updated the docs and examples to
reflect the changes made in hoon `%143` (which will be deployed with the breach) and helped Ted debug some urbit/fleet
problems.

_Curtis_ `~sorreg-namtyv` has made a number of improvements to hoon's defaulting system (bunting). Part of the work
included fixing an inconsistency in how hoon determined which subtype of a fork type would be chosen as default. After
fixing that, he implemented a cache for those defaults, which improved compilation speed by 10-20%. This code has been
merged into Arvo's master branch. He's still working on a parallel defaulting system, which might go even faster.

_Galen_ `~ravmel-ropdyl` and Jimmy have been working on the new urbit.org homepage, which will be Tlon's next priority
after the breach. This will feature a complete redesign using a new base.css to provide a standardized look and feel for
the Urbit web experience.

_Mark_ `~palfun-foslup` / `~palnup-salwyx-mortyl-silfyl--digrel-pitbud-dorsym-livpyl` has been working with
~poldec-tonteg to troubleshoot some issues with Urbit's Ethereum constitution. He's still waiting for the rest of Tlon to
test his [monumental PR](https://github.com/urbit/arvo/pull/452) for new talk, which he submitted a couple weeks ago. Now
that we have the fleet repo working, we can use it to test this work more thoroughly. This week he also made some changes
to Hall, which he has expressed in haiku form:

> the hall has opened,
> circles form to admire,
> people's collections.

He also says:

> Or if you want something slightly more serious:
> Hall has received some more fixes and quality of life improvements since I opened the PR. It's > never been more ready
> for the breach! I'm already working on something interesting that uses > it: an interface for managing your own notes,
> blogs and foras. Complete with filesystem, storage, and hall notifications!

_Joe_ `~master-morzod` has written an implementation of SSL termination in vere. This will allow your Urbit to serve true
end-to-end-encrypted HTTPS, as opposed to Tlon's servers operating as man-in-the-middle, which is not a viable long-term
solution. This has been an important piece of missing functionality, so we're excited to see it start to come together.
Latest code can be found [here](https://github.com/joemfb/urbit/tree/346de776c5fabe3e02fecb7cab3d1652e4cc46e3).

_Isaac_ `~davtyr-nimren` has been building the next generation of Urbit's web publishing system, currently located in the
ren/tree directory of Arvo. This new system, instead of serializing data down to the client to be fetched after the
initial page load, will perform the HTML rendering on the server. This is now possible because of the integration of our
Udon markup language with the Hoon compiler. This allows us to include Udon files in other Udon files using Ford runes.
The new system is much simpler and should improve page load time. Once we've written our planned Vere HTTP cache, this
new paradigm should also improve the coherence of that cache. This system is mostly complete now, and Isaac is now
working on smaller bugfixes.

There was also a [new episode of Mars Talk](https://youtu.be/1xcjnBu6qFo) with Ted and Joe discussing Hoon's type system.

Those are the highlights from this week. Back to breaching!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.11.14 Update]]></title>
            <link>https://urbit.org/updates/2017-11-14-update</link>
            <guid>https://urbit.org/updates/2017-11-14-update</guid>
            <pubDate>Mon, 13 Nov 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
As usual, we're guilty of wanting to write code more than prose. Last time we
announced our plans for Ethereum integration. This month we'll stick to basic
project status:

## Fall release goals and status

_Curtis, Ted, Paul_

Sometime in the next few weeks, we'll ship the Hoon 143 / Vere 0.5 release.
This release will of course be a continuity breach. The mighty engine is still
running in the lab while we screw on the last bells and make sure the boiler
isn't leaking oil, steam or memory. Currently, Curtis is fighting memory leaks
while Ted and Paul make sure the memoization cache can actually get reclaimed.

We want this fall 2017 Urbit testnet release to be reasonably rugged across the
board. It is not a production network and its keys remain test keys. However,
it should not crash, sink, etc.

This is new. For previous releases, it wasn't a realistic goal to keep ships
from sinking, or salvage every pier. It's just incredibly disruptive and
unpleasant in a pseudonymous network to sink people's identities. In this era,
if your ship sinks, please (a) post an incident report to the Urbit fora; (b)
know that we will strain every fiber to help you wrest it from Poseidon's grim
grip.

Furthermore, although there will be no direct formal continuity between this
release and the next one, we will provide tools to directly convert any data
in your urbit. So, in case you actually do put meaningful datas in your urbit,
you won't have to convert your datas completely by hand. Again, we will do
everything to help.

## Hoon 143

_Curtis, Iceman, Ted, Anton, Mark_

Curtis has spent most of 2017 quasi-surreptitiously in "auteur mode," trying to
complete his initial authorship of Hoon. After this release he promises to work
only on Arvo and above.

Hoon 143 is not perfect, but it will do for a while. Nothing in Hoon 143 is so
bad it's embarrassing. No one has any need to wait for it to stabilize. Any
errors in the above must be fixed by Hoon 142.

Hoon 143 establishes a set of standards and conventions which define modern,
high-quality code. Most of the Urbit codebase isn't quite to this standard.
Changing this includes removing the use of deprecated language features, then
removing support for the deprecated features (to create Hoon 142). Someone
should definitely do this work.

Here are some of the things Curtis has done to Hoon, without asking anyone's
permission. (Did Godard ask permission?) On some of these things he had fellow
conspirators -- Iceman was an equal contributor on the decorators, the team of
Ted, Anton and Mark on Udon.

Big changes in Hoon 143:

- Hoon 151's "electroplating," which replaced Hoon 164's "vulcanization,"
  has been replaced by 143's "repainting." This means wet gate namespacing
  works, so you can write `(weld ~[1 2] ~[3 4])` and get `~[1 2 3 4]` instead of
  `error: %mull-bonk-b`.
- There's now only one wide syntax `{a/term b/term}` becomes `[a=term b=term]`.
  This is like Hoon 164 syntax, but without the ubiquitous, and horrible, prefix
  comma. The price is modes.
- Decorators: formal syntax for adding documentation to types, available at
  runtime for reflexive help and diagnosis.
- In addition to the Sail dynamic XML syntax (which everyone forgets about, and
  which is basically JSX in Hoon), Hoon now has an embedded, Markdown-flavored
  rich text language: Udon. Few dynamic document platforms have this kind of
  range -- one file, with everything from code to tree-structured data to styled text.
- Keywords, which everyone despised, have been fully eradicated.

Curtis is done with Hoon and will never again change or improve it.
He may offer occasional opinions. Ted and Iceman are the new maintainers of
Hoon (including all of hoon.hoon and zuse.hoon, excluding Arvo models).
Anything all they agree on is probably good.

## What's not in this release

_Curtis_

2017 was also the year we learned the lesson that, while Urbit is awesome and
makes many system-software problems trivial, it is not so awesome that a team
this small can advance two branches at once. This fall 2017 release is a
classic, Microsoft-style stick save, cutting off about half of the research
("master" or "cc-release") branch and merging it back with splints and bandaids.

What got cut (this work is mostly coded, but not fully tested / integrated):

- The all-new event system in Vere, the all-new Arvo kernel with correct whitepaper-style lifecycle function
- The all-new (not just repaired) Ames (network) vane
- Ted and Anton's the mostly-rewritten Ford (build) vane
- Mark's rewritten Talk app (now Hall)
- The all-new Jael authentication vane
- The new generalized console library

There is plenty of other stuff that needs to go into our next release. Some of
it is described below.

## SPA rendering and build system

_Ted and Anton_

Ever notice how urbit.org gives 504 errors far too much? Hell, it probably
504-ed when you tried to load this page. This is clearly a problem.

Perhaps we could hack our way around it — but, as usual, we prefer to get to the
root of the problem. When you request a webpage from an Urbit we use our build
system, Ford, to produce it. Then our single-page app, Tree, renders and builds
the page in the browser.

There are two problems with the current system:

The Ford cache is cleared every time something in Clay changes.

On the client side, pages are built through multiple requests.

To fix (2) we want to move to a system where each page is a single static build.
This means doing 'server side rendering' with Ford — rather than having the
client make multiple requests for every page component.

The basic parts of this are done. We implemented a subset of markdown in Hoon
and added some new runes to Ford. This means you can write files that include
other files without any JSX or client side craziness.

(1) is a bit more complicated, and has taken up quite a bit of Anton and Ted's
time. We've implemented a new cache algorithm, which is designed to promote
unchanged content across revisions. The algorithm seems correct, but doesn't
properly promote unchanged content in all cases.

With these two things actually completed we'll be able to get much snappier page
loads. The next step is properly terminating SSL at an individual ship — but
more on that next month.

The details of this project are outlined in UP1 - Ford Caching Redux:
[fora/posts/~2017.10.19..04.47.50..c107~/](https://urbit.org/fora/posts/~2017.10.19..04.47.50..c107~/).
More on UPs below.

## New primer

_Isaac, Galen and Jimmy_

One thing we still don't do a particularly good job of is communicating about
what Urbit is. Even to savvy tech and crypto folks.

We're working on a new, illustrated, single-page explanation to go up on
urbit.org. The text is coming together and we're starting to work on design.

## Nock tutorials

_Josh and Galen_

Josh is a PhD student who has a lot more teaching experience than we do. To
boot, he's convinced that Nock is incredibly simple and can be taught to just
about anyone. So, he put together a few video tutorials.

We're touching up the look and feel — but they should go up in the next week or
so.

## ETH contracts

_Mark and Curtis_

Working from Curtis' designs, Mark has helped us implement the Urbit
constitution as a set of ETH contracts. They're off to the auditors, but the
code lives here: [github.com/urbit/constitution](https://github.com/urbit/constitution)
for public scrutiny.

## MyEtherWallet

_Anthony and Galen_

We want to make interacting with the Urbit ETH contracts as easy as possible.
Especially for people who aren't necessarily particularly familiar with
interacting with dApps.

So, we designed an Urbit-specific frontend for MyEtherWallet. And Anthony, who
actually knows Angular, has been helping us implement it. He has been working
privately, but progress will be visible here:
[github.com/urbit/etherwallet](https://github.com/urbit/etherwallet) soon.

## UPs

_Keaton, Ted and Galen_

About a month ago we were discussing how we'd really like to be more transparent
about the projects we undertake. And, we'd really like to have a way of
cataloging projects we discuss but can't take on.

Enter the UP or 'Urbit Proposal'. UP0 gives an outline for what a UP should
contain:
[fora/posts/~2017.10.19..03.45.26..dbec~/](https://urbit.org/fora/posts/~2017.10.19..03.45.26..dbec~/).

## Jaque, an independent interpreter in Java

_Paul_

Paul is delighted to announce Jaque, an independent implementation of Urbit
using Graal/Truffle on the JVM.

Jaque is not just another Nock function -- it boots an actual Urbit pill to a
working dojo prompt. Jaque has no compiler jets and has exposed several jet
mismatches in Vere. It works and is reportedly quite snappy. Paul is still
tuning the interpreter, changing it from a tree interpreter to a small bytecode,
because Graal does not like big stacks and tree interpreters make big stacks.
He'll say more about it when he considers it done, which is not yet.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.10.17 Update]]></title>
            <link>https://urbit.org/updates/2017-10-7-update</link>
            <guid>https://urbit.org/updates/2017-10-7-update</guid>
            <pubDate>Mon, 16 Oct 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
`~master-morzod` joins Mars Talks to talk about the Urbit operating system. The core team and contributors talk about how to best teach Urbit. Ted explains Hoon casting and does a full expansion of the Nock macros to draw a better connection between Hoon and Nock.

- [Mars Talks, Ep. 2](https://www.youtube.com/watch?v=kh4Ai5YXFaA) hosted by `~taglux-nidsep` with guest `~master-morzod` on Arvo, the Urbit operating system. [Discussion on Fora](https://urbit.org/fora/posts/~2017.10.5..03.57.51..f4c0~/)
- [The Absolute State of the Urbit Docs](https://github.com/urbit/docs/issues/137#issuecomment-333444336), a conversation on GitHub between `~taglux-nidsep`, `~sorreg-namtyv`, `~rovnys-ricfer` and `~master-bottec`. [Discussion on Fora](https://urbit.org/fora/posts/~2017.10.3..03.04.45..b532~/)
- [`~rovnys-ricfer` on Hoon casting](https://github.com/urbit/docs/pull/201#issuecomment-333546648). [Discussion on Fora](https://urbit.org/fora/posts/~2017.10.3..01.53.05..07b3~/)
- [Nock macro expansion: A clear explanation that anyone can understand](https://urbit.org/fora/posts/~2017.10.6..23.50.35..fb74~/) by `~rovnys-ricfer`
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.9.29 Update]]></title>
            <link>https://urbit.org/updates/2017-9-29-update</link>
            <guid>https://urbit.org/updates/2017-9-29-update</guid>
            <pubDate>Thu, 28 Sep 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Galen and Curtis comment on Urbit and the blockchain wars. Curtis and a new fan discuss the ideal Urbit virtual machine. `~poldec-tonteg` joins Mars Talks to spread the gospel of Urbit web development. A new contributor makes it easier to sync Urbit files during development.

- [Urbit and the blockchain wars](https://urbit.org/blog/2017.9-critique/) blog post. [Discussion on Fora](https://urbit.org/fora/posts/~2017.9.25..20.34.38..8e27~/)
- [A question by James Bowery from urbit-dev](https://urbit.org/fora/posts/~2017.9.26..23.26.32..1066~/)
- [Mars Talks, Ep. 1](https://www.youtube.com/watch?v=lX0xx70TcJE) hosted by `~taglux-nidsep` with guest `~poldec-tonteg` on Urbit web development. [Discussion on Fora](https://urbit.org/fora/posts/~2017.9.28..04.10.26..a4bb~)
- [urbit-sync](https://github.com/ngzax/urbit-sync) by `~migsyr_tarnux`. [Discussion on Fora](https://urbit.org/fora/posts/~2017.9.29..11.58.54..4dd1~)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit and the Blockchain Wars]]></title>
            <link>https://urbit.org/blog/urbit-and-the-blockchain</link>
            <guid>https://urbit.org/blog/urbit-and-the-blockchain</guid>
            <pubDate>Sun, 24 Sep 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/urbit-and-the-blockchain-1.jpg)

One core principle of the Urbit network is that _Urbit doesn't take sides_.
This is true in all kinds of conflicts -- and especially blockchain wars.

We're [moving the Urbit PKI onto Ethereum](https://urbit.org/blog/2017.9.20-bootstrapping-urbit-from-ethereum/)
not because we like Ethereum, but because it's the most practical thing for
Urbit right now. This is not a moral or aesthetic choice.

Some have objected to this decision. Some of these objections are excellent.
The rest are understandable.

Let's review our decision, responding to objections along the way. Not everyone
has to agree on everything. No one should stay confused. And we welcome
further comment.

## Urbit is not endorsing or supporting Ethereum

There are many technical criticisms of Ethereum. We agree with many of these
criticisms -- even most. But still more important: Bitcoin is the strongest
chain. If Bitcoin could directly enforce Urbit's PKI rules, we'd use Bitcoin,
for this reason alone. (That said, Ethereum may be less exposed to Chinese
politics.)

We chose ETH because it is the strongest _computational_ chain. It is certainly
stronger than the way we're storing the Urbit land registry now: GitHub, plus
internal records.

Urbit is not endorsing Ethereum. Urbit is not creating any appreciable monetary
demand for Ethereum. Urbit is not even locked in to Ethereum: with a fully
self-governing constitution, the Urbit galaxies can decide to migrate to another
consensus engine, or no consensus engine, or even our own consensus engine, any
time we like.

And even if the whole Ethereum network unexpectedly implodes, and stops
generating meaningful new blocks, we (or more generally: the set of active
Urbit galaxies) cannot abandon the social power to manually hard-fork the
network. Ultimately, the Ethereum contract is just a hardcoded address in a
piece of Urbit source code.

Let's address each of these points at a little more length.

## On moving to a blockchain

The first point to remember: our choice wasn't between Ethereum and nothing. It
wasn't between a blockchain and nothing. It was a choice between 21st-century
tools and 20th-century tools.

The current Urbit land registry is divided into parts stored in various places:
GitHub commits, database records held by Tlon Corporation, and insecure keys on
a test network. This might have been fine, for us, in 2015. In 2017, it's
borderline unacceptable.

## On choosing a chain

Our first decision point: whether the public chain enforces the rules of Urbit,
or just logs raw data that anyone can interpret.

The simplest procedure, with the strongest blockchain, would be just to encode
each Urbit event as raw (OP_RETURN) data on the Bitcoin blockchain. Or we could
use another simple layer on top of Bitcoin; classic "colored coins," for
instance.

The resemblance between Urbit land-registry titles and colored coins is one we
noticed a long time ago, of course. For a long time it wasn't that relevant,
because colored coins remained largely theoretical.

The larger problem is just that a non-computational blockchain can't enforce the
specific rules of the Urbit land registry (like the right of a star to create
specific planets).

You can put arbitrary data into a blockchain and enforce it off-chain. This
strikes us as unsatisfactory, though. For instance, you have to define the
semantics of erroneous or malformed operations. If this is not done perfectly,
it's a short road to major weirdness. Also, your interpretation tools are a
special-purpose one-off not shared with anyone.

There are other second-order "virtualchains" (Blockstack is one example), which
build computation layers on top of arbitrary chains. These tools are interesting
and cool. They are also quite young. As is Urbit, so we need all the maturity
we can get.

Also, our use case, as a land registry, is quite simple -- we don't have any
desire to pay (in complexity) for power we don't use. A two-layer solution
just seems to leave more room for bad weirdness.

## As normal Urbit state?

The original design was for Urbit to host its own primary copy of the PKI state,
not mirror some external master.

As more people start believing in Urbit, this makes us extremely nervous. Being
the single source of truth implies a strong commitment to security and
continuity. Urbit needs to get there, but it isn't there yet.

Trust in the security, continuity, and general maturity of Urbit needs to
develop gradually. An Urbit that isn't ready to store crypto-assets can still
be a great product. But it can't be a great product if its supposedly valuable
keys are in fact insecure, yet needed to operate on the network.

In short: we can't follow this original plan. It has the same chicken-egg
problem we discussed [last time](https://urbit.org/blog/2017.9.20-bootstrapping-urbit-from-ethereum/).

## An Urbit consensus engine?

Urbit is itself a deterministic computer. Building a consensus computer within
Urbit, which is actually a general-purpose OS, is an attractive long-term
possibility.

But Urbit lacks the principal feature of Ethereum: deterministic performance.
In both Ethereum and Urbit, the semantics of a computation are precisely
defined. In Ethereum, the computation's cost is also precisely defined.

This would be quite hard to do in Urbit. We traded deterministic performance
off for semantic simplicity. Designing a consensus computer without a
performance definition is a research problem.

We have solved a number of research problems here at Urbit. Could we build an
Urbit blockchain? This problem doesn't seem utterly intractable. For instance,
we could leverage the semi-trusted hierarchy in some direction resembling proof
of stake.

One thing is certain, though: research problems don't solve themselves
overnight. If you have any ideas on this one, give us a holler.

In any case, if Urbit got its own consensus engine, it's obvious that we'd
simply copy the state of the Urbit PKI on Ethereum, and shut it down. Or we
could migrate to another computational blockchain which works better than
Ethereum.

## An existing computational blockchain

So we need an existing, mature, computational blockchain. There are only two
major candidates: ETH and ETC (Ethereum Classic).

It's no secret that we prefer the governance model of ETC. It's also no secret
that the whole Ethereum system, especially Solidity, isn't exactly put together
in the way we would do it.

But an optimal governance model is just one virtue among many others we need to
consider. ETH's network capitalization is 25x that of ETC. Its hashrate is 15x.
Its tooling support -- in software, hardware, vaulting, exchanging, etc -- is
considerably stronger.

ETC's governance model is Bitcoin's: code is law. For the network, this is
better. But we are considering threats to Urbit, not threats to the rest of
Ethereum.

ETH has embraced discretionary human governance. It's quite plausible that this
will lead to total political collapse. But the human political structure of ETH
seems reasonably strong at the moment. It's relatively difficult to imagine
successful, near-term "proof of Vitalik" attacks via Ethereum on Urbit. Political
conflict tends to develop over longer periods of time, giving us room to migrate.

Ultimately we decided that the minority power of ETC outweighs the governance
issues with ETH. This is of course how imperfect standards win. Betamax had
better resolution than VHS.

## One reminder

For Bitcoin maximalists in particular (some of our best friends are Bitcoin
maximalists), it's important to note that (besides the gas price of
transactions) putting Urbit on Ethereum _does not create any net monetary demand
for Ethereum_.

Yes, you will get an Urbit ship through an Ethereum transaction. However, no
value stays in ether. If you want to buy a ship with bitcoin, you are just
going through a conversion layer. These conversion layers work pretty well
these days. If you have a religious objection to handling altcoins, have a
friend help.

Bitcoin maximalists understand that all monetary energy should concentrate in a
single currency. But land isn't money. And the technical details of the
implementation of the Urbit registry -- whether `OP_RETURN`, Ethereum, or GitHub
-- have no effect on Bitcoin supply and demand.

## Another reminder

Ethereum is not using Urbit. Urbit is using Ethereum. We know every cool
alternative band that gets signed to a major label says this, but we mean it.

Urbit, as a land registry, is almost a textbook example of very weak, boring use
of a computational blockchain. We're not expecting a lot out of Ethereum.
Ethereum does not feel like a system whose technical envelope should be pushed.
We have no intention of pushing it.

Moreover, the ability to vote formally in an Ethereum constitution will allow us
to migrate in a cohesive way to _any other formalization of the Urbit PKI_.
This could be another Ethereum contract. Or another blockchain.

This "clean escape" implies that Ethereum is still operating normally, or at
least normally enough to conduct a galaxy vote. What could happen to Ethereum?
The blockchain could stop generating new blocks; it could fork; it could be
filtered by some kind of collective attacker; it could even start accepting invalid transactions. What seems implausible is destruction of all copies of the whole chain.

When Ethereum ceases to be functional or trustworthy for any reason, a "dirty
escape" becomes necessary. The galaxy operators need to identify the last point
in the Ethereum chain at which the Urbit constitution remains valid, copy that
data to the new primary record, and resume from there.

But unlike other blockchains that have wrestled with human-centric governance,
Urbit still has a formal procedure for making this decision. With the Ethereum
chain compromised, we no longer have an automated system that implements the
rules. The rules remain, though. Humans have spent thousands of years
following non-automated rules.

Basically, we're just using ETH as a self-validating ownership record. So long
as the chain isn't destroyed and owners retain their secrets, Urbit retains the
power to migrate to any record that works better.

## And one literally constructive criticism

One excellent criticism (credited to `@sorpaas`) is that just having the Urbit
galaxies mirror the state of Urbit's Ethereum constitution is insufficient.
This design gives Urbit nodes a choice: either mirror the whole Ethereum
blockchain (which is ginormous and certainly not shrinking), or don't validate
the Urbit PKI at all.

In Urbit, if your parent galaxy is sending you fraudulent reports about the
blockchain (any blockchain), you have a very serious problem which goes way
past blockchains. It's time to switch galaxies.

The trust relationship between an urbit and its parent is like the trust
relationship between you and a gas station. For all you know, what's coming
out of the hose could be Welch's grape juice. But why have you never, ever worried about cheap surplus vegetable products destroying your engine?

ExxonMobil has no business motivation to ruin its customers' engines. If it
did, it would just destroy its business, and gain… what? If you don't have an
attack motivation, you don't have a threat model. If you don't have a threat
model, you don't have a threat. This is why we don't tend to worry about
"parent attacks" in Urbit.

But that said: there's no reason not to make Urbit's cryptographic structure as
strong as possible. If you don't want to trust your gas station -- you
shouldn't have to. We don't need to eliminate reliance on trust. We do prefer
to _minimize_ it.

Therefore, the Urbit Ethereum mirror needs to track all the Ethereum
transactions that touch the Urbit constitution, and propagate these raw
transactions into Urbit. Urbit nodes can check the transactions and their
signatures themselves, without relying on Ethereum. Then, anyone in Urbit can
validate the Urbit PKI without an Ethereum node.

(We don't anticipate running a node _in_ Urbit, eg an EVM in Hoon -- for now,
galaxies will just RPC to a local Unix node.)

## And in closing

We appreciate everyone's feedback and hope no one remains confused.

We're happy to address any remaining concerns -- and happier still if someone
finds a mistake on our end. If you have a good counterargument, now is better
than later!

Fora thread for discussion is here:
[urbit.org/fora/posts/~2017.9.25..20.34.38..8e27~](https://urbit.org/fora/posts/~2017.9.25..20.34.38..8e27~).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.9.23 Update]]></title>
            <link>https://urbit.org/updates/2017-9-23-update</link>
            <guid>https://urbit.org/updates/2017-9-23-update</guid>
            <pubDate>Fri, 22 Sep 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Galen and Curtis publish Tlon's plans for bootstrapping the Urbit PKI on the Ethereum blockchain. Ted creates a cheat sheet for Hoon. An Urbit podcast is born. The community talks about searching filesystems and cryptographic hashes.

- [Bootstrapping Urbit from Ethereum](https://urbit.org/blog/2017.9-eth) blog post. [Discussion on
  Fora](https://urbit.org/fora/posts/~2017.9.20..22.56.04..47ce~)
- A [Hoon cheat sheet](https://storage.googleapis.com/media.urbit.org/docs/hoon-cheat-sheet-08-26-17.pdf) by
  `~rovnys-ricfer`. [Discussion on Fora](https://urbit.org/fora/posts/~2017.9.18..22.31.06..24d5~)
- [On Searching Filesystems](https://urbit.org/fora/posts/~2017.9.16..06.19.33..72a4~) by `~littel-ponnys`
- [Mars Talks, Ep. 0](https://www.youtube.com/watch?v=LFalNG4eTqU) hosted by `~taglux-nidsep` with guest `~rovnys-ricfer`
  of Tlon on the fundamentals of Urbit. [Discussion on Fora](https://urbit.org/fora/posts/~2017.9.21..04.31.08..9ae7~)
- [Exploring Urbit](https://www.youtube.com/watch?v=OOQ2Do6jAi4) by Jordan Leigh of Decypher Media with guest
  `~tonlur-sarret` of Tlon. [Discussion on Fora](https://urbit.org/fora/posts/~2017.9.22..23.09.25..c613~)
- [To Understand Blockchains, You Should Understand Cryptographic Hashes
  First](https://fitseb-ropnux.urbit.org/blog/Cryptography2/) by `~fitseb-ropnux`. [Discussion on
  Fora](https://urbit.org/fora/posts/~2017.9.19..18.39.11..ebaa~/)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Bootstrapping Urbit from Ethereum]]></title>
            <link>https://urbit.org/blog/bootstrapping-urbit-from-ethereum</link>
            <guid>https://urbit.org/blog/bootstrapping-urbit-from-ethereum</guid>
            <pubDate>Tue, 19 Sep 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
_TL;DR:_

We've decided to launch Urbit's constitution as a system of Ethereum contracts.

We'll instantiate a land registry for Urbit address space; an ERC20 "spark"
token which is burned to create a generic star; and a voting system for
self-governance. We'll also create template contracts which galaxies can use to
auction stars, and stars to distribute planets.

## A bit of background

One thing we realized after the last sale was, 'oh hey, the network has been up
for about a year.' Not bad! It wasn't that long ago that we were rebooting the
universe every few weeks. We still have plenty of work to do — but Urbit has
matured to the point where public ownership of the network really should be
cryptographically real.

But even when the servers stay up, Urbit is still a testnet and remains
centralized in practice. We (Tlon) retain the ability to reset the network keys
at any time. This just isn't very 2017.

In theory, Urbit doesn't need a blockchain, because real estate moves slowly.
In digital real estate, as opposed to digital currency, a low-friction,
zero-trust solution to the double-spend problem isn't an economic necessity.

In practice, though, we have a hard chicken-egg problem. In the current design,
the key you use to secure your urbit is the same key that you use to sign your
network packets. Abstractly, this is the right design -- you want one
definition of who owns an identity.

But concretely, since Urbit keys are valuable, you don't want to put them in an
operating system that isn't generally recognized as systematically secure. It's
hard to achieve this status while you're a testnet. So the virtuous cycle never
gets started.

Moving the Urbit land registry to Ethereum is an easy and obvious solution to
this problem. If your urbit is owned by an offline Ethereum key, there's now a
mature ecosystem for protecting this property. And its security doesn't depend
on the security of Urbit. So, we realized, maybe Urbit actually does need a
blockchain for its land registry. While the system matures, we can bootstrap
off of Ethereum, without changing the design of the Urbit cryptosystem.

And best of all, you can get your Urbit star or planet entirely through the
blockchain, without interacting with any centralized database or payment
mechanism. So we're really living in 2017.

Sounds good, right?

It does sound good. Although, as usual, we care about making things that _work_
above all else. So, rather than a 'announcing the Urbit token sale' post, this
is going to get fairly technical. We want to start the discussion about how
this change is going to work, and how it's going to get implemented. We'll save
the hype for later.

First, we'll walk through the costs and benefits of using Ethereum. Then,
we'll refresh our memories on how the Urbit address space works, and finally
we'll walk through some of the details of how we plan on implementing this.
We've thought quite thoroughly about these things, but public criticism is
really important.

## Weighing the choice of Ethereum

Our engineering style is to build the whole stack, from axioms to UI, from
custom, super-minimal parts. When these parts don't fit perfectly, we rewrite
them until they do. With a few exceptions, such as crypto algorithms, Urbit
doesn't reuse existing code or designs, depend on existing tools, or expect
outside contributors to solve problems essential to a complete experience.

Instinctive minimalism is essential in a custom full stack. The best solution is
always to not solve the problem. The natural engineering response to the
pre-blockchain difficulty of solving Byzantine consensus agreement was: do we
really need it?

### The case against Ethereum

Since Urbit network address space is a land registry, not a currency,
transactions are low-frequency. A low-frequency transaction system can succeed
economically even if it has high friction. The double-spend problem, which
consensus computing solves, becomes easy or at least tractable given high
friction.

We reinvent the wheel if we have to, throw it away if we can. So depending on
Ethereum goes against all Urbit's instincts.

Let's enumerate the problems, as critically as we can:

And Ethereum's user experience is notorious; its governance is suspect and
unstable; its dilution rate is unconscionable; its dev environment is full of
bugs and misfeatures; in short, it's a classic MVP. It has only one real goal:
success. It seems to be doing pretty well with that.

We prefer [SLC](https://blog.asmartbear.com/slc.html) to MVP. Urbit under
construction is fun to play around in. But we certainly won't ask real users or
real developers to set foot in Urbit until their experience is truly simple,
lovable and complete. The original iPhone set the bar for this, and we'll get
as close as we can.

### The case for Ethereum

It's obvious that Urbit has a practical problem in deploying a self-hosted PKI.
When does the testnet become a realnet? You wouldn't put real, valuable keys in
your urbit, until you know the system is mature and secure.

But how does anyone know that Urbit is mature until more daring users have used
it with real, valuable keys? But who wants to be the first person to hop into
the box?

There is no clear way to bootstrap past the testnet phase. Except, well, reboot
Urbit onto an existing blockchain, with a tested and reasonably-secure
key-handling infrastructure, that can also validate the Urbit PKI rules. Then
each user can decide on their own whether sensitive data is safe in their own
urbit.

## An Urbit refresher

Maybe some people are here because they know what Ethereum is, but not so much
Urbit.

For those of you not familiar, let's try to refresh your memories.

### What Urbit is

One simple way to think about Urbit is as a "personal blockchain." Like a
blockchain, Urbit is a deterministic virtual computer. Its semantics are defined
by a frozen lifecycle function, which maps its event history to its current
state. But, unlike a blockchain, an Urbit instance is a private computer for one
user, not a public record for everyone.

Urbit's lifecycle function is a nano-interpreter called Nock. A typed functional
language, Hoon, compiles itself to Nock. An event-driven OS, Arvo, is written in
Hoon. Everything above Nock can upgrade itself over Urbit's own overlay packet
network, Ames. Ames is live and stable with test keys.

Our Urbit interpreter runs on any Unix machine. The Urbit server is a
single-level store -- both database and application engine. Every Urbit event is
a transaction. Urbit is semantically frozen and cannot call out to Unix.

Your Urbit instance is your personal server. Your urbit should eventually
contain and manage your whole digital life. You may compute at home or in the
cloud, based on your security/privacy tradeoff, but Urbit's formal semantics
makes ships trivial to migrate. You'll never be locked in to one computing
provider.

### The Urbit address space

An Urbit address is called a "ship." A ship is a network address, a
cryptographic identity, a pronounceable name, and a permanent memory. A ship's
name is just its numeric address, written in a syllabic base-256.

Smaller addresses mean shorter, more memorable ships. Ships are classified in a
hierarchy: 8-bit "galaxies" (like `~dyl`), 16-bit "stars," (`~ropdyl`), and
32-bit "planets" (`~ravmel-ropdyl`). Galaxies and stars are network
infrastructure. Regular users have planets. The tight 32-bit address space makes
names short enough to remember, and costly enough to deter Sybil attacks.

Planets are created by their prefix star; stars are created by their prefix
galaxy; galaxies were created by the founders. Parents assist their children,
providing essential services like peer-to-peer packet routing, but don't own or
control them. The prefix is just an initial default -- a ship can switch to any
parent that's willing to adopt it.

## Summary of the integration model

In the new integrated model, every planet, galaxy or star is owned by an
Ethereum address. The secret that controls this address is the ship's "master
key."

The master key is not needed to operate the ship and should not be stored on it,
at least not until Urbit is more mature. Master keys should be kept as "cold" as
possible. They are only used to perform lifecycle operations on your ship, by
signing Ethereum transactions which are sent to the Urbit constitution.

We'll fork an open-source Ethereum browser and add a custom UI for Urbit
transactions. New users will acquire their urbits entirely on the blockchain.

The most basic Urbit transaction is starting a ship you own. To start your ship,
you use Urbit to generate an Urbit keypair, and use Ethereum to register the
Urbit public key (a 512-bit pair of Curve25519 for encryption and Ed25519 for
signature) on the Ethereum blockchain.

For users who want to hold generic stars without starting or even selecting
specific ships, we'll create a divisible "spark" (USP) ERC20 token. A spark is
the right to create one star. Sparks are a convenience tool: they leverage the
mature ERC20 infrastructure for holding and trading token utility rights.

Instead of launching stars directly, galaxies can cede their unlaunched stars to
the Urbit constitution. The issuing galaxy receives one spark in exchange for
this star. Any Ethereum address can redeem one spark in exchange for the right
to start one star from the constitution's pool.

Once all the galaxies are created, Urbit is fully decentralized. We retain no
ownership powers over the Urbit constitution.

The Urbit galaxies will mirror the state of the constitution, distribute its
state and events within Urbit, and post any transactions created within Urbit.
Generally an Urbit ship trusts its parent -- if not, it should find a new one
fast. But a deeply paranoid ship can still listen to Ethereum directly.

## Contract designs

The Urbit constitution is four contracts: certificate storage, spark storage,
election storage, and logic controller.

Following Ethereum best practice, we'll use separate storage and logic
contracts. The logic contract is stateless, and can upgrade itself without
replacing the storage contracts.

We'll walk through how we have designed these contracts in detail here. You can
also view our in-progress source at the
[`urbit/azimuth` GitHub repo](https://github.com/urbit/azimuth).

### Certificate storage contract

For every galaxy, star or planet, the certificate contract holds a current
state: `%latent`, `%locked`, `%liquid` or `%living`.

The default/empty state is `%latent` (nothing has happened to this ship). The
contract stores no data for a latent ship.

A `%locked` ship has an owner and an activation date. It cannot be activated
until the given date. Until activated, the locked ship can't be transferred,
vote, liquidate or launch children.

A `%liquid` ship is held by the Urbit constitution to be redeemed for a spark.
It has no other state.

A `%living` ship is active. Its state: an Ethereum address which owns it; an
Urbit public key; a revision number, which increments on any lifecycle
operation; and (for planets and stars) both current and requested (for escaping)
parent ships.

The certificate contract throws an event on every state change.

### Spark storage contract

The spark contract is a divisible ERC20 token (you can't hold half a star, but
you can hold half a spark). Only the logic contract can create and destroy
tokens.

### Governance storage contract

The governance contract records galaxies' votes on governance proposals.

There are two kinds of proposals: concrete and abstract. A concrete proposal is
the address of a new logic contract for the constitution. An abstract proposal
is the hash of a document.

Voting is one-bit -- the default vote is "no" -- and irreversible. A 256-bit
bitfield records the set of galaxies that have voted for each proposal.

Only active galaxies may vote. A counter records the number of active galaxies.
A proposal passes if more than 50% of active galaxies support it. If the
proposal is concrete, the old logic contract is terminated and the new one
receives storage control. Abstract proposals have no further effects on the
blockchain.

### Logic contract

The logic contract is stateless and supports the following ops:

#### Create a galaxy

What: move a galaxy from `%latent` to `%locked` state.

Who: the founders only.

Comments: this is the only founder-privileged operation.

#### Liquidate a star

What: move a specific star from `%latent` to `%liquid` state, granting one spark
to the galaxy owner.

Who: owner of the active galaxy which is the star's prefix.

#### Claim a star

What: move a specific star from `%liquid` to `%locked` state, with the
activation date set to the present, and the owner as claimer; remove one spark
from the owner.

Who: any Ethereum address which owns a spark.

#### Launch a star or planet

What: move a specific star or planet from `%latent` to `%locked` state, with the
activation date set to the present, and set the Ethereum address which owns the
ship.

Who: owner of the parent of the launched ship.

#### Start a ship

What: move a specific ship from `%locked` to `%living` state, setting its Urbit
public key.

Who: owner of the locked ship.

#### Transfer a ship

What: change the owner of a `%living` ship, also resetting the Urbit public key.

Who: current owner of the ship.

#### Rekey a ship

What: in a living ship, change the Urbit public key, without changing the
Ethereum address that owns the ship.

Who: owner of the ship.

#### Request adoption

What: in a living ship, set the requested-parent field.

Who: owner of the ship.

#### Accept adoption

What: in a living ship, set the current parent to the requested parent, and
clear the requested parent.

Who: owner of the requested parent.

#### Create a proposal

What: create a proposal, which is either the hash of a document (abstract) or
the address of a new logic contract (concrete).

Who: owner of any living galaxy.

#### Endorse a proposal

What: register support for a proposal. If the proposal is concrete and this
vote takes it over 50%, upgrade the contract.

Who: any galaxy who has not yet voted on this proposal.

### Planet sales and spark auctions

We'll also write contracts that help galaxies and stars distribute their stars
and planets.

#### An auction contract for spark sales

The ERC20 spark token creates a liquid market in stars, or rather star
precursors. But a galaxy liquidating sparks may not want to just sell a large
block into this market, which may have weak depth, especially when the token is
initially launched.

So we'll validate and deploy the Nick Johnson design for an
[off-chain second-price auction](https://www.reddit.com/r/ethereum/comments/6igsdq/a_proofofconcept_of_a_better_crowdsale_contract/)

To run an auction, the seller liquidates a block of stars, then transfers the
spark tokens to a seller-owned copy of the auction contract. The Urbit
constitution is not involved with the auction.

#### A distribution contract for planet sales

There is no generic token for planets. To start a planet, you need a star to
launch it with your Ethereum address as the owner.

To distribute planets on the blockchain, a star instantiates a private copy of
the planet sale contract. Since the star is the contract's owner, the contract
can send launch operations to the Urbit constitution.

The star owner configures the planet sale contract with two parameters: the
price in ether of a planet, and the number of planets available.

## Okay, so

That was quite a lot of information! There's also a blog post about the constitution
[here](https://urbit.org/blog/interim-constitution/), and GitHub issues on the
[urbit/azimuth repo](https://github.com/urbit/azimuth) are more
than welcome.

There's a lot more to come on this front as our contracts get closer to getting
live, and we begin migrating toward an on-chain Urbit PKI.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.8.11 Update]]></title>
            <link>https://urbit.org/updates/2017-8-11-update</link>
            <guid>https://urbit.org/updates/2017-8-11-update</guid>
            <pubDate>Thu, 10 Aug 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Usually after a crowdsale we rethink our direction a little. Sorry for the
radio silence — it's hard to talk while you're thinking.

We've decided to refocus our efforts a little in the short term, optimizing
against long-term infrastructure work in favor of making Urbit work better
right now. Bear in mind that this is a short-term decision and Urbit is still
a long-term project! We just find ourselves in, um, a very fast-moving
industry.

There are two sides to this effort: design/usability and stability.

## Design and usability

### Making static publishing static

`:tree`, the Urbit publishing framework, can be painfully slow. In part, this
is because we do too much work client-side to put pages together. It would make
a lot more sense for a page to be a single fixed function of a URL -- the
original "functional publishing" design.

So, we've gone and made that actually work. Server-side includes will now be
possible, since we're adding a Markdown subset to Hoon itself. We're also going
to improve Vere's internal HTTP server to include our own caching with proper
dependency invalidation.

### Bootstrapping a style guide

![](https://storage.googleapis.com/media.urbit.org/site/type-2-up.png)

Currently, all of Urbit's CSS and styling is based on Bootstrap. It's not a
very good fit. We do a lot of work to override the default styles.

While we were improving some of our example apps a little while back it became
obvious that we need our own base CSS and style guide. So, we went ahead and
started down that path. After years of working with other CSS frameworks, it's
a relief to be producing one that's purpose-built for Urbit itself.

Urbit is a tool, so its branding needs to be completely calm and quiet. It
can't get in the way. In a way, a CSS framework is the brand itself. Urbit
isn't a logo or a tagline — it's a look and feel. This way, it's a look and
feel that you can also send pull requests to.

There's a working prototype of this style guide today, and we'll publish a repo
sometime in the next week or two. Hopefully some substantive design discussions
can be had in connection with the code itself.

### Write, talk, socialize

![](https://storage.googleapis.com/media.urbit.org/site/app-2-up.png)

We already use Urbit to chat and write, but the edges are pretty rough. Better,
faster publishing and a look and feel refresh will allow us to update and clean
up our existing tools for chatting and writing. Hopefully to the point that
they clear the 'Facebook 2004' bar. But, of course, in a pretty different way.

## Examples

![](https://storage.googleapis.com/media.urbit.org/site/examples-screen.png)

Also, our examples repo is now hosted on Urbit itself. You can just `|sync` a
desk and open a URL on your own Urbit to view the examples.

Try it yourself! The instructions are in
[this fora post](https://urbit.org/fora/posts/~2017.8.3..20.53.26..c361~/).
If you've got ideas for examples to contribute, that'd be great.
The source is on [GitHub](https://github.com/urbit/examples).
`~poldec-tonteg` just contributed his Tumblr connector, which he is also using
to syndicate his Tumblr through Urbit.
[Check it out](http://poldec-tonteg.urbit.org/portal.html).

## Remaint

The last test network managed to stay up for about a year. That's pretty good!
During that time we discovered a few bugs that would cause urbits to end up in
one-way-connectivity. A short explanation is that remote crashes would often
not get properly passed back to the requesting ship.

So we fixed that. We could probably hack this change in via an OTA update, but
it's much easier to breach this change in, and it'll be great to have it out on
the network. So, we'll be doing a breach once the code has been properly
tested.

## Urbit + ETH

Finally, we've been working on a design for how Urbit can bootstrap itself off
of the Ethereum blockchain. We have a loose specification of how this could
happen, and will present those at the meetup
[tonight](https://www.meetup.com/urbit-sf/events/242295411/). Come, critique
and ask questions. We'll publish what we come up with in the coming weeks.

## Keep in touch

As usual, discussion is on fora:
[fora/posts/~2017.8.11..21.45.52..4296~](https://urbit.org/fora/posts/~2017.8.11..21.45.52..4296~).

Also, we managed to get the `@urbit` Twitter handle:
[https://twitter.com/urbit/status/895698846918909952](https://twitter.com/urbit/status/895698846918909952).
Finally!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.5.11 Roadmap]]></title>
            <link>https://urbit.org/updates/2017-5-11-roadmap</link>
            <guid>https://urbit.org/updates/2017-5-11-roadmap</guid>
            <pubDate>Wed, 10 May 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Urbit today (May 2017) is a working proof-of-concept. The Urbit test network
has been up continuously since last August, hosting its own distributed chat,
distributing its own updates, serving its own website and forum, etc, etc.

Everyone has heard of the minimum viable product (MVP). Urbit in summer 2016
(the current test network) is the MVP's first cousin: the AVP (almost-viable
product).

## From AVP to MVP

Urbit is an open-source project. Its sponsor, Tlon, is a company. So we can't
exactly tell the public to _go away_. But there is nothing much the public can
use Urbit for, besides hanging around and talking about Urbit.

Going from AVP to MVP means changing that. And of course, it means issuing real
Urbit keys. And promoting Urbit to users. And preaching it at developers. And
all that normal stuff. But not until we're ready, because we ship only the most
beautiful bits.

Sometimes we forget to remind people that _no one has ever built anything even
remotely like Urbit_. It's not like, people had cars, so we built a better car.
It's like, people had cars, so we built a [rocket unicycle](https://media.urbit.org/whitepaper.pdf).

Our rocket unicycle is a lot more awesome than a Chevy. But it demands more
custom engineering. We have to invent every little widget as we need it.
Usually that involves rebuilding it two or three times (see the (see the [long-term
strategy](/essays/toward-a-frozen-operating-system/)). This process converges
from the bottom of the stack up, and accelerates as our progress advances.

Nock, which is now frozen, and which is a page of pseudocode, took from 2002 to
2008 to invent. Hoon took from 2008 to 2012, and is stable but not frozen. All
the real technical problems in 2016 Urbit are either in the top layers (Arvo,
its vanes and apps), or outside Urbit proper (Vere, the Unix event processor).

Except for one major component (the security vault `%jael`), there isn't any
single big thing wrong with 2016 Arvo or Vere. In retrospect, they can even be
seen as inspired stabs in the right direction. But hammering square pegs into
round holes isn't the Urbit way.

If we made our AVP into an MVP by straight-out _debugging_, we'd be limping
across the finish line. An MVP must be minimal in affordances. In its
aesthetics, it must be sublime. It has the rest of its life to grow features,
but beauty only fades.

## A parallel process

Architecture is entropy in reverse. Urbit has to become _more_ elegant, as it
becomes more functional. This delicate process must be carefully controlled.

To keep Urbit on the path to absolute zero, we have to work in three directions at
the same time:

- Stabilizing the Urbit infrastructure
- Developing the Urbit user experience
- Documenting the Urbit system

Pushing in all three directions at once keeps the whole project in balance. We
could drop any two of these goals and head at top speed for the other. This
would produce a nice simulation of doneness in a single dimension.

But if we just hardened our infrastructure from the bottom up, we wouldn't be
responding to the needs of the user experience. If we just built a user
experience on top of our prototype infrastructure, it wouldn't be stable enough
to be usable. If we documented the prototype, it would become much harder to
revise. And so on.

And the balance between these directions shifts with the seasons. After
spending the fall and winter writing infrastructure, and the spring testing it,
it'll be time to spend summer and fall working toward the user and the
developer.

## Since the last crowdsale

Maybe this is too vague. What we actually did since the last crowdsale:

We replaced about half the Unix interpreter (the whole `vere` directory, event
handing and storage), and about a third of Arvo: the lifecycle function, boot
sequence and kernel `%arvo`, the network `%ames`, the PKI (adding a new security
module `%jael`), the console `:drum`, and the `:talk` app. If Arvo was a car, we
replaced the powertrain.

At the Hoon level, we added formal docstrings and reorganized (or rather,
organized) the kernel and standard library. At the Nock level, we of course did
nothing. And on the client side, we redesigned the Web API, and prototyped a
completely new Urbit user experience. And all the new code is high-quality,
fully documented, and generally ready for anyone to copy and/or abuse.

This `cc-release` (continuity candidate) isn't quite done — the Arvo code is
written but not fully tested, and one module (the application sandbox `%gall`)
is still waiting for its rewrite. But the new Arvo has that "not quite perfect,
but basically right" feeling of architectural doneness which Hoon has had for a
while.

Note that we remain a super-tiny team. We've had some serious outside
contributions, but clean loose ends that outsiders can pull on remain
frustratingly scarce. Hoon is too stable and Arvo is too unstable.
Architectural work scales poorly in personnel, and you can't really renovate a
house while people are trying to live in it.

## Moving forward

After `cc-release` this summer, we'll move from bottom-up, infrastructure-driven
engineering, to top-down, user-driven engineering. Naturally this is
`dd-release` (deck-directed).

Our planning target is a stable, useful Urbit we can ship in 2017. Since we're
working top-down, we can abandon the deep architectural essays and work, like
normal human beings, from an illegible list of features scribbled on a
poorly-erased whiteboard.

## A whiteboard list

Our feature list for `dd-release`, in no particular order:

- The top-level `:deck` UI, an interaction multiplexer like GNU screen, but for
  terminals or web consoles. (The front end of `:deck` is a working prototype
  now.)

- The "helpful console," which offers contextual help and lets you construct any
  dojo command with a wizard-style UI. The three-way combination of a command
  parser, contextual completion and help, and webform input, may be our most
  interesting little challenge. We think we know to do it.

- Useful, well-designed web API integrations which contributors can easily clone
  to extend Urbit's reach. Stars can proxy APIs for their planets, metering
  free service.

- Integrations for email and SMS are live, so that any ship can at least message
  its owner. A storage integration to S3, etc, lets us save external blobs. A
  DNS integration lets us forward ship.urbit.org to ships with public IPs.

- Real keys are ready to be born. An instantiation protocol for the real Urbit
  keys exists and has received some public review. The current options:
  physical delivery of tamper-resistant artifacts, or registering ownership on
  Ethereum or another blockchain. (We'll release a separate essay on this
  question soon.)

- All key updates at the planet level or above are propagated hierarchically
  across the network. An offline key can block all transfers. Planet owners
  can invite their friends to a self-hosted conversation with webmoons (guest
  accounts).

- The `%eyre` HTTP server is cleaned up and its API simplified. Web
  programmers see a clear, CQRS-based query and subscription interface in JSON.
  A cookie makes your browser into a virtual moon, with a unique causal identity
  for each page instance.

- No user operation can damage the ship, which can be reset to factory condition
  with just the private key.

- Personal urbits on a home computer don't lose data, except in case of
  system/OS failure. Mutual exclusion on interrupt handlers is perfect.
  Timeouts, crashes, and user interrupts are handled perfectly. Snapshot
  handling is asynchronous and uses two A/B images.

- Urbits are configured to rotate logs by default, so they don't grow
  infinitely. All caches have continuous expiration, and out-of-memory can't
  sink a ship. The Web server is secure and has adequate performance without
  an external cache or any auxiliary servers.

- Urbit can connect its event loop to Kafka or a similar event replication
  service. Replicated urbits on a hosted service don't lose data, except
  through acts of God or government.

- One star on a normal virtual host can comfortably manage at least 256 active
  planets. Dormant planets consume minimal local or remote resources.

- The whole Urbit stack is managed with telescoping Kelvin numbers. Upgrades
  succeed perfectly or crash the transaction. The stack is permanently
  upgradeable, even for backward-incompatible changes in Hoon.

- Hand maintenance is only needed to upgrade the Unix interpreter, vere. The
  owner gets a notification when an obsolete `vere` blocks an Urbit update.

- The new security masks are respected across all vanes. The revision-control
  system `%clay` has permission masks. Untrusted code can be installed as a
  gateway to a foreign service with same-origin network permissions.

- Backward-incompatible changes in the Hoon language or Hoon libraries are
  unlikely. But the Arvo upgrade mechanism can make arbitrary Hoon changes,
  compatible or not.

- All major Arvo subsystems are architecturally stable. Namespaces, cards, URL
  routes, the boot sequence, and the upgrade model, are well-specified. Further
  change in these specs will involve a slow-track community process. But the
  definitions are stable enough to be taught.

- Architectural overviews of all major Arvo components are attached to the
  source code. Tutorial documentation for both Hoon and Arvo is good enough to
  lead a naive programmer up through building a web API gateway (server side
  Hoon) and a web agent (client side JS).

- Urbit stores and manages all Urbit-related development metadata: todos, bugs,
  releases, PRs, discussion, etc. It routes this metadata through `:talk` and
  logs it to `%clay`.

- A precise system coding convention is in place and enforced, if only by
  measurement. All code in Urbit is graded A, B, or C. Grade A Hoon ("Prime")
  is well-structured and well-explained. Grade B ("Select") is well-structured,
  but not well-explained. Grade C ("Choice") is still great code, but its
  style or technique may not meet our latest standards.

- All code in Urbit except `++ut` (the compiler itself) is grade B. (We can
  relax standards on the compiler because it tests itself so thoroughly.) All
  code on the Arvo powertrain (`%arvo`, `%ames`, `%jael`, `%gall`, `:dojo`,
  `:helm`) is grade A.

If you know the current maintenance Urbit, you know that most of these features
are mostly in sight. None of them is exactly _quite_ complete. None of them is
anywhere near a stretch. We have significant parts of all of them.

Also, since this is the release after the release we're doing now, we're
probably missing as many checkboxes as we've caught. And triage is a thing
that happens. It's really better understood as the _kind_ of work we're going
to do.

We'd really like to get all these things done in 2017. But a lot depends on
what kinds of resources we have access to. And of course, as we document the
system, it gets easier for all the people who believe in Urbit to help us build
it.

As usual, comments are on fora. Check out
[this thread](https://urbit.org/fora/posts/~2017.5.12..20.33.04..3db0~/).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Toward a Frozen Operating System]]></title>
            <link>https://urbit.org/blog/toward-a-frozen-operating-system</link>
            <guid>https://urbit.org/blog/toward-a-frozen-operating-system</guid>
            <pubDate>Tue, 09 May 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Is it possible to freeze an entire OS, so that its codebase never changes and
never has to change? Is the proposition even meaningful? Is it practical?
And if so, why would we want a frozen OS?

Think about it intuitively. There's a reason we call an OS a "platform." It's
a piece of permanent infrastructure. Paul Graham wrote a
[great essay](http://www.paulgraham.com/hundred.html) about the
"hundred-year language," but the language is only one part of any complete
platform. And in infrastructure terms, a hundred years isn't that long.

Why not think of structures that have lasted _thousands_ of years? An aqueduct,
a pyramid, a Parthenon? Why set our sights lower? Why isn't it time to aim for
perfect and timeless code? If not now, when?

## Scope of the problem

More prosaically, a frozen OS just means your OS never changes. A frozen OS
never gets any updates. Not because it can't update itself, just because it
doesn't need to.

Is this even a meaningful concept? A frozen OS? First we'll have to decide
what "OS" even means. Certainly, if "OS" means "the code that your hardware
boots into," hardware always changes and so will the OS.

A broader, more useful definition: the "OS" is _an opaque model of a persistent
general-purpose computer_. This definition allows for arbitrary levels of
virtualization. Linux on a droplet is an OS. A browser is an OS, because it's
persistent (sorta) and opaque. But `node.js` is not an OS, because it's not
opaque: it exports Linux system calls.

Within this opaque model, we have to decide what's "system" and "user" software.
It clearly makes no sense to freeze userspace. Let's use the
[trusted codebase](https://en.wikipedia.org/wiki/Trusted_computing_base): code
is system software, if compromising it would compromise the whole system.

## Infinite maturity

It's important to remember that just because a system is designed to achieve
frozenness, doesn't mean it's useless until it's frozen. It doesn't even mean
it's immature. It just means that in the very long term, the system's maturity
goals are infinite.

Systems designed to diverge infinitely (with normal X.X.X semantic versioning),
even those designed to converge infinitely (as with
[Knuth versioning](http://www.tex.ac.uk/FAQ-TeXfuture.html)), also achieve
maturity, often great maturity, without being quite frozen.

For example, C is a very mature language. C has long since mastered backward
compatibility. We can be sure that any C program which compiles on today's
correct C compilers will compile on any future correct C compiler.

But, since C is not frozen, we can't be sure that today's C compilers will
compile any future C program. So C has not yet achieved perfect _forward_
compatibility. By definition, a frozen system is compatible both forward and
backward. So C is mature, but it could still get more mature.

The point of a frozen OS is to shoot for _infinite_ maturity. Obviously a
frozen platform is compatible forever in both directions.

Infinite maturity does exist in the real world. But only in a few simple file
formats and protocols — IP, JSON, XML. And not all this maturity is the result
of perfection. Some is just the accident of a missing update mechanism.

But IP, JSON, XML... this is how stable, how taken for granted, system software
should be. And can be. Certainly, any JSON parser today will parse any JSON
document made in the future.

The dream of absolute zero is an OS whose core components are so simple, so
boring, and so mechanically straightforward that we can imagine them becoming
finished and never changing. We need to freeze not just a format or a protocol,
but a language, a kernel, a standard library. To succeed, we need to flush out
each quirk, complexity, and creeping feature, until the system is so boring and
obvious that no one even wants to change it.

## Kelvin versioning

"Kelvin versioning" is one way to track a project designed to be frozen.

In Kelvin versioning, a version is an integer in degrees Kelvin. Absolute zero
is frozen — no further updates are possible. If your Kelvin versions don't
track your actual progress, you run out of integers. This danger is a concrete
incentive for the project to track its own progress accurately.

(Kelvin versioning isn't useful only at lifecycle scale. It can be used for any
development process with an irreversible end — as build numbers for a release,
for example.)

## The palm-tree dependency model

A whole OS can't have a single Kelvin number. It has to consist of multiple
components which depend on each other. What's the right dependency model for
the parts of a frozen OS?

One way to think about dependencies across a whole OS is the "palm-tree model."
Fundamentally, there are two kinds of components in a system: "exclusive"
components (where we have to choose one version of the code), and "inclusive"
ones (where different users can see different versions).

The exclusive components are the trunk of the palm tree: a stack of layers, each
of which has one active copy. For instance, you are only running one kernel at
a time. Different apps cannot use different versions of the kernel.

The inclusive components are the fronds, branching out in any direction they
want. Not only can two apps use different versions of the same library, in
many situations _one_ app needs to be able to use two different versions of the
same library.

## The palm trunk: telescoping Kelvins

Any subsystem that serves as any kind of platform is exclusive, since anything
that runs on top of the platform has to choose one version of the platform to
run on. Since layers are good, this creates a natural stack which can get quite
tall — and include components which are technically in userspace.

The right way for this trunk to approach absolute zero is to "telescope" its
Kelvin versions. The rules of telescoping are simple:

1. If tool B sits on platform A, either both A and B must be at absolute zero,
   or B must be warmer than A.

2. Whenever the temperature of A (the platform) declines, the temperature of B
   (the tool) must also decline.

3. B must state the version of A it was developed against. A, when loading B,
   must state its own current version, and the warmest version of itself with which
   it's backward-compatible.

Of course, if B itself is a platform on which some higher-level tool C depends,
it must follow the same constraints recursively.

The important effect of obeying rule 2: in a tall trunk, it's sufficient to
state your dependency on the platform directly below you. Suppose C sits on B,
which sits on A and exports features of A. C can state only the version of B
it's written against, because when A chills, B must also chill.

If A could chill without B chilling, we could modify C to use new features of A.
Then our new C would silently fail to work on an A-B stack which had not
received the A update.

## The palm fronds: total flexibility

The goal of the trunk is to get to the fronds. In the fronds, no one should
ever worry about dependency conflicts. And nothing is ever frozen, or has to be
frozen.

The right way to solve dependencies in userspace is: within an organization, use
a monorepo and link relative to its head. Between organizations, use pinned
version numbers that are as immutable as possible. Avoid programming
environments that create exclusion problems in userspace — for instance, that
compel a single process to choose one version of a library when a diamond
dependency exists.

There is almost never any good reason to automatically update dependencies with
fresh versions of foreign code. In the case of a security update, the
maintainer of an app which depends on a patched library needs to catch the
patch and propagate the update in a new version of the app. An app shouldn't be
security-critical to begin with, and propagating updates is a basic function of
a modern OS. Also, if the app is security-critical, it could have its own bugs,
so it needs a maintainer and an update pathway anyway.

## Urbit: status and prospects

Yes, we do believe it's possible to write a freezable OS. In fact, we wrote
one. And it works. It's not yet frozen (except at the bottom layer), but it's
getting there.

Urbit, a clean-slate functional OS, has been under development since 2002. It
took a decade (as a one-man project) just to build a prototype of a freezable OS.
The result in 2017 (now with a small company) is a telescoping Kelvin stack of
layers from VM to UI.

At the bottom (the VM Nock), this stack is slightly warmer than liquid helium
(5K). It's easy for Nock to get this cold, because it's defined in a page of
axioms that gzips to 340 bytes. We are in no hurry to declare zero, but any
change at this point would be both very unlikely and very difficult to
implement.

Urbit's typed functional language, Hoon, which compiles itself to Nock, is
closing in on liquid krypton at 143K. Hoon is defined in about 5,000 lines of
Hoon, or 10,000 if you count the deep standard library. Nock will never need to
change; Hoon is perfectly serviceable but has some well-known rough spots.

Above Hoon, the stack rapidly gets much warmer. Arvo is an event-driven
microkernel that's 1,000 lines of Hoon. Above this are another 5,000 lines of
system library, then 12,000 lines of Arvo modules: a peer-to-peer network, a
PKI and private ledger, a revision-control system, an HTTP gateway, a functional
build system, and an application sandbox. A trivial working system needs
another 5,000 lines for basic chat and shell apps.

We haven't had meaningful Kelvin numbers for the Arvo layer, but this release
will change that. About a third of Arvo has been or will be rewritten in the
last year; we'll assign Kelvins once this code (which now compiles) is tested
into existence, largely based on how close the last compiling draft was to the
first working draft. But you'll certainly be able to cook eggs on it.

(Once again, not being frozen doesn't mean not working. Until all these layers
are finished, we'll be updating them over the air. To be exact, Urbit
distributes its own updates through subscriptions in its own revision-control
system.)

The actual status of Urbit is that in 2017, we hope to make our last
discontinuous update — meaning that instead of your Urbit node updating itself
silently, you destroy and recreate it. Urbit works today, but it isn't really
alive until today's Urbit data lives forever.

Even committing to continuity is a significant step toward the frozen OS,
because we're committing to never making another change that the present
platform can't install. Fortunately, the only layer that has to stay frozen for
this is Nock.

## The style of convergent system software

We're obviously in no position to declare victory at any layer above Nock, but
aiming at absolute zero creates a system design style we think works very well —
even if we never get to zero.

Deep, onion-like layering is essential. A thin layer has no room to grow. A
good example of this principle is the difference between Urbit and Lisp
machines. Both Nock and Lisp are very simple axiomatic definitions of
computing. But practical Lisp systems expand by extending the model, whereas
Urbit layers over a frozen axiom system.

Software that expands by extension is inevitable. But we need to be able to
kick it up to userspace. System software should be concerned with the
fundamental problems of computing, which don't change. The few cases in which
they do change — like crypto algorithms — are special cases, easily
encapsulated. And even these changes can be expected to slow down in the long
term.

Perhaps the best example of the convergent style in existing, mature system
software is the relational database. The genius of the relational model is that
it's designed to never grow hair. Even SQL, with its COBOL-era syntax, is
essentially invulnerable to any significant non-cosmetic improvement.

The lesson: when we see a system that seems to want to expand indefinitely, we
can and should look for a layer division within this system, separating an inner
layer that tends to converge from an outer layer that naturally diverges.
Layering is what distinguishes true system software from the giant balls of mud
that all deep codebases want to become.

Are all balls of mud, or at least all the muddy parts of an OS, susceptible to
this transformation? We think so. But we'll see.

As usual, comments are on fora. Check out
[this thread](https://urbit.org/fora/posts/~2017.5.12..20.30.11..0050~/).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.4.17 Update]]></title>
            <link>https://urbit.org/updates/2017-4-17-update</link>
            <guid>https://urbit.org/updates/2017-4-17-update</guid>
            <pubDate>Sun, 16 Apr 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's our April update, covering the last month or so. I've taken people's own
reports and added a little background where necessary.

It might help to have a broader roadmap. We'll post that next.

### `~palfun-foslup` (Fang)

I've been focusing entirely on `:talk` work.

After documenting most parts of the existing talk implementation, I tore it apart
into a "guardian" and "agent" (daemon and user-agent), or "broker" and "reader" for
talk specifically.

Along the way, I took note of and corrected some architectural weirdness, with the
prime goal of making the whole simpler and more clear. The split talk currently
mostly works, but there's still some improvements to be made, both in existing
implementation and in new features.

_Background: in the cc-release world, the user-level application container %gall
is scheduled for a somewhat cosmetic internal partitioning. Right now there is
only one kind of "app," ie, dynamic core managed by the `%gall` vane. In future
there are "guardians" (system daemons), "agents" (user agents), "tunnels" (HTTP
security drivers, currently in %eyre), and "gateways" (foreign API interpreters)._

_This is not as big as a change as it sounds -- all these partitions use the same
mechanisms. It's just about policy limitations. Eg: only a guardian can receive
inbound messages and subscriptions. In `:talk`, the separation matches the split
between mailserver and mailreader in classic Unix email, news server and news
reader in NNTP, etc._

### `~tonlur-sarret` (Keaton)

I've started a new multi-part tutorial series on building and deploying Urbit web
apps. The goal of the series is to highlight Arvo's technical features and the
flexibility of Urbit's API/UI model through interactive code examples and full
demos that technical readers can extend.

_Background: Urbit isn't yew a platform you'd want to deploy anything real on.
But userspace isn't going to change that much, so we're trying to make it more
accessible for early explorers._

_It's true that the network has now maintained continuity for almost nine months,
while ~zod has eaten 180GB of of events and seems no worse for the wear. This
should not be mistaken for stability! Any data in your present urbit will need to
be retrieved by hand when the universe is finally rebooted. And of course, the
PKI is still non-final and invalid._

_And the changes to the core `%gall` programming model will be mostly cosmetic.
For example, `%gall` will do more to help you handle subscriptions; pending events
will be inside your core; little stuff like that._

_The main change for the programmer is just that in the present `%arvo` and
`%ames` (whose total rewrite is now being tested), message transaction handling is
shitty from end to end. But you're used to that. Distributed programming with
exactly-once transactional messages is such an awesome experience that even when
it's broken, it's kind of ok._

### `~ramtev-wisbyt` (Raymond)

Before 0.5, Urbit ran as a single monolithic process controlling everything from
terminal I/O to computing and storing events. In 0.5, Urbit is split into a more
traditional database-server architecture. Thanks to a wrapper application, casual
users don't have to notice much difference if they don't want to - except that the
bottleneck in the old event code is gone, so things are a lot faster. But the new
architecture has a lot more flexibility.

At the top level, there is a single urbit daemon process which runs in the
background, handling I/O. The daemon can govern multiple ships, each of which has
its own worker process to compute and record events. Terminal I/O is moved to a
separate client process, which speaks a noun-based protocol to the daemon. The
sole client isn't the only thing that can speak this protocol - there's also a
command-line client that can handle system admin tasks like loading piers, and
urbit commands like the current `urb.py`. You can also write your own clients if
you're adventurous, though `libnoun` doesn't quite reach the level of a stable API
yet.

_Background: the "bottleneck" is that old event code processes its full input
queue before deigning to emit any outputs. This highlights Urbit's chelonian
agility with brilliantly perverse moments of inexplicable latency. We also have
no confidence whatsoever in the data integrity of the old storage layer._

_The new Urbit looks much more like a regular production server. Everything
outside the noun library has been replaced. We're also hoping to add FUSE access
to the Urbit namespace, though the priority isn't immediate._

### `~pittyp-pittyp` (Anton)

I am in the middle of making an architecture change to the console protocol, with
the eventual goal of being able to reconnect sessions.

_Background: the console protocol was in a sense the initial test case for Urbit
as a true OS. If you've built a working command line by passing events between
separate input, history, and application subsystems, with correction/completion
that requires multiple writers to the input buffer, you've built an OS._

_On the other hand, your initial test case rarely ends up as a showcase demo. For
instance, one of the things we didn't understand at first was the importance of
the CQRS pattern (command-query separation) behind Urbit's separation of `%poke`
and `%peer`. Pokes (messages) are one-way commands, not queries. Peers
(subscriptions) have no effect on the server state._

_The relationship between pokes and peers is particulary delicate in a very
interactive application, like a console. Proper CQRS dictates that sending input
to a virtual console, and subscribing to its updates, should be totally
orthogonal. But needless to say, this is not how we originally did it._

_If you remember the last update, we are obviously asking our console for a lot of
UI power. We are also redesigning `:talk` to use it even on the Web. But we have
to fix the protocol first._

### `~ravmel-ropdyl` (Galen)

I'm putting together new materials for the public.

### `~sorreg-namtyv` (Curtis)

I've done two main things: adding formal decorations to Hoon, and making the Arvo
boot sequence coherent.

The coherent boot sequence puts a complete Urbit installation in a single sequence
of initial events. As always in the development branch, this is a true boot
sequence which proceeds directly from nock. We no longer use the `-A` flag to
load the initial filesystem from an Arvo repository, nor do we boot userspace over
the network. Treating the whole install as a single noun is very helpful in
ensuring consistency for the developer. (We're aware that distributing source
files jammed into a binary pill isn't optimal from the Internet's perspective --
the only inscrutable content actually in the event stream is the self-compiling
compiler. A fancier interpreter should probably assemble its own boot sequence
from a transparent resource directory, not a binary pill.)

For formal decorations, see the accompanying forum post. Briefly, I started from
an initial draft by `~ponnys-nacwer` and added a lot of elaborations. The goal is
to get Hoon to a high level of literate programming, which documents not only APIs
but also data structures. Integrating documentation into the type system is
especially important on a user-friendly system with long-lived typed data
structures. Hoon is now at 144 Kelvin.

The parser and AST changes required for decorations also helped me find a way to
disambiguate direct and indirect Hoon syntax, eliminating the duplicate irregular
syntax introduced in Hoon 151 -- if we want. Backward compatibility was almost
perfect, requiring only a few touchups across the whole codebase.

### Oh, and

This actually went up on `/fora` before anything else. Feel free to chime in on
[this thread](http://urbit.org/fora/posts/~2017.3.1..22.06.50..bf2a~/) with
comments and questions. We're here to answer them!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.3.1 Update]]></title>
            <link>https://urbit.org/updates/2017-3-1-update</link>
            <guid>https://urbit.org/updates/2017-3-1-update</guid>
            <pubDate>Tue, 28 Feb 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
_Curtis_ (`~sorreg-namtyv`) has reached code-complete (compiling but not tested) on
the `arvo.hoon` rewrite. The super-impatient can have a look at
[this file](https://github.com/cgyarvin/arvo/blob/revere-ivory/sys/parv.hoon).

The entire boot sequence from Nock through the Arvo kernel has now been rewritten,
and actually makes sense. The old Arvo did work, it's true, under most
conditions. It didn't work because it made sense, but mainly through pure
persistence and luck. This is not viable for the deep core of a stable platform.
It has, however, managed to stay alive on the network for the past 7 months.

This all-new Arvo kernel (at a very fluffy 1065 lines) joins the all-new `%ames`
and `%jael` vanes (kernel modules), and the `%zuse` library, in the new family of
reference-quality Hoon code. (`%ames` is almost there -- the code is good, but not
documented.)

Roughly speaking, Urbit including all application, library, and kernel code, is
about 40,000 lines of Hoon, in three grades, categorized by how clean and easy to
read they are.

C-grade Hoon is found in `%eyre` (Web server) and `%dill` (console); a bit of it
has accumulated in `:talk`; the markdown parser; some of the examples; some of
`hoon.hoon`; etc.

C-grade Hoon is write-only code. To even look at it, even if you know Hoon, is
reverse engineering. It follows no conventions, not even its own. If it has
comments, they mean nothing, except (possibly) to the author. (One bad property of
Hoon is that, like C, it does nothing to stop you from writing obfuscated code.)
Most C-grade Hoon dates to 2014 or early '15.

B-grade Hoon can be followed with some effort. It is structurally simple, but not
always conceptually simple. It makes no particular effort to explain itself,
either through documentation or otherwise. `%behn`, `%clay` (B+ for decent
comments), `%ford`, `%gall`, most of `hoon.hoon` and most userspace code is
B-grade. Most B-grade code is from late '15 or early '16.

The A-grade Hoon is everything produced since our crowdsale: `%ames`, `%zuse`,
`%jael`, and `%parv`. Hoon of this quality, you just spread on a cracker and eat.
It's completely smooth. You can almost see what it's doing even if you don't know
Hoon. The only places where A-grade Hoon is hard to understand are places where
the problem is actually tricky.

Urbit succeeds exclusively through software quality. All A-grade code should be
permanently maintainable at consistent quality. All B-grade and C-grade code will
deteriorate over time and eventually needs to be replaced.

But `cc-release` is an "infrastructure MVP" in which the critical parts are
A-grade: the boot sequence and OS, networking, and secrets. Lower-grade code
remains suitable for light-duty kernel and userspace work. The good news is that
the longer we wait to rewrite it, the better the replacement will be.

These new A-grade subsystems remain untested (except `%jael` and `%zuse`) and have
not been integrated. This will involve further tinkering with other vanes and
userspace code. However, Arvo should be the last major module rewrite before
`cc-release`, so we're on our way.

_Anton_ (`~pittyp-pittyp`) and _Galen_ (`~ravmel-ropdyl`) are working from the
opposite end. They're designing the new, easy-to-use, command-completing Urbit UI
from the top down, using ES6 and React.

This new framework isn't even connected to Urbit. Its first use is actually a demo
video. We published a few screenshots from our mockups in the last blog post, and
want to give a more complete impression of where we're headed to the public.
Making this interface real will, of course, require nontrivial console engineering
on the Urbit side. We think it's going to be great.

Like our new server-side code, the new Urbit client-side framework is designed to
be high-quality code that other human beings can read and extend.

_Raymond_ (`~maldeb-hapben`) has finished breaking the new `vere` system into
client, manager and worker processes. Curtis earlier rewrote the event loop and
the logging system, with correct use of concurrency and `fsync()` in an actual
two-phase commit.

There's still a large number of small tasks to perform, but we're essentially
turning `vere` into the C equivalent of A-grade Hoon: clean code that just
obviously works. Also, the new `vere` works like an actual, industrial-grade
server, and should be reasonably adapted to the task of hosting nontrivial numbers
of urbits.

The absolutely crucial requirement for `cc-release` is ships that don't sink. We
have not observed any problems with the new event log so far, but we still need to
stress-test it with powercycles. Yes, Urbit really is an ACID database!

_Keaton_ (`~livweb-havweb`), our intern, has written a bunch of examples and
cleaned up a bunch of doc.

_Elliot_ (`~ponnys-podfer`), an outside contributor, sent an amazing `doccords`
patch that adds documentation strings to Hoon. This sounds like a superficial
change, but it actually involved deep work in the heart of the type system. He's
also added a bunch of this doc himself.

You can check out the pull requests [here](https://github.com/urbit/arvo/pull/353)
and [here](https://github.com/urbit/arvo/pull/356). The original `fora`
discussion is [here](http://urbit.org/fora/posts/~2017.1.16..06.08.17..ae0f~/).

As usual, comments are on fora. Check out
[this thread](http://urbit.org/fora/posts/~2017.3.1..22.06.50..bf2a~/).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2017.1.30 Update]]></title>
            <link>https://urbit.org/updates/2017-1-30-update</link>
            <guid>https://urbit.org/updates/2017-1-30-update</guid>
            <pubDate>Sun, 29 Jan 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
> TLDR: a real Urbit is an Urbit that does real work. This means nontrivial
> progress in two areas: systems maturity and user experience. In 2H 2016 we
> cleaned out most of the worst holes in Arvo and vere, and totally reconceived the
> user experience. The new Urbit feels like an MVP and we can't wait to ship it.

In 2013 Urbit was intriguing. By 2015 it had become interesting. In 2016 it was
actually exciting (if not always in a good way!). In 2017, we're actually
planning to make the darn thing useful. (For certain values of the word "useful.")

Our `cc-release` stability upgrade (mainly affecting the OS layer `arvo` and the
interpreter `vere`) is roughly code-complete and being tested into existence.
Once it exists and is stable, it can actually be documented -- often, for the
first time.

And `cc-release` is our first release really designed so that neither your ship,
nor the whole network, can actually sink. The Urbit network had zero unplanned,
and one planned, breach (network flag day) in 2H 2016. The last planned breach,
the `cc-release` update, is planned for 1H 2017.

With the infrastructure converging, we can finally think seriously about the user
experience of Urbit. What we're imagining is a small-scale social network and
command-line API aggregator. It's just screenshots right now, but we're confident
that we can build it and make it work.

System software is boring (at least when done right). So let's start with the user
experience.

## Design

Galen Wolfe-Pauly is Tlon's CEO and Urbit's interaction designer. Galen went to
architecture school. He talks like it. We recorded him secretly and came away
with these notes:

![](https://media.urbit.org/site/sketch-1.png)

- _UX_? As a kid it was just _design_ or maybe _web design_. At some point I
  remember people talking about _user interface_ or _UI_. But I truly don't
  understand where the _X_ came from. It's like Monster Energy got involved in
  the branding.

- An _experience_ sounds like the kind of thing that's going to be littered
  with ads, or is going to manipulate me in some way. Something I passively
  consume. Not something I actively control. So I prefer _interface_ to
  _experience_, and I think you should too.

![](https://media.urbit.org/site/sketch-2.png)

- Urbit has to be just as usable as any widely used app in 2017. For a personal
  server, the usability bar can't be Unix. A Unix server is an industrial tool.
  An industrial tool can't be a consumer product. You can attach a blade to the
  end of a drill and use it as a blender, but it's not a Vitamix.

- What is an app, anyway? It's _shared computing_. Everyone's data is one data
  structure, in one program, on one server, owned by one corporation. With _one_
  UI for everyone to do _one_ thing.

- But there isn't one big corporation that writes _all_ the code. Everyone's
  lives are spread across a bunch of different apps. Every app solves the
  ownership problem separately.

- So the whole user experience of using Web apps involves tracking all these
  silly little accounts, learning each and every user experience, and glaring
  helplessly at each little piece of data trapped in a different silo.

- Even your Google account doesn't feel like one thing. Whatever your Google
  Docs are, it's not a bunch of document files on your Google Drive. All the
  resources of Google can't make their Borg backend feel like one computer which
  belongs to you.

- The phrase 'general-purpose computing' sounds scary, but it shouldn't be.
  'Computing' doesn't mean writing code. We're computing when we browse
  Facebook or talk to Alexa.

- Your personal server will be solving the same problems today's whole ecosystem
  of network apps solves, just all in one place that belongs to you.

- The closest thing to a general-purpose personal server today is probably the
  Chinese service WeChat. If you don't know much about WeChat, you should
  really watch [this NYT video](https://www.nytimes.com/video/technology/100000004574648/china-internet-wechat.html).

- From a distance WeChat is great. Everyone in China loves the one-app,
  one-identity, all-my-own-stuff user experience. It's clearly better than
  being forced to switch apps constantly.

- But WeChat is just another giant shared-computing service. It's made out of
  the usual 2010s server stack mess. The visual and interaction design looks
  pretty dated. WeChat tells us that users want one experience, but not much more than that.

![](https://media.urbit.org/site/sketch-3.png)

- To paraphrase Walter Sobchak: say what you want about the tenets of shared
  computing, but at least it's an ethos. We know how to build very good
  special-purpose user experiences. What's the conventional UI for a
  general-purpose personal server? It doesn't exist.

- For most users, your urbit runs in a data center (like a web app). You log
  into it with your browser (like a web app). Other than that, where do you
  even start? A `bash` prompt isn't what we're looking for.

- But wait, is the idea of a command line bad UI? Or is the Unix command line
  just bad UI? We know ordinary people can use command lines. They use
  chatbots. Long ago, they used MS-DOS.

- Today's computing user experiences, the PC and its mobile cousin, rejected the
  command line. This made computing easy enough, at the cost of hiding much of
  its creative power.

- The power of a general-purpose server which can command not only local
  applications, but also network services, is at a whole new level. We don't
  think any visual metaphor or 2D control panel can do it justice.

- We need to bring the full power of the machine to the user, without breaking
  their trust that the machine is on their side. We can't let the user get lost
  or break the system. It has to feel safe and simple to explore its furthest
  reaches.

![](https://media.urbit.org/site/sketch-4.png)

- As Neal Stephenson [tells us](http://cristal.inria.fr/~weis/info/commandline.html),
  the command line is the natural UI for any computer. It's especially the
  natural UI for a _network_ computer, like a personal server. A command line
  scales way better than a GUI to a large selection of actions. And a network
  computer can do almost infinitely many things.

- When we've tried to put a simplified "for dummies" GUI on top of Urbit, it's
  just awful. It's like a bad Linux desktop GUI. You feel instantly that
  you've got a choice between something limited and lame, and something
  mysterious and scary. So we threw those designs out, in search of something
  better.

- The true command line is generally thought of as something mysterious and
  scary. Somewhere that you can do things to irreparably damage your computer.
  It's powerful, but also dangerous.

- This tradeoff — between control and safety — is false. The unfriendly command
  line is actually just another artifact of 70s computing. The UI of the
  command line is designed for a programmer, not an ordinary person.

- `bash` is a bad UI because there's no easy way to control its power, or learn
  all the things it can do, or separate its power to do dangerous things from
  its power to do safe ones.

- At the other end of the spectrum is the chatbot, which is a bad UI because
  it's hard to make it much more than a toy. Like so many innovations, chatbots
  happened by accident. It's just a way to connect an input string to network
  services. But the natural-language metaphor of "chat" is confining. It
  doesn't scale well to any problem that isn't trivial.

- What does a great command line look like? It should have a strict syntax, not
  try to guess what you mean. But it can't be a constant test of your ability
  to memorize the phonebook.

![](https://media.urbit.org/site/sketch-6.png)

- Urbit already has the beginnings of a great command line. We parse your input
  with an actual grammar and catch errors as you type. You can't even press
  return on an invalid command.

- What's missing is help. A great command line needs to reach out and hug you
  in every way it can. It needs to assume you don't know anything at all about
  the system. It's there for you to solve your problems, but also to help you explore.

- There's actually one exotic Unix shell that does it right:
  [`fish`](https://en.wikipedia.org/wiki/Friendly_interactive_shell). `fish`
  jumps through some pretty amazing hoops, like parsing manpages, to give you
  context and completion.

- It's a lot easier for Urbit because we're designing the system from scratch.
  From a technical standpoint, all we have to do is add contextual help to our
  existing parser framework. An extended rule can parse a string, or tell the
  user what it wants to parse. In simple terms: we have to make the `:dojo`
  (our shell) much friendlier.

- The `:dojo` shell is built around the concept of a _generator_, a program that
  builds a noun. The idea is that how you build the noun is orthogonal to what
  you do with it. You could print it, send it as a command, etc. There are
  several kinds of generators -- simple scripts, prompting dialogs, HTTP
  scrapers, etc.

- A generator is initialized with command-line arguments and options, in the
  classic Unix style (except typed). In the classic Unix style, Urbit at
  present provides no help at all in constructing a command line. You just have
  to know.

- How should it actually work? Let's say you're trying to put Urbit in control
  of your Twitter feed. That means you're creating a Twitter gateway on Urbit,
  which you can control with a `|twitter` command.

- Before you type a character, Urbit offers you `|` (any command with side
  effects). (You could also add a `!` prefix, which is like `sudo` -- it lets
  you do something dangerous.) Once you type `|`, you can page through a list
  of commands. Once you type `|t`, that list is much shorter. Once it can tab
  complete to `|twitter`, it prompts you with that.

- And once you get to `|twitter`, you're in a "meta-generator" that's helping
  you build the correct command line. At least in a browser, you'll be stepping
  through a form with rich entry. But the command line will show you the text
  of the command you're building, so next time you can just type it.

- Building a command is just a case of data entry. In a command-line world,
  data entry is always serial. You answer questions serially, one at a time.
  The only navigation is forward and back.

- A great Urbit console also has to be accessible both from a browser and a Unix
  terminal. That means a prompt needs to tell the console if it could be a
  radio button, even though a terminal can't have a radio button. We'll improve
  the interactivity of our terminal a little, but we're not rewriting Lynx.

- So, what do you do with this fancy command line? Command everything -- from
  your urbit to the world. Installing an app is a command. Publishing a tweet
  is a command. Paying someone in bitcoin is a command.

- Your urbit can show you all the things you can do, and help you do them. If
  there's something you'd like it to do, build it!

- A great command line alone is not all that Urbit needs. But it feels like the
  right central paradigm for interacting with your Urbit. We'll get into the
  specifics in a future post.

![](https://media.urbit.org/site/sketch-5.png)

## Infrastructure: stability, maturity, performance, documentation:

We dragged Curtis, whose hide has turned completely white like a cave fish, from
his coding hole to stammer out this update:

We're actually doing pretty well on the infar. Despite there being all kinds of
unacceptably broken things about Urbit 2016, the network has actually stayed up
since August, and we haven't had an unintentional continuity breach since June.

Of course, it helps that we don't ask anyone to _use_ Urbit in earnest. And ships
still do sink. Since an urbit is an identity, sinking your planet is a horrendous
experience. You'll never bond with your second planet the way you did with your
first -- never mind any _data_ you may have lost.

Our upcoming `cc-release` is the last planned breaching release. With certain
exceptions discussed below, all major parts are now (January 2017) code complete
or better.

This includes the rewritten network stack (`%ames`), code complete but untested;
the new secret vault and promise tracker (`%jael`), mostly tested; and the new
`u3_pier` event execution framework, with worker processes and real two-phase
commit, smoke-tested. We've also completely restructured `hoon.hoon` and
`zuse.hoon`, which now are at least cosmetically acceptable.

This is not to say that the `cc-release` Urbit won't in many ways embarrass us as
engineers. It will. But your ships won't randomly sink, your secrets won't
randomly leak, and your datas won't randomly rot. Or if they do, it's an
implementation bug, not a design flaw.

There are still a few cracks we need to fill in. The main one: some top-level
adjustments to the Arvo event system. The boot sequence now executes correctly,
but the actual boot events need to be totally refactored, as does the rather
critical Unix-Arvo interface. The long-promised security mask and voltage flags
need to be added, and vanes adjusted to use them. Causal tracking of execution
crashes needs to actually work. At the user level, `:talk` needs to be split into
a user agent and a daemon, and the user-level `%kiln`, the "systemd of Urbit,"
needs a rethink to make upgrade logic state-triggered, not edge-triggered.

The console and the dojo need some work to make our user experience real. One way
to view a high-usability command line is that a command, if you don't have the
esoteric knowledge to fill it in by just typing the syntax, is essentially a
form. This form needs to work both in the browser and the terminal, which isn't
trivial. Browser and terminal both need a simple multiscreen navigation model,
which we don't have yet.

There's also a bunch of Unix-level work to do, mainly in converting the old
"single-player mode" console-bound Urbit into a real system service. Urbit works
better as a daemon which runs one or more worker processes, and talks to client
consoles over a Unix socket. A real architecture actually makes it practical for
star owners to host the planets they issue, for example.

Finally, because we never forget the wisdom of the sages, our last act before
asking people to use Urbit will be the long awaited performance crusade. The new
event system now at least releases outgoing events before the input queue is
clear! You never know what optimization will achieve before you make a serious
effort, but I don't see any reason we can't carve out a new empire of speed in the
savage, uncharted east.

We haven't touched the documentation since the first half of 2016. As always,
maturity has to come before documentation. Premature documentation is almost as
dangerous as premature optimization.

## Notable contributions

Some notable contributions of late:

- `~ponnys-podfer` wrote a MUD
- `~palfun-foslup` created a surprisingly capable talkbot
- `~master-morzod` reworked the console in both the Hoon and C layers, adding color and cleaning up a bunch of stuff.

Anyone who contributes at this point deserves extreme praise for the ability to
work in an immature, often broken system. We look forward to being ready for
normal programmers who aren't intrepid jungle explorers.

## Next crowdsale

We'll do another crowdsale in the spring. We understand that the last sale left a
lot of people unable to participate — and our first priority is making sure those
who are excited about Urbit can own some real estate. We'll announce our plans on
how this might happen soon. If you're interested, make sure you're on our mailing
list.

## Contribution prizes

We're still thinking about the right way to award Urbit real estate to outside
contributors. Especially after the crowdsale, it really has to feel 100% fair.
But it can't be in any way, whether legally or emotionally, a form of compensation.
We can't afford to kill the fun.

It doesn't feel right to do this at all when the documentation is completely
inadequate, because it's not fair to people who don't have the time to reverse
engineer. But we're thinking hard about this issue.

## Future updates

We know you love these opinionated, literary state-of-the-urbit updates. We love
writing them. But we obsess over them too long and they take too long to write.
Urbit's ultimate success depends almost entirely on the code.

Going forward we're going to switch to commit-message style updates on a monthly
basis, with longer updates arriving sporadically. Maker DAO does a great job of
these shorter updates
([here](https://blog.makerdao.com/2016/12/14/maker-update-925/) is an example).

If you're ever curious to check in or hear what's going on, don't hesitate to get
in touch. You can always chat with us on
[urbit.org/stream](https://urbit.org/stream), or by booting your own Urbit.
[Twitter](https://twitter.com/urbit) or email
([urbit@urbit.org](mailto:urbit@urbit.org)) are also perfectly fine.

There's also [our forum](https://urbit.org/fora/) that anyone can post to. We've
created [this thread](http://urbit.org/fora/posts/~2017.2.1..22.36.47..9f54~/) to
discuss this post.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2016.10.6 Update]]></title>
            <link>https://urbit.org/updates/2016-10-6-update</link>
            <guid>https://urbit.org/updates/2016-10-6-update</guid>
            <pubDate>Wed, 05 Oct 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
September's monthly update slipped into October! But don't
worry, it's a good one.

## "Hard tech"

In [this amusing talk](http://www.themacro.com/articles/2016/09/chad-rigetti-on-building-quantum-computers/),
Chad Rigetti defines "hard tech" as "solving problems you don't
even know are solvable." Rigetti is building a quantum
computer, which is definitely "hard tech." More power to him!

But software can be "hard," too. Is Urbit "hard tech"?

The correct answer at this point is: no, but it _used_ to be hard
tech. Now it's actually real, if not exactly easy. The Urbit
network hasn't crashed once this summer, though we did one
intentional breach (right before delivering the stars). I'm
still kind of amazed by this.

But we still need to get to the point where (a) the whole network
can't crash ever, (b) you can put your data in an urbit and be
pretty sure it'll live forever, (c) Urbit works well as a social
network, and therefore (d) we can distribute planets to ordinary
human beings and not have them be like, "gah, what is this?"

If we had the resources of Microsoft or Google, or even of
Mozilla, we could solve these problems with a brute-force
human-wave attack. We could just debug the system into
existence. It must be nice.

But not. In some ways it's essential to Urbit's mission that
there isn't a giant army behind it. It means that the only way
Urbit can succeed, or even survive, is to be excellent. That's
the right attitude for a stack designed for the 2020s. Not that
we can wait until the 2020s to get (a) through (d). Just that we
don't want our children and grandchildren to curse the day this
stack was born. Unix, the Internet and the Web gained the world
and lost their souls -- we don't have that option.

Given this attitude, the thing that terrified me most of all
about this summer's crowdsale is that the most important parts of
Arvo -- the network and the PKI -- simply didn't exist in any
viable sense. Yes, the present `%ames` network does net work.
There is even in theory a sort of PKI, although no one has ever
even tried to revoke a key. It might be secure -- who knows?

More concretely, the existing `%ames` vane (kernel module) contains
both the protocol and the PKI, mixed together in a single giant
state machine of the sort I've learned never to build again.
There is no perfect code anywhere in the present production Arvo,
but the only body of _dead-end_ code -- which needs replacement,
not documentation and maintenance -- is `%ames`.

Unfortunately, networking and key management is the most
important part of Urbit. In a sense it _is_ Urbit. So having it
not exist, except as a design in our heads, was not a good thing.

While documenting, evangelizing and in general growing Urbit is
vastly important, what's even more important is finishing it --
without compromising its elegance. Elegance is the only thing
Urbit has. It's not like there aren't other operating systems.

So the first thing I did after the crowdsale was to disappear
into a hole and take care of this technical debt. This was not
"hard tech" in the sense that I knew it was solvable. I didn't
know it was solvable _well_, though. And it has to be solved
_well_, because otherwise who cares.

## Check out our new, improved cc-release

I'm delighted to report that the new, rewritten `%ames` network,
and the all-new `%jael` PKI, are now at code complete. (Code
complete means "compiling but not tested," which is actually
saying a lot in a typed functional language.) They've been
checked in to a new `cc-release` branch on
[`github.com/urbit/arvo`](https://github.com/urbit/arvo).

I think these two vanes are definitely the best code in Urbit.
There's still a bit of fundamental work in Arvo (implementing the
boot sequence and event security mechanisms described in the
whitepaper), but this is not "hard tech" -- the designs are
clear and surprises seem unlikely.

## `%xmas`: the new network

New `%ames` (currently `arvo/xmas.hoon`, since old `%ames` is still in
the build) has had all the key management stripped out; it's just
a network vane. It's also no longer a single giant state
machine, but a system of five simple 200-line state machines.

It was wonderful to discover that Hoon lets you write purely
functional programs with what are essentially global variables.
Specifically, nested cores generalize across global variables,
local variables, and objects, in a way I find technically quite
lovely if I do say so myself. On the other hand, Hoon ain't
magic, and it's not like we've solved any of the
software-engineering problems inherent in a 2000-line state
machine based on global variables. So, nice to kill that.

Don't look at new `%ames` just yet. It was done in July and
August. It needs a few touchups to fit the `%jael` interface.
And it needs to be brought up to `%jael`'s quality standards.

## `%jael`: reference code, PKI, and personal ledger

`%jael` (`/arvo/jael.hoon`), the PKI, is what I'm really excited
about. It's what you should take a look at if you know any Hoon
or even if you don't. There's several really important things
about `%jael`.

The first is that it's actually reference-quality code. Or so I
believe. It's literally intended to serve as a reference style
for what all production-quality Hoon should look like. If you're
reading the code and you see anything that isn't absolutely
perfect, whether it's cosmetic or structural or anything in
between, file a PR. `%jael` is fully commented -- if you think
it needs more comments, or fewer, file a PR...

Needless to say, a reference style will be an enormous help in
managing community contributions. It's not that, for now at
least, we won't accept patches not written in line with the
reference `%jael` style. But we'll always accept patches to bring
'those patches' up to reference. For the moment, the code will just
define the style by analogy, but it'll eventually spawn an actual
document.

If you're feeling ambitious and want to change the reference
style itself, your change is best submitted as a patch to `%jael`
itself. And _really_ ambitious people can create their own
alternative Hoon styles -- hopefully defined at the same same
level of precision.

Second, `%jael` actually implements the Urbit PKI as designed,
right down to unusual but politically critical features like
escaping a bad parent. Since the code is readable and heavily
commented, it can and will serve as the best possible reference
for the PKI's semantics.

Both `%ames` and `%jael` are designed for the new and correct
single-homed urbit model, where one pier is one ship. In the new
world, to boot your planet, you use your ticket to generate a
symmetric key that authenticates you to your parent. When you
share your public key with your parent, over that initial secure
channel, it notices that it hasn't signed it yet and shares its
signature back to you.

Third, `%jael` isn't just a PKI -- it's a generalized system for
formal promises. The whole point of a PKI is that entities can
make secure statements to each other. Of course, every `:talk`
message is a signed statement, but the really important messages
are _promises_ -- such as, for instance, "Tlon owes you 3 stars."

(Right now, the stars we sold in the crowdsale are recorded in the
state of a higher-level application (`:womb`). (We have an
encrypted offline backup, of course.) This is fine at a certain
level, but it's a bit rickety and not really up to Urbit's
standards of architectural elegance. Promises and secrets are
fundamental state and need to be handled at a fundamental level.)

In a secure distributed social network, people need to be able to
make formal promises to each other. Essentially, every ship is
an _accounting entity_. It records its liabilities, which are
the promises it's made to others, and its assets, which are the
promises others have made to it. When I update the promises I've
made to you, I send you an updated statement.

All kinds of promises fit this mold. For instance, while you
don't usually think of a symmetric key as a promise from one
entity to another, it is. It's a promise from ship A to ship B,
that B can identify itself to A by this secret.

So `%jael` will, among other glorious things, essentially allow
every galaxy to serve as an exchange for star invitations, and
any star to serve as an exchange for planet invitations. Mere
payments are just the start of what you can do with this. And of
course, one of our big near-term goals is to make first Urbit
invitations, then (once the crypto is truly final) actual ships,
tradeable on "regular" cryptocurrency exchanges.

One of my views about Bitcoin is that its decentralized,
trust-free ledger isn't really the most important thing about it.
Humans build trust quite easily. For instance, Bitcoin doesn't
even enable trust-free payments -- a payment is always an
exchange for other good or service. Do I provide the good or
service before, or after, the Bitcoin payment? Either way,
trust is unavoidable.

The important thing about Bitcoin is just that it enables users
to manage their obligations to each other digitally, without
interacting with a 20th-century asset management system made of
paper and magnetic tape. Giving every user their own asset
management ledger is another small revolution in that direction.
And if I'm defining and issuing my own digital assets, why do I
need to put them on a global blockchain? You're still trusting
me to actually live up to my promises.

Last but not least, `%jael` solves one of Urbit's most important
and hardest problems: how do I back up my urbit? I know I said
this was impossible, but I lied.

Urbit uses persistent sessions, which means a pair of ships uses
the same session sequence numbers for life. Since every packet
is a transaction, when you send an acknowledgment, you mean it.
The upside is that we get exactly-once messaging, which if you've
ever done distributed programming is a very, very good thing.
The downside is that if you lose your state, there's no way to
recover it, since you don't know what sequence number to send
next. (See under: [Two Generals'
Problem](https://en.wikipedia.org/wiki/Two_Generals%27_Problem)).

In the new world, the Unix layer will subscribe to a stream of
`%jael` changes which contain all certificate and rights actions.
We'll save this separately from the rest of the pier state, and
it's small and trivial to back up.

When restoring, if you have all your private keys but have lost
all other state (obviously if you don't have the latest private
key, you're hosed), you sign a new version of your will which
contains a "brain damage" bit. When this will is propagated to
your neighbors, they learn that you're brain-damaged and reset
their sequence numbers -- and forget you know anything they told
you, treating you as a new stranger.

At the application level, all your subscriptions get closed.
Apps already have to deal with this. Forward messages shouldn't
involve any state coupling; that's what subscriptions are for.
In case there is some coupling anyway, you'll get an event that
"ship X lost his mind, forget anything you know about him."

Essentially, we're cheating the fact that you can't have
transient sessions and [exactly-once delivery](http://bravenewgeek.com/you-cannot-have-exactly-once-delivery/)
by letting the abstraction leak in this special case, and putting
the responsibility for fixing it on the brain-damaged ship. It
may even leak up to the user. But dude, you're the one that let
your brain fall out of your skull.

Another thing I like about this solution (and about `%jael` in
general) is that it solves the problem of how you use someone
else's secrets, if you manage to steal them. There's no point in
security through technical difficulty -- if you have the latest
private key for a ship, you're the captain now. You shouldn't
have to hack something up to make this work.

## Keep in touch / office hours

`:talk` is always a great place to come and ask questions.
Someone from Tlon will be available in `:talk` from 12PM - 3PM
PDT each weekday. And [our forum](https://fora.urbit.org) is a
great place to post questions. We've created [this
thread](https://urbit.org/fora/posts/~2016.10.7..17.28.21..b058~/) to
discuss this post.

For anything else you can always get in touch with us via
[`urbit@urbit.org`](mailto:urbit@urbit.org).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2016.8.30 Update]]></title>
            <link>https://urbit.org/updates/2016-8-30-update</link>
            <guid>https://urbit.org/updates/2016-8-30-update</guid>
            <pubDate>Mon, 29 Aug 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Here's August's monthly letter from Tlon, only slightly late.
We've been doing a lot of planning and, unfortunately, a little
bit of research.

We hope we're done with this research stuff. There is really nothing
more unpleasant than CS research. But the protocol and crypto state
(`%ames` and `%jael`) needed another round of basic architecture.

## Infrastructure milestones

By "infrastructure" we roughly mean everything in `/===/arvo,`
ie, the kernel and vanes.

Infrastructure development in the presently foreseeable future is
a system of four milestones, the first of which we've hit. We
have a reasonably good start on the second:

- _FI - First inception_: The first milestone (August 15) was "first inception"
  (FI), where we claimed our true and final urbits.

- _CC - Continuity candidate_: The next milestone is a "continuity candidate"
  (CC), a release where it's at least possible that we'll need no further
  continuity breaches and/or reinstalls. CC requires a nontrivial amount of
  further engineering work.

- _FC - Final continuity_: Sometime after that comes "final continuity" (FC),
  where we explicitly renounce continuity breaches. CC to FC is a testing
  milestone and is satisfied by collective judgment.

- _SF - Security freeze_: The last milestone is "security freeze" (SF), where we
  declare the PKI final and issue live keys.

## FI: first inception

The outcome of the FI milestone was a working network, with
multiple federated stars and final `@p` names. (Modulo some
justified complaints about the `lut` suffix.) Federation
probably means we can invite a lot more people to Urbit and it'll
keep working, but let's still be a little cautious.

The FI keys are not final, but the cryptosystem is (though there
may be still be bugs in our implementation).

The Urbit network works and is an adequate, if still quite buggy,
social network, with two modes of social communication: chat and
long-form text with comments.

People can learn to program in Hoon and even write `%gall` apps,
but the documentation is lacking and involves wide gaps, which
must be filled by reverse engineering or public assistance.
Fortunately the Tlon people are reputed to be quite helpful.

At least one breach is certain. All data in your FI urbits will
be destroyed! In the breach to the CC release, we will port the
address allocation registry (the urbit.org womb) manually to the
new network.

If you have been spawning planets from your stars, you'll need to
follow our procedures, which we'll post before the next breach.
Emergency breaches may also happen. We recommend against
spawning at the moment, but of course your star is yours.

Data in FI urbits should also be considered completely insecure.
(In fact, the urbit process probably should be run in a VM if
there is any other important data on the machine, since we have
not done any real security analysis and network data is used.)

## CC/FC: continuity

The CC release at least attempts to maintain continuity. What is
continuity?

Continuity is when we stop rebooting the universe. You can leave
a continuous urbit turned off on a USB key in your attic for 10
years. When you activate it on in 2026, it will probably spend
several days upgrading itself, but it will work.

CC is just a candidate. FC is when we actually believe we've
achieved continuity.

Here are some features we've lumped into the CC/FC bag. This
list may expand, but hopefully won't contract.

Urbit is a reliable datastore. For instance, as a developer, you
should edit your source files in the Urbit filesystem `%clay`,
then back them up with `git` via a one-way mirror. (Most people
now edit outside Urbit and copy trees in.) Of course, `%gall`
application state you create in a FC urbit can and should also
last forever, via state adapters.

Urbit has a reliable storage system that can use a cluster log
like Kafka, does not lose data even on Linux, encrypts the image
as well as the log, and allows log pruning.

Urbit handles all crashes correctly on all platforms. A stack
overflow or interrupt always produces a usable trace.

Urbit boots with the proper, beautiful, functional, boot sequence
defined in the whitepaper. It's single-homed -- designed to
operate one ship per kernel -- and uses the event security model
from the whitepaper.

Urbit has a working end-to-end "permanent networking" message
system with in-order, exactly-once delivery and end-to-end acks,
and perfect causal consistency over the wire with no head-of-line
blocking between different ducts.

Urbit no longer mixes cryptosystem code with networking code.
Secret storage moves into a separate `%jael` vane. `%jael` will
hold public, private and symmetric Urbit keys, foreign API keys,
tokens, passwords, etc; and other capabilities, like Urbit
invitations.

Urbit has a communication recovery procedure so that a
brain-damaged ship can resume communication after it loses
information, even if all it knows is its own identity and key.
Only-once delivery is violated, but the onus for recovery is
placed on the damaged ship rather than its healthy neighbor.

If a ship has a static IP, Urbit can serve a secure website
without proxying, either at its own urbit.org subdomain or at a
private domain.

Urbit has have a FUSE-oriented filesystem interface to the
local OS, rather than using libuv filesystem monitoring.

Urbit has a mark system that supports mark containers, and
handles mark evolution properly in both the network and the
filesystem.

Urbit handles library versioning properly in `%ford`, never using
`=>` to load libraries, using aliases correctly to allow multiple
conflicting versions in a dependency graph.

Urbit has a stable, extensible but backward-compatible I/O
protocol between Arvo and vere (the Unix process). Any future
Arvo will work on an old vere.

Urbit uses Murmur32 rather than FNV as a short hash (mug).

Urbit is still not a cryptographically secure system, and doesn't
allow true cryptographic ownership transfers. The cryptographic
transfer features exist, but using them is a bad idea until the
keys are final.

(For right now, everyone who issues urbits to others needs to at
least track ownership centrally, ideally with a mirror database
outside Urbit. We could not stress this more stressfully!)

Urbit has received a thorough performance and scaling audit, and
there are no trivial efficiency problems to solve.

The Urbit console can output colored text and control a 2D ASCII
text array (curses style). The web console (not web dojo) works
with some keylag.

All Urbit vanes are thoroughly documented/specified with an
overview document and inline comments.

## SF: security freeze

The SF release will render Urbit a "live" cryptographic system.
It is unnecessary to point out that all subsystems in the
security chain must be audited, and operational procedures for
stars and galaxies need to be standardized.

(Yes, the SF release needs to invalidate the current
cryptographic structure, even if it hasn't been compromised.
Since it's not secure, we don't know it hasn't been compromised.)

However, the SF release keys will be instantiated via network
update, which is essentially "god mode." New keys will be
distributed to old key holders, and any disparities between
cryptographic and centralized ownership records will be resolved
in favor of the latter. Before SF, no one can gain anything by
stealing a key or transferring it without authorization.

A software update can of course do anything to the PKI. After
SF, at least, global Arvo updates (which ideally can become rarer
and rarer) will need to be approved through a constitutional,
republican governance process.

After the SF release, we have no control over cryptographic
transfers, but the Arvo code itself may penalize long wills to
minimize velocity and keep Urbit from acting as a currency.
(This is essentially a Tobin tax.)

The SF release needs to run the actual Arvo interpreter, with
jets, in a completely sandboxed subprocess with no I/O privilege.
Sandboxing jets, or even a safe jet language, should also be
investigated. Network jet update must also be possible.

An SF urbit can issue and manage children without any problem.
It can be hosted easily in a commercial data centre. The
interpreter can migrate images securely, automatically and
efficiently to a different hosting service.

An SF urbit will have a framework for DoS defence, blocking and
banning, and other nuisances of the modern world. There will be
at least the beginning of a global reputation system.

## CC: work overview

The one subsystem that needs a complete rewrite is `%ames` (the
network). The `%jael` vane is completely new. Fortunately, the
new `%ames` vane compiles, and the `%jael` interface is defined
(and not that `%jael` can be complicated).

The mug replacement work is also done, but needs to be debugged
(which is no easy task).

Applying the canonical boot event system sounds like a giant
change, but it's actually pretty straightforward -- same for
single-homing. Arvo proper is only a few hundred lines of Hoon.

The event system in `vere` needs to be replaced, but we have a
module built by a contractor with both the local FS and Kafka.

All the vanes besides `%ames` need documentation and a general
tuneup, but this should not rise to the level of a rewrite for
any other vane.

## Community involvement

Urbit's most serious problem right now is that many more people
are interested in it than are actually working on it. This
reflects its heritage as a basement project.

Our most important work item remains opening up the codebase so
that community development can happen. We'll start turning the
CC tasks into community operations as fast as possible.

But this is a separate topic. It fits under a discussion of
Tlon's corporate plans and operations, which we'll post later.

## Contributors

The contributors have been amazing. We need to make more use of
their talents, which are growing daily. And we need to do a
better job of chronicling their deeds! But for now, github
remembers.

## Keep in touch / office hours

`:talk` is always a great place to come and ask questions. Going
forward someone from Tlon will be available in `:talk` from 12PM - 3PM
PDT each weekday.

Post to our [new forum](https://urbit.org/fora)! Especially [this
thread](https://urbit.org/fora/posts/~2016.8.30..18.05.18..8ba3~/) to
discuss this very post. Don't be afraid, the water's fine! Actually there
are a few glitches, but it's hosted on Urbit (and also backed up).
For the less daring, [r/urbit](https://www.reddit.com/r/urbit) is a
reliable old standby.

For anything else you can always get in touch with us via
[`urbit@urbit.org`](mailto:urbit@urbit.org).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2016.7.20 Update]]></title>
            <link>https://urbit.org/updates/2016-7-20-update</link>
            <guid>https://urbit.org/updates/2016-7-20-update</guid>
            <pubDate>Tue, 19 Jul 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
First, a huge thank you to everyone who helped make our crowdsale a
success. It's an amazing feeling to realize that the Internet is
fully capable of funding and programming its own replacement. The
world both knows enough about it, and cares enough about it.

It will still be a lot of work to make Urbit a polished product for
ordinary humans, and organizing this work remains a tremendous
responsibility. But now we're confident that it can be done.

Now that the public has a serious stake in Urbit, we can't really keep
up our old habit of working in the dark and occasionally releasing
mysterious beautiful things. We'll keep up with these monthly
updates, on or about the 20th of each month.

As always, you can see the beating pulse of Urbit development at
[urbit.org/stream](https://urbit.org/stream).

## General status

The work required to pull off the sale definitely drained the energy
of our two strongest engineers, Philip (`~wictuc-folrex`) and Anton
(`~fyr`).

Rather than remain on the path to total burnout we decided to push
back the issuing of stars. Our goal is to activate invites on August
12th, 2016. Apologies for the delay, and the short notice.

## Great renaming, rekeying, and new ames

If you bought a star, you might notice that while our invitation
server (the womb) is up, it's not currently configured to let you
create a star.

Our first major release, which comes with a continuity breach
(complete network reboot where all ships are recreated), needs to (a)
fix the ship naming algorithm "`@p`", giving everyone (including us)
new names; and (b) replace the somewhat risible cryptosuite A (RSA and
other horrors) with the competent cryptosuite B (Curve25519, Ed25519,
AES).

Not only will this let star buyers collect their stars (they don't
need to, but it might be fun), but all planet owners will now claim
their new planets via the womb. If you have an old ticket, the womb
will convert it into a new invitation.

We had planned to run the great renaming today, but about a week or so
ago we found ourselves reconsidering. This isn't because the new
crypto and `@p` code isn't ready -- it is (largely because it's the work
of Ray, `~raplys-lornex`). But...

1: Anton needed a break and the womb is his code. For a piece of
critical infrastructure, it's also a little under-documented and
under-tested. Hoon as a typed language makes you lucky. Urbit is
still a testnet, but we're a little tired of relying on luck.

2: Slipping the great renaming lets me (Curtis, `~tasfyn-partyv`)
resuscitate and integrate my rewrite of the `%ames` network module,
which was mostly completed and then put aside six months ago (so that
I could do things that didn't involve writing code). New `%ames` is
sorely needed, because right now there's a network bug that actually
sinks (permanently disables) ships, and we basically can't debug
anything in the area because we'd be debugging old code.

People have also expressed some concern about the fact that `%ames` is
sending mysterious UDP messages which aren't documented in any way
(the whitepaper has some protocol description, but it's still not
quite comprehensive. Actually, `%ames` is a pretty clean system overall
and shouldn't be hard to turn into the kind of literate, stable Hoon
code the future should be made of. But again, documenting obsolete
code kind of sucks.

Finally, we have an idea (half Anton's, half mine) about how to
actually end the unfortunate tradition of continuity breaches, by
providing a "rough start" model which lets you create a working ship
with just the private key. Needless to say, it would be very exciting
to actually stop rebooting the universe, permanently.

So it's a pretty good fit to push the renaming and the new network
protocol out into a single Great Inception, which currently seems like
it should happen in early August. I certainly can't wait to pick my
new, permanent Urbit name! But as always, we ship no code before its
time. We will keep you up to date on our progress.

## Other near-term goals

The short-term focus remains self-hosting and onboarding. Ray is
currently working on building a simple message board on top of `tree`,
so that Urbit can be its own phpBB as well as its own IRC. Persistent
IRC (ie, `:talk`) is extremely useful, but we need long-form
discussion. Reddit is pretty good, but not _quite_ right -- and an
ounce of self-hosting is worth a pound of SaaS.

Basically, we don't intend to work on user-level features that we
don't use ourselves for quite some time, if not ever. Self-hosting is
the path to maturity, always and everywhere.

## Medium-term goals

Our medium-term focus is expanding the attack surface of Urbit as an
open-source project in every possible way. We want to completely
dispel the aura of mystery.

There are two general paths toward this: teaching and documentation.
On the teaching front, I think you'll like the new, super-easy Urbit
learning series I started [here](https://urbit.org/docs/byte). More
Urbytes are forthcoming.

On the documentation front, Urbit has a large volume of basically
undocumented and undescribed code at the Hoon and Arvo levels. This
is incredibly shitty from the perspective of an open-source project,
especially because neither I nor anyone has the kind of obsessive
attachment to random details that you'd expect in an under-documented
system.

We need the community to own the technical decisions in Hoon and Arvo.
Urbit can't be a real open-source project until we truly open this
attack surface.

The right way to solve this, I think, is to "document into existence" --
producing design documents from the existing codebase, reviewing these
designs collectively, then converging the actual code with them. The
key areas to attack are Arvo itself and the vanes. The first area I
want to do this with is the new `%ames`.

There is an excuse for not having done this already: premature
documentation is a serious evil. When you're figuring out how a
system should work at all, documenting it is counterproductive. But
Urbit is past this point. It needs to settle down and become a
grownup.

## Contributors

Many thanks to those who have been providing the fantastic stream of
PRs we have been getting. We've had great help on all parts of the
stack, from the front-end to the C interpreter to Arvo vanes.

We'd love to help you get involved. Come join us on `:talk`!

## Keep in touch / office hours

`:talk` is always a great place to come and ask questions. Going
forward someone from Tlon will be available in `:talk` from 12PM - 3PM
PDT each weekday.

[r/urbit](https://www.reddit.com/r/urbit) is also a good place for any
kind of discussion.

For anything else you can always get in touch with us via
[`urbit@urbit.org`](mailto:urbit@urbit.org).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Toward a New %clay]]></title>
            <link>https://urbit.org/blog/toward-a-new-clay</link>
            <guid>https://urbit.org/blog/toward-a-new-clay</guid>
            <pubDate>Wed, 13 Jul 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
TLDR: (a) Urbit's revision-control system, `%clay`, is itself due
for a (medium-sized) revision! (b) this time, you yourself can
really help! (c) please don't give away the buried spoiler!

This explanation does not (or at least should not) require you to
know anything about Urbit.

### But %clay is already pretty cool

Of course, nothing in Urbit is allowed to be _lame_. `%clay` is
actually quite cool. It does need some work. But first, let's
talk about what it is and why it's cool.

`%clay` is the Arvo vane (Urbit kernel module) for revision
control. It's an authenticated, human-memorable global immutable
namespace which is also a typed revision-control system. It's
also very good at subscription and synchronization. Urbit
currently uses `%clay` to distribute live hotpatches; we
transparently upgrade the whole network with one checkin.

### Compared to other revision-control systems

`%clay` is clearly a vanilla DVCS in the modern `git` style. Of
deployed DVCS these days, `%clay` is probably closest in spirit
to `bzr` or maybe `fossil`.

Obviously, as a part of a larger whole, you would expect any
Urbit RCS to be brutally spartan. `%clay` is. It's even more
spartan than `bzr`.

(In fact, it's really too spartan to fully use at the moment. We
ourselves still use `%clay` mainly as a distribution system, and
do all internal development on GitHub. This is because the
present `%clay` lacks a few little conveniences, like commit
messages. See upgrades, below.)

There are lots of normal DVCS things in `%clay`. But there are
also cool and unusual ones. Let's take a brief tour of the
high-level system, then describe what we think should change
about it.

### Anatomy of a DVCS

A DVCS is a historical state graph. A point in this graph is a
snapshot of some tree-structured system, like a filesystem.

These snapshots, including recursive internal nodes, are stored in
a content-addressable store. Pointers in this store are used to
construct a revision graph, whose edges are edit and/or merge
actions. Some sort of namespace attaches meaningful names to
current revisions in this graph.

There are six big questions in the design of a DVCS:

- how are snapshots named?
- what is the data structure within a snapshot?
- how does it map to the Unix filesystem?
- how is the system queried?
- how is the revision graph defined?
- how does the content-addressable store work?

## Anatomy of %clay

A good way to summarize `%clay` (at present) is that its answers
to the first four questions are interesting, and its answers to
the last two are boring. We'll talk about all six, though.

### Global namespace: [ship desk case]

The permanent global name of a `%clay` snapshot is a `++beak`. A beak
is a triple: `[ship desk case]`.

The `++ship` is an Urbit ship. A ship is a network address, a
human-memorable name and a cryptographic identity. The address
width is variable; shorter addresses are more desirable. Most
users have 32-bit addresses, which we map to four-syllable
synthetic names like `~sorreg-namtyv`.

The `++desk` is a 4-letter word meaning "branch."

The `++case` is a version, one of three kinds: a version sequence
number, a named label, or a date.

In the Urbit path syntax, the beak is the first three segments of
the path: `/ship/desk/case/my/cat/picture`.

In most cases, a path parser has a default ship, desk and case,
each of which can be replaced by `=`. So `/=home=/my/cat/picture`
is the data at `/my/cat/picture` on your own ship, in the `%home`
desk, right now. Immutability doesn't have to be inconvenient.

`%clay` has no concept of a mutable name or a magic `HEAD`. Use
the current date. If you're referring to remote data and you're
worried about clock skew, subtract a second or three, or be
prepared to block. (Or keep your clock unskewed, which shouldn't
be _that_ hard.) It's not like mutable-name schemes work any
better than this anyway.

(Immutability is central to `%clay`. `git` merely adopted the
reflog. `%clay` was born in it, molded by it...)

`%clay` is objective; each Urbit node hosts only one ship, but
treats domestic and foreign data (almost) the same way. If you
ask your `%clay` repository for someone else's data, it will
block the request until it gets the data, which it then caches.
At present, we always fulfill requests from the origin ship,
though in future we could certainly use it as a tracker.

If `%clay` discards cached data, it keeps a hash, so that your
urbit can't violate the local illusion of immutability. We
can't, of course, prevent anyone else's ship from sending
conflicting claims in different directions. But we can prevent
programs on our own ship from hearing about them, meaning that we
retain local referential transparency.

### Local structure: dome, arch, leaf and mark

A `%clay` snapshot is called a `++dome`. A dome is the `%clay`
equivalent of a tree-structured filesystem.

Each node in this tree is one uniform structure, an `++arch`,
which is both file and directory. A `++leaf` or data value in
this arch is a typed document.

A logical document type is called a `++mark`. A mark is a
symbolic pointer to a Hoon source file, in the same dome, for an
engine that can validate, compare, and/or convert
documents of that mark.

Let's go over arches and marks a little more closely...

#### An arch is a uniform filesystem node

Most filesystems and RCS have modal nodes. For instance, a git
data node can be a blob or a tree. `%clay` (and the Urbit
namespace in general) has one kind of node, an `arch`:

```
  ++  arch  (pair (unit leaf) (map knot arch))
  ++  leaf  (pair mark noun)
```

An arch has an optional typed-data leaf, and optional named
children. In Unix terms, it's a file, a directory, or both. It
can't be neither: an empty arch, with no data and no children, is
auto-pruned. As in `git` (but not in Unix), the hierarchy is a
pure function of its leaves. Paths exist only because of the
data they point to.

The `++knot` names in an arch path are also a little special.
They're typed, in a sense; any knot can be parsed invertibly into
a typed atom. The atom is an arbitrary unsigned integer. Its
type (an `++aura` if you know Hoon) defines the semantics and
presentation of the atom: for instance, a symbol, a decimal,
a date, etc.

Ultimately a filesystem is a database, and a path is a primary
key. It's very useful to be able to store simple data in this
key, in a standard and unambiguous way.

Why uniform nodes? One, they map nicely to information trees
where a subtree may need some custom collective presentation,
not an automatically generated Apache style directory listing.
Two, non-uniform nodes introduce a whole pointless category of
node type conflicts -- for which life is far too short.

#### A mark is an executable document type

A mark is "like an executable MIME type." It's best defined as a
symbolic mapping from a filesystem to a schema engine.

If you have a MIME type `text/html`, you need to watch the
Internets to track what the W3C thinks HTML is. If you have an
Urbit mark `%html`, you can functionally construct (using our
insanely powerful functional build vane `%ford`) a core which
can validate or normalize HTML, apply patch and diff logic, and
translate to and from other marks. `%ford` can even reason about
translation paths and construct multistep conversions.

(Urbit does not actually have this super-smart `%html` mark right
now. But it probably should, huh. And this page was composed in
Markdown and translated to HTML by `%ford`.)

Where does the source code of a mark live? Within the same dome
as the data it describes. `%html` files are described by the
Hoon source at `/===/mar/html`, which perhaps gets mapped into
your Unix filesystem at `$ship/home/mar/html.hoon`.

This Hoon file is not self-contained. It has dependencies. The
`%html` mark may depend on various structures and libraries
elsewhere in Urbit. But the source code for all them is within
this dome.

One constraint this puts on domes is that _all domes are
descendants of the base system dome_. Domes are versions of one
reality, not fragments of that reality. You can't create a new
empty dome -- you'd have no mark source, and be unable to install
any validated files.

Enforcing the rule that all domes are congruent (if only in that
they all contain the base system files) costs us nothing in the
implementation, does not inconvenience the user, and ensures that
weird collisions between non-parallel things don't happen.

### Unix mapping and mounting

Every DVCS is its own filesystem in a sense. But every DVCS
works by mapping and mounting itself, in some sense, to Unix.

#### Mapping arches to Unix

How do we map arches into Unix? The arch structure maps 1:1 to
the Unix directory tree. When the arch has a leaf, we derive a
dot extension from the file's mark.

So, supposing we have a leaf `foo` which is an HTML document
(mark `%html`), with two children `bar` and `moo`, also HTML
documents, in Unix we'll see:

```
foo.html
foo/bar.html
foo/moo.html
```

This maps invertibly back into `%clay`, and it looks perfectly
unremarkable from the Unix side. File completion sometimes gets
a little annoying.

It would be if nice every possible Unix tree, even every
plausible Unix tree, mapped cleanly and completely to a `%clay`
dome. There are always horrid exceptions, even in common use --
like extensionless Makefiles. The trivial solution is that if
`%clay` finds a file mysterious, it won't track it.

One often unquestioned assumption in new system software is that
compatibility with old content is important. It's nice, but not
that important. Most content in a new system is new content.
The important compatibility direction is export, not import. So
the new system should subset, not superset, the ancient formats.

### Mounting desks to Unix

If a `%clay` desk is _mounted_, it has a two-way live sync to
the Unix directory of the same name within the pier.

When files in a mount directory change, `%clay` notices it
through `libuv` filesystem watching (ultimately `inotify()` or
`FSEvents`), computes diffs, and automatically commits them to
the desk. And if `%clay` creates a new version for its own
urbity reasons, it will revise the Unix files.

Keeping all mounted files in the same Unix subdirectory makes it
easy to move the whole pier in a tarfile. Edits applied while
the `urbit` process isn't running will be detected and applied
the next time it starts.

In conventional DVCS terms, `%clay` has a 1:1 static mapping from
branches to working directories. Why?

Why not? Do we need that "what branches are checked out in what
directories" piece of state? Why force the user to worry about
which branches are mounted to which directories? Why not just
mount them under their own names? Is there some crippling global
shortage of disk space for source files? Our planet is running
out of inodes? Wut?

### Queries, subscriptions and synchronization

There are two ways to get data out of `%clay`: dereference the Urbit
namespace, or send a request/subscription. Sync is in userspace.

#### Dereferencing the namespace

`%clay` is just part of the full Urbit namespace. The full namespace
has a two-character prefix which expresses what vane to query
(always `%c` for `%clay`). The suffix is a mode flag; `%x` for
data, `%y` for a list of children, `%z` for the whole arch
subtree, `%w` for the version number. (Each vane has its own
modes.)

For example, the full path to my cat picture is

```
/cx/~sorreg-namtyv/home/[now]/my/cat/picture
```

(where `now` is the current date).

If the data model is `++image` (hypothetical -- we don't really
do image processing in Urbit right now), the normal way to load
this data in a Hoon program is

```
.^(image /cx/~sorreg-namtyv/home/[now]/my/cat/picture)
```

This produces a statically typed value (which works by
dynamically checking `image` against the actual type of the
value, but this comparison caches well).

Internally, an Urbit namespace request produces a `++cage`, which
has a mark, a `++span` (language-level type), and an actual noun.
The product is doubly optional, `(unit (unit cage))`; this is `~`
if we don't know the value of this name at present but might
learn it in future, `[~ ~]` if we know we'll never know it, or
`[~ ~ value]` if we know it now.

In high-level shell programming (`:dojo`), we can make apparently
"blocking" requests to `%clay`. What actually happens: when `%clay`
produces `~`, we stop trying to compute this expression and wait
on one or more blocking requests. When we are unblocked, we
recompute again from scratch; the intermediate computation is not
saved at all.

Urbit doesn't like to block. It likes to save coherent data
structures, not incomplete computation contexts. When Urbit
pretends to block for you, this is a courtesy service. You
can return the courtesy of not expecting miracles from it.
When in doubt, send an actual request.

### Requests and subscriptions

A true request (local or remote) has access to the same
namespace, but can (a) read across case (revision) ranges,
and (b) filter by subtree.

If the revision range in a request stretches into the future, the
request becomes a subscription. Urbit messaging always regards a
single response as a special case of a subscription.

Generally, the response stream created by a request starts with
all the data the server has available right now; updates will
follow when they become available; the subscription will be
closed when the request range is complete.

#### Userspace synchronization

Synchronization per se is done in userspace. In `%clay`, sync just
means an application (typically the `%kiln` module in the system
app `:hood`) subscribes to a remote desk, and saves its change
stream locally. So sync is really an emergent feature of `%clay`.

### Revision graph

`%clay`'s revision graph is completely uninteresting at present.
Some changes are proposed below, however.

As in any DVCS, a dome is the child of one parent dome (an edit)
or more parents (a merge). Often the parent of any revision is
the previous version in the sequence, but it can be anything.

### Storage model

`%clay`'s storage model is completely uninteresting. It's also a
little funky and I want to change it, so I'll be super vague.

A `++lobe`, a 128-bit atom, is the Merkle hash of a `blob`, which
is essentially a leaf. All blobs are stored in a hash table
(`(map lobe blob)`), and reference each other through lobes.

At present we don't GC this space at all, because we don't
actually delete any roots.

A `blob` may be `%direct`, meaning it's defined as the data
itself, or `%delta`, defined as a change against another blob.
This is motivated by the desire not to store a full snapshot
on every file change. But it may be misguided (see changes #0
and #1 below).

We cache the full arch tree (`++ankh`) of the latest state in
each desk. For current queries, this mitigates a lot of the
opportunities for slowness that this data model creates. But the
disparity between the speed of the current version and the
speed previous version is an undesirable glitch in the API.

## Our motivation for change

We actually have _three_ motivations for change...

### We need to develop on %clay

At present, we're still using `git` as a development platform.
`%clay` is certainly used, but just for its strength --
deployment. This is starving Urbit of essential experience and
basically keeping it lame. So, change is necessary.

### Change must come from the community

"Why?" you ask? "Why must change come from the community?" Well,
one, duh. Change always comes from the community.

But two, a great force for change has departed. Philip Monk,
late maintainer of `%clay` (`~wictuc-folrex` in the old era,
`~wicdev-wisryt` in the new), is tired of types and typing. He
spent September roaming with the bison in Montana, and is now
literally on his way to Patagonia. On the one hand, Phil still
exists and is not at all unwilling to answer questions, even dumb
questions. On the other hand, _Patagonia_.

So %clay needs a new owner, or owners. At this point, we think
the community might be indoctrinated enough to take a stab.

Alas, `%clay` already has a pretty checkered ownership history.
Long ago I built a `%clay` that was really the only serious
design failure in Arvo. Then Jared Hance, a brilliant summer
intern, took my broken `%clay` and reformed it into a minimal `git`
in about a week. Then Philip modified Jared's `%clay` to be a
_typed_ revision-control system, which is a pretty cool thing.

But... in none of these transitions did `%clay` actually get
_rewritten_ per se. While it's a reasonably good vane, it
does contain one or two historical decisions.

We know a lot more about Arvo than we used to, and I think we can
revisit many of these decisions. The point of this post is to
start a `%clay` design discussion that will evolve into actual
collective action.

### Pioneers may find it worth their time

We're planning a rewards program for contributions to `%clay`.
It'll simply involve setting a time period and a pool of real
estate, and allocating the pool by judged contribution.

This is an experimental program. We'll say more about it later.
It may not even happen. It may happen very differently. When in
doubt, don't talk about Fight Club.

## Some openings for change

Change, of course, must come from the community. No one can
dictate change from the top down. We _know_ this. But...

This list of suggested changes for the next `%clay` is not in any
sort of order: priority, structure, difficulty, etc. Let's talk
about the changes first; make actual plans second. The numbers
here are just for convenience.

_All changes in this program will happen on the next-generation
(`cc-release`) branch._

### Change #0: state reform

As mentioned above, the storage model in `%clay`, as the code is
at present, feels a little funky to me. There's nothing terribly
awful about it, but it doesn't feel quite right and its scaling
properties are very questionable.

Briefly, `%clay` today actually derives the hierarchy from its
leaves -- rather than _logically_ so deriving it. Only leaves
are in the object store. This is just weird, and you can feel
`%clay` trying to be something other than what it is. (I blame
Jared, though it's actually my fault.)

To store a dome snapshot (`++yaki`), the present code keeps a
`(map path blob)` at the root of the dome. This is enough to
reconstruct the `++arch` structures the namespace exports.
However, all kinds of basic arch operations, like basically `ls`,
become `O(n)` in the number of leaves in the dome. This is
obviously not quite right.

I believe the storage structure should be (removing everything
that isn't needed to serve the namespace):

```
  ++  clay  (pair safe (map term desk))
  ++  desk  (pair numb (map numb root))
  ++  dome  (pair date root)
  ++  leaf  (pair mark noun)
  ++  lobe  @uvH              ::  128-bit base32
  ++  numb  @ud               ::  decimal version number
  ++  root  (pair (unit leaf) (map knot lobe))
  ++  safe  (map lobe root)
```

Here a `++root` is the universal node, with children addressed by
hash, but logically representing the abstract `++arch`.

Users of hierarchical filesystems basically expect performance
qualities that match the filesystem structure. A huge directory
in one place shouldn't affect search speeds somewhere else. And
of course, `ls` can't be O(n) in the size of the filesystem.

### Change #1: store edges, cache snapshots

The current `%clay` is snapshot-oriented, like `git`. The actual
changes are discarded. I think this is a bad choice.

`%clay` is not a research project, and has no idea of going as
far as `darcs` in the "set-of-patches" direction. However, at
present we actually throw away the patch (`++nori`).

I think the right DVCS design for `%clay` is a snapshot-oriented
system which also keeps the patches. The revision graph has the
same general shape as in the old `git` style. But rather than
just deriving the diffs from the snapshots, we can also derive
the snapshots from the diffs. When in doubt, we save space by
dropping the snapshot, not the diff.

For an RCS which is also a general-purpose typed filesystem, it's
clear that considering edges (deltas, diffs, changes, etc) as the
primary state is optimal. You can use diff functions to derive
deltas from snapshots, but in many data models this will always
risk losing information from the original action. When in
doubt, save what the user did.

This is even more true for operations on the tree structure, not
on individual leaves. Consider the heuristic energy that `git` has
to go through to figure out when `mv` has been used -- even when
`git mv` has been used! (According to the `git` faq, this is
because the lowest common denominator remains Linus' style of
working with emailed patches.)

Edges probably don't even need to be deduplicated. They also can
contain metadata such as commit messages (which `%clay` has no
place for at present).

Once edges are recognized as unreclaimed primary state, snapshots
can always be derived from the edges. So we can reclaim memory
being used for snapshots.

It's also straightforward to have a kind of edge which is a list
of edges, letting us collapse feature branches trivially.

Finally, I think references in edges should wherever possible
indirect through the namespace, rather than directly to the
content address. The user has strictly more information if you
say you merged `/~sorreg-namtyv/base/987/`, than if all you have
is the hash that this reference refers to.

### Change #2: unconfuse merge and rebase

The dispute between merge and rebase has all the bad smells of
a historical wart. But here I'm just not sure what's right.

The user has one _intent_ whether merging or rebasing, which is
to combine changes on one desk into another. The _algorithm_
used to construct this change, whether operational transformation
(rebasing) or a 3-way diff (merging) has one goal: use all
available information to model the authors' editing intent as
realistically as possible. If we save edges, we should use
edges.

Whether to define the resulting change graph with the typical
structure of a merge, or the typical structure of a rebase,
strikes me as quite arbitrary, and well into the land of "pick
one and force everyone to stick with it." But this call demands
a real expert on RCS workflow, which I'm not.

Since `%clay` is a humble part of a larger system and needs to
keep its weight down, "do it both ways because people have
different preferences" is not usually the right answer.

### Change #3: comment jihad

`%clay` needs to be brought up to the documentation standards of
`%jael`. This means (a) the formatting matches; (b) the comments
are at the same level of quality and ubiquity.

The basic commenting standards are: (a) every core (class) needs
a block comment explanation; (b) every gate (function) needs a
line comment; (c) every face (variable) needs a line comment.

This is obviously not just a clerical task. To write these
comments, you need to actually understand the code. This is a
nontrivial but extremely rewarding task, even if the code you're
commenting will get replaced.

Also, the _symbols_ in `%clay` must be brought up to `%jael`
quality. There is still far too much four-letterism here.

NB: `%clay` is about 3000 lines of pretty clean Hoon, which is
certainly not at all undocumented. We're not exactly looking at
a Matterhorn of reverse engineering here.

### Change #4: knot to coin internal paths

One feature of Urbit paths, briefly mentioned above, is that a
path segment or `++knot` (which is just a `@tas` text string, an
ASCII symbol as an atom) must be within the range of the
invertible noun printer, `++co`.

`++co` maps a described data value, a `++coin`, to an ASCII
string which is a valid URL segment and Unix filename. Its
friend `++so` inverts the function, perfectly.

Almost every knot is the simplest kind of `coin`, a `dime.` A
dime is a single atom with a rendering type (`aura` if you know
Hoon). Auras include `@tas` for symbolic text, `@ud` for
unsigned decimal, `@p` for Urbit ship, etc. `++co` can also
print arbitrary cells, though less prettily.

This feature is cool because it lets us stuff data into names in
a precise and predictable way. Usually the names in a namespace
are human-meaningful and human-originated, and are therefore
symbolic, but there are exceptions. For example, blogposts may
want to be named by date.

However, it is slightly retarded for the fundamental state of our
arches to store the _rendered_ string (`++knot`), not the source
data (`++coin`). It leads to all kinds of inefficiencies where
we're doing way more parsing than we want to. (Parsing also
should be jet-propelled, but is not.) It also makes it way too
easy to sneak in bad data and make it `%clay`'s problem.

So, logically, we'd be shifting from

```
  ++  arch  (pair (unit (pair mark noun)) (map knot arch))
```

```
  ++  arch  (pair (unit (pair mark noun)) (map coin arch))
```

Also, a vanilla `++map` might not be quite the right data
structure at this point -- we probably want a custom sorted tree,
which separates auras and imposes a custom order on each. This
would let us serve simple range queries quite efficiently, so
long as they match the standard aura order (eg, alphabetical
order for symbols).

### Change #5: dome semantics by reference

While the principle that a dome contains its own mark source is
elegant, it's a pain in the ass to implement properly. `%clay`
certainly does not do it justice at present.

The complexity is in checking every change to see whether it
includes a change to the mark source (which is very unlikely),
or a dependency of the mark source (slightly less unlikely).
And if so, do we have to update all the leaves in the dome?
This is also very unlikely. And yet, it happens.

Instead, we could simply designate, by beak (ship, desk, and
case) a dome which contains the canonical mark source. This
would rarely change -- you could upgrade a desk to a new mark
dome, but it would be a manual operation and probably a rare one.

The common case would just be that everyone uses the current
version of the `%base` desk when a desk is created, and never
changes it. In practice, this means not every two-byte edit
needs to get involved in detecting and/or applying schema
evolution, a welcome simplification.

### Change #6: mark containers

Marks in present `%clay` are atomic and symbolic (like `%html`).
Since they're also used for network protocols, and the proper
design is one mark per message structure, the mark namespace gets
overloaded fast.

So we added an app hierarchy within the mark namespace, using hep
`-` as a divider. The `:talk` app expects messages with the mark
`talk-message`, whose sources is in `/===/mar/talk/message`.

This helps, but it doesn't solve another two problems: trivial
nouns and containers.

It's retarded to have to add a source file to send a `@ud` or a
`*`. An aura (see above under `coin`) should be a trivial mark.

Also, we need to be able to construct standard containers of
marks: lists, maps, sets, and tuples (or, as a database person
would say, "rows").

### Change #7: meta-marks

Another kind of complex mark that needs to exist: conflict,
difference, and invalid marks.

Conflict data and difference data are two types of noun that are
generated in normal RCS operation. If we have the concept of an
`%html` noun, we also need the concept of an invertible change
from one `%html` file to another; a merge conflict between two
`%html` files; and even a conflict between two marks.

There are two kinds of changes to a dome: manual and automatic.
Manual changes are initiated by the user and should crash, unless
manually overridden. Automatic changes should not crash, ever,
and should not lose data. If they create problems, which they
shouldn't, these problems will need to be cleaned up manually.

This is a complex space to navigate, but it requires a conflicted
merge to be able to resolve to a valid dome containing conflict
leaves, not crash. The present `%clay` goes halfway there and
resolves to a scratch desk, but we can go farther: the whole `git`
dumpster-fire of "merge state" deserves destruction. One change
is a merge that produces conflicts, the next is an edit that
resolves them.

Similarly, all sorts of errors can produce invalid leaves. One
particularly rare case which is nonetheless important is schema
evolution: what happens to files in a mark, when the mark source
code changes. They all need to be re-normalized. And this
operation can fail, producing an invalid value. (We don't do any
of this now, BTW, although `%ford` has the dependency mechanism to
make it possible.) Again, in some cases this should crash the
update to the mark source; in other cases, there is no local way
to handle the crash.

So there must be a way to preserve invalid nouns that can be
repaired by repair tools that expect invalid content, while not
actually marking them as valid so that innocent code is deluded
into using the bad content.

The bottom line: a mark needs to be split into two models:
`++mark`, the original symbolic mark with its source engine, and
something like `++logo`, the meta-mark or mark container. The
mark is the building block; the logo is the building.

### Change #8: filesystem hierarchy standard

While all filesystems remain forks of one ur-filesystem, the
standard tends to enforce itself. But not define itself.

I've always hated the current `/mar` for marks, for instance. I
prefer `/mac`. But others hate this. And so on. Also, by
necessity, our nascent "FHS" is heavily biased toward system
data, away from user data. This is retarded.

Please focus all bikeshedding energy on this problem! Better to
bikeshed about what color to paint the bikeshed, then what shape
the bike gears should be.

### Change #9: security and access control

Oh, yeah, that! They always say not to design security in at the
last minute. Unfortunately, this is exactly what we did. There
is no security at all in present `%clay`. (There is also no push
operation in `%clay`, so it's not as mad as you think -- anyone
can read anything, no one can write anything, which is fine in a
young network where there are no secrets.)

Fortunately, we don't have anything super fancy planned in this
area, just basic access-control lists. These obviously need to
be designed along with the filesystem-hierarchy standard (see
elsewhere).

Is it even possible to do ACLs properly in `%clay`? At this
point, yes. There is an event-oriented security model in Arvo,
though it isn't really hooked up to anything at the moment.
There is also a privilege badge system in `%jael`. The
combination of these two features is quite sufficient for a
decent ACL model.

The idea of event-based security is that every event passed to
`%clay` has a security `++mask`. The mask tells us:

- the set of ships that has _contaminated_ this event
- the set of ships that has _endorsed_ this event
- the set of ships that this event may be _released_ to.

To simplify this system a little and maybe explain it, the
security question in any event is: (a) who has _caused_ this
event? (b) who may receive its _effects_? (These sets never
include your urbit itself, of course, only neighbors.)

For example, if we're doing something because ship X sent us a
packet, and we're going to leak the results of this something
back in a response to ship X, once `%clay` knows what our ship
thinks of its neighbor X, we should have a good picture of what
effects this event should be allowed to cause. If `%jael` knows
that X is our friend, `%clay` can know that X can see our cat
picture.

Causality is separated out into contamination (data from ship X
got into the event) and endorsement (ship X signed the whole
event). (This may be overdesign.) All these sets can be defined
as the empty set (eg, releasing to the empty set means no output)
or the universal set (input from the universal set could be from
anyone, ie, is unauthenticated).

### Change #10: stop using mark-extended paths

When you read a leaf from a `%clay` dome, `%clay` is happy to
perform any necessary mark conversions (the actual work is done
by the `%ford` build vane). You can also just ask for the leaf
in whatever mark `%clay` has it.

It's confusing to think of this mark extension as part of the
path. You shouldn't say `+cat /===/app/talk/hoon`. You should say
`+cat /===/app/talk`, or maybe `+cat %hoon /===/app/talk`.

A mark-extended namespace may be added to `%ford`, to compensate.
But type-converting reads are the rare case, not the common case.

### Change #11: real queries and indexes

A filesystem should postpone being a database until it can no
longer do so. So, please don't think about this problem yet.
I'm joking, of course!

### Change #12: meta-query

Make it possible to query the list of desks in a ship :-)

### Change #13: completely redesign Unix mounting

This is actually a series of changes, described below. But
broadly...

One of Urbit's experiments is live two-way synchronization
between the Unix filesystem and the revision-control store.
Dropbox style, as it were. I think this experiment is basically
a failure. It may be right for cat pictures, but I don't think
it's right for Urbit.

The fundamental problem is that there are all sorts of weird,
flaky ways applications use a mutable filesystem. It's not at
all unusual for an editor to change a file by deleting the old
file, then writing the new one in its place.

You really don't want this to produce a delete change. A simple
cooldown timer for the sync helps a lot with this, but causes
other weirdnesses. In theory, a sync can even cause another
change to the same version of the same desk. And so on.

The thing we fear is just too funky to work (there is some
strange "reflux bug" still affecting it) is any sort of _two-way_
synchronization between Unix and Urbit.

And what I think puts this feature into the deadpool, or at least
cold storage, is that there's no useful workflow that actually
uses it -- at least, when editing Urbit code.

It's actually really nice to have files on a disk that nothing
will automatically modify. If you're using `git` and `%clay` in
parallel, it's nice to mount your `git` working directory. The
original Urbit workflow was to work out of a mounted directory,
but the two-way updates were just too weird and scary, so now we
tend to edit elsewhere and copy in -- which is lame.

### Change #14: figure out what to do with FUSE

We actually have two forms of filesystem access to `%clay`: read-only
FUSE (in a somewhat experimental state), and filesystem watching
(using `inotify()` and `FSEvents` under a `libuv` wrapper).

The FUSE interface is a good one, though it needs more work.
Moreover, it exports the whole Urbit namespace to Unix, not just
`%clay`. For reading Urbit data, FUSE is basically ideal.

The obvious impulse is to make a read-write FUSE. But I don't
think FUSE should be used for recording changes to an RCS, even
though the FUSE API sends you changes as events.

There are three reasons for this. One, the actual filesystem
writes that Unix apps make are typically of low quality and
confusing. Some crack-brained editor will find it completely
normal and unremarkable to modify a byte in a file, by deleting
the file and rewriting it from scratch. You can use a cooldown
timer to wait for this nonsense to converge, but leaving data in
heuristic limbo seems like a very bad idea in FUSE-land.

The second is that people derive a lot of comfort from seeing
actual files on an actual disk. The idea that your datas are
stuck in Urbit is slightly terrifying as a user experience.
We claim to be reliable. It's actually hard to imagine datas that
couldn't be recovered from either snapshot or log. But how can
you possibly believe us on this?

So I think it's correct to lean all the weight of reading data
from Urbit on FUSE, and use filesystem watching for writing.
Heuristic timeouts are fine in filesystem watching, because at
least the data got written when the disk says it got written.
And at least it's on the disk.

Also, FUSE is a daemon by definition, which forces us to think a
little harder about how to run the Urbit process as a daemon.
But this is a separate discussion.

### Change #15: one-way, nonced working desk

A one-way mount is a much less crazy thing. It works the same
way our two-way mount works today, but with only one writer: the
user, via Unix.

Since a mount is one-way, it needs to have an absolute write lock
on the desk it's writing to. We cannot have a `%home` desk which
we are also editing with filesystem watching.

Instead, we have a temporary and anonymous state that's connected
itself with your `%home` desk. Desk names have to be valid
symbols, but we can use `hep`, `-`. A reasonable choice is to
pick a random 32-bit name for each mount instance -- so the desk
name is not `%home`, but `%home-bosdut-sigder`. (Randomizing
instead of always using a fixed suffix, say, `%home-work`,
just makes all kinds of screwups less likely.)

You create a mount simply by mkdiring the desk name in your pier.
Just the base name, Urbit will come up with the `%bosdut-sigder`
part and put it in a `.desk` file at the desk root. To forget
the mount, just delete this file. This avoids the ugly confusion
between unmounting a mount, and deleting all the data in it.

(Urbit will keep a set of the mount desks it's used and
forgotten, not reuse them, and block all requests into them. By
blocking, we can delete without losing referential transparency.
Yes, Virginia, Urbit can forget!)

Note that the auto-reload behavior of applications is extremely
useful when testing. When testing, you can either switch the
active application desk from `%home` to `%home-bosdut-sigder`,
or activate autosync from the latter to the former.

### Change #16: commands as metafiles

A new idea I'd like to play with is that, since the basic model
of the mount process is to read Unix files and suck their
contents into Urbit, you should be able to control a mounted
`%clay` desk through Unix filesystem operations alone.

No Urbit command-line access, not even any `urb/` HTTP control
channels, should be required for the user to generate `%clay` data
through filesystem mount, or to set up the mount.

An RCS experience that works entirely through Unix tools, in
which the only connection between content creation tools and
revision-control tools is shared access to the filesystem itself,
is essential if your RCS has something so repulsive as a daemon.
Otherwise, you're basically, like, reinventing Perforce.

More concretely, the Urbit experience today requires `:hood`
pokes (Urbit shell commands, basically) for all nontrivial RCS
operations, from mounting to merging. Again, there are lots of
situations in which you can write into a mounted filesystem (the
protocol for Unix communication could be easily adapted to
communicate with a browser-based editor, for instance), but you
don't want the user to have to bother with an Urbit shell.

Even commands like mounting and merging are easily communicated,
through filesystem writes that any Unix tool (including many
macro editors).

This is very easy for a filesystem watcher. One such protocol:
if you want to send the daemon a command relative to some
directory, write a `.ur-command` metafile in that directory. The
daemon accepts the command by deleting it.

The user experience is that you configure your mounts by simply
making the directories and configuring dotfiles in them. Unlike
in the present system, Urbit will never modify your datas
silently in the background.

Here's what this looks like:

Suppose you want to edit some data in the `%home` desk. Your
data is in `/=home=/mar/talk`. You also want a read-only view
of `/=home=/arvo`.

From Unix, you do something like this:

```
  $ cd $pier
  $ mkdir -p home/mar/talk
  $ touch home/mar/talk/.edit
  $ mkdir home/arvo
  $ touch home/arvo/.read
```

Want to commit your changes? That means merging the working
desk, `%home-bosdut-sigder`, into the `%home`. Put a commit message
into `home/.commit` and it'll happen. If there's an error, it
will appear as `.error`.

The mount has a .version file which simply contains the change
number (of the working desk) which any edits are relative to. If
the urbit daemon is running and watching, edits will be absorbed
quickly (probably after a heuristic timeout), and the version
incremented. But we always are confident that the edits are
against the latest version, or at least we can use this as a
sanity check. All kinds of insane things can happen to get a
filesystem out of consistency.

This design obviously needs a little fleshing out, but I'm quite
confident it's a convenient and reliable way to drive `%clay`
from Unix.

## In conclusion

There's obviously a lot of fun here! There are two things you
can do right now.

One, talk about `%clay` on [this forum
thread](http://urbit.org/~~/fora/posts/~2016.10.25..17.37.47..6937~/) or
on [:talk](http://urbit.org/stream). Both hosted on Urbit
itself!

Two, poke around the
[code](https://github.com/urbit/arvo/blob/cc-release/arvo/clay.hoon).
Make sure you're on the development branch (`cc-release`).

Phasing in this work will be a fun and interesting challenge.
(My suspicion is that the right first task is the Unix mount.)
Let's talk...
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Why Urbit Probably Doesn't Need a Blockchain]]></title>
            <link>https://urbit.org/blog/why-urbit-probably-does-not-need-a-blockchain</link>
            <guid>https://urbit.org/blog/why-urbit-probably-does-not-need-a-blockchain</guid>
            <pubDate>Wed, 13 Jul 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/why-urbit-probably-does-not-need-a-blockchain.jpg)

TLDR: Urbit (probably) doesn't need a blockchain, because the Urbit
address-space PKI is a special case of a consensus ledger (itself a
special case of Byzantine agreement).

Special cases are often easier to solve than general problems. The
"New Jersey" or "worse-is-better" school of systems design emphasizes
solving any problem with the weakest possible tools.

## The worse-is-better school

Culturally, Urbit is best described as a functional stack built in the
"New Jersey" school of system software design, as described in Richard
Gabriel's famous
["worse is better"](https://en.wikipedia.org/wiki/Worse_is_better) essay.

There are two kinds of mindsets when approaching hard technical
problems. The "MIT" mindset, more typical among mathematicians and
scientists, wants to attack the problem as its simplest and broadest
case, producing the most general and powerful solution available. In
short: better-is-better.

The "New Jersey" worse-is-better mentality, more typical among
programmers and engineers, wants to do everything possible to _not_
attack the problem. Can I produce a serviceable approximation to a
true solution? Do I actually have to solve the general problem, or
can I reduce it to an easier special case? Can I change the product
so it doesn't have this problem?

Ideally, anyone building anything has both these mindsets in their
toolbox. But it's worth noting that (a) Jersey designs (meaning the
Bell Labs school that produced Unix, C, and Go) tend to beat MIT
designs in the marketplace, and (b) there are very few pure-functional
systems built with the true Jersey spirit.

## Why Urbit (probably) doesn't need a blockchain

Nakamoto consensus is an example of better-is-better. The blockchain
design is actually more powerful than it needs to be. It's not just a
trustless decentralized ledger; it's a trustless decentralized
database and (as Ethereum has realized; but this idea is clearly
present in Bitcoin's scripting language) a general-purpose, zero-trust
decentralized computer.

Again, Urbit is not a general-purpose decentralized database or
consensus computer. It's a special case of the former, which is a
special case of the latter. Urbit is nothing but a digital title
chain for network addresses. Our belief is that the special case is
much easier than the general case, which is why Urbit (probably)
doesn't need a blockchain.

The rest of this essay describes what makes this special case special,
and how we can use that to not need full Nakamoto consensus, or any
kind of general-purpose Byzantine agreement.

## The double-sell problem

Urbit has the same basic "double-spend" issue as Bitcoin. As Satoshi
puts it: "The problem of course is the payee can't verify that one of
the owners did not double-spend the coin." But Urbit is not a
currency, so we say "double-selling."

"Double-selling" means signing over an Urbit address (_ship_) to two
different parties at the same time, presumably with the intent to sell
it to both and skip town with the loot.

Again, the logical problem is the same. Bitcoin attacks it as a broad
theoretical breakthrough: better-is-better. Urbit attacks it as a
narrow special case: worse-is-better.

Intuitively, Urbit's answer is that a real-estate transaction is
substantively a very different thing from a credit-card payment. No
real-estate agent ever has ever leaned over the desk, quickly grabbed
_both_ the check and the keys, and run laughing out the door.

To understand more rigorously how Urbit is a special case, let's take
a quick look at the Urbit address space and PKI.

## The Urbit address space and PKI

(NB: this description differs in minor ways from the running code.
Where they differ, the description is right. Urbit is not at present
secure: use for entertainment purpose only.)

An Urbit ship is an unsigned integer that serves four purposes: a
cryptographic identity, a packet routing address, a stateful virtual
computer, and a unique, human-memorable name.

Each ship is owned by a private key. To transfer a ship to a new
keypair, sign the new public key with the old private key. This
revokes the old key and activates the new key. Propagating this
update globally makes the revocation global. This is essentially the
digital title system a smart 12-year-old would design.

### Ships and wills

Ships are 128-bit numbers classified into tiers by bitwidth. An 8-bit
ship (a number less than 256) is a _galaxy_. A 16-bit ship is a
_star_. A 32-bit ship is a _planet_. A 64-bit ship is a _moon_. A
128-bit ship is a _comet_.

The chain of signatures for each ship is called a _will_. Unlike most
certificate systems, there is no metadata in an Urbit will. Nothing is
signed but the public-key fingerprint. The length of the will is the
keypair version that owns the ship. This version is called its
_life_. Each new signed fingerprint in the will is a _deed_.

Who gets to create a ship? Comets are fingerprints of a random
keypair. Moons, planets and stars are created by their _prefix_, the
ship whose bits are the bottom half of their formal width. For
instance, the star `0xbeef` is the prefix of the planet `0xdeadbeef`.
Galaxies have their fingerprints hardcoded in the official kernel.

Ship numbers are not generally written in hex. They're written in
Hoon's `@p` syntax, a phonemic base-256. `@p` also permutes within
tiers, to superficially conceal prefix structure; for instance,
`0xdead.beef` is `~firbyr-napbes`, while `0xcafe.beef` is
`~nissep-sopnub`.

### Parent hierarchy

The prefix of a moon, planet, or star also becomes its _parent_. The
parent of a ship is its natural locus of federated services. The most
basic such service is to mediate P2P routing, as a so-called
"supernode." But the set of potential federated services is
unbounded.

For moons, each new key update is signed by the parent. Planets and
stars sign their own updates, making them independent. To prevent
denial-of-service attacks by parents against children, stars and
planets can _exit_, choosing a new parent. An exit deed is a key
update also signed by the new parent.

The full public cryptographic record of a ship is its _dossier_. The
dossier is the set of ship-will pairs, including all parents and
prefixes recursively, needed to validate the ship's current key. A
ship can process a dossier from an untrusted source.

The full set of ship-will pairs a ship knows is its _cabinet_. So the
crucial question for PKI propagation is whether a submitted dossier is
accepted into a ship's cabinet.

### Propagation race

The rule is simple: any deeds in the dossier which are new (not
already in the cabinet) must not use keys superseded in the cabinet.
Otherwise revocation doesn't work. But revocation affects only
dossiers received in the future; nothing already in the cabinet can be
revoked.

Intuitively, this algorithm creates a propagation race. Life `2` of
`~firbyr-napbes` revokes life `1` of `~firbyr-napbes`, so propagating
life `2` to the whole network ensures that anyone who steals the
private key for life `1` can't use it in any way -- whether to launch
children, or to sign a new, bogus life `2`.

## Solving the special case

So how can we solve the double-sell problem, for the special case of
the system designed above?

### Double-spend relaying in Bitcoin

The first thing we need to notice about our special case is that _even
Bitcoin_, not considered as a general consensus problem but just as a
decentralized payment rail, isn't that far from _not_ needing a
blockchain.

As the Karame ["Two Bitcoins at the Price of
One"](http://eprint.iacr.org/2012/248.pdf) paper points out:

> An efficient countermeasure to combat double-spending on fast
> Bitcoin payments would be for Bitcoin peers to propagate alerts
> whenever they receive two or more transactions that share common
> inputs and different outputs.

"Fast Bitcoin payments" means zero-confirmation, ie, Bitcoin without
the blockchain. These double-spend alerts have never been integrated
into Bitcoin Core, despite frequent proposals. Given that Bitcoin
_does_ have a blockchain, it seems quite sensible for purists to shun
hacks that make zero-conf transactions somewhat more secure. Also,
double-spend alerts in Bitcoin are a DoS vulnerability; Bitcoin has
fees to control the cost of propagating transactions, but who pays for
an alert?

In principle, however, we could imagine a version of Bitcoin without a
blockchain, in which the mempool was the ledger, and there was an
alerting and/or conflict model to detect and resolve double spends.
An accepted transaction is simply one that propagates to one or more
randomly chosen observer nodes.

This design, for the problem that Bitcoin is solving, intuitively
feels weak and a little hacky. The Karame paper is not actually
advocating for removing the blockchain from Bitcoin. At the same
time, low-value zero-confirmation payments are commonly used.

One way to think about security is to flip the tables and think of the
defender as the attacker, and vice versa. Just imagine you have some
moral right to double spend. The rest of the world is unfairly trying
to stop you. Can you defend yourself?

In the context of a gossip network that shares all the things, a
procedure that involves telling one person one thing, and another
person another conflicting thing, and not getting "hacked" by the
unfair world which believes there should be only one truth, is
inherently quite fragile. And where the attack is fragile, the
defense is robust.

Most of the security in any digital title system comes from the PKI
itself. The double-spend problem, the general issue of Byzantine
failures in information propagation, is already a corner case. So
perhaps we can solve it as a corner case.

Again: _even Bitcoin_ isn't that far from being able to build a
practical decentralized ledger without a blockchain. The same gossip
model that broadcasts nonconflicting transactions is not at all
incapable of reacting to conflicting transactions. We're not really
recommending that Bitcoin ditch the blockchain, but this gives us hope
with our fundamentally easier problem.

## Various specific specialnesses

What are the differences between the Urbit double-sell problem and the
Bitcoin double-spend problem? Is our special case really, truly,
special?

In worse-is-better mode, we want every special-case advantage we can
get. Every difference we find is one we can use as a leverage point.

### Minimal transaction interdependency

The first major technical difference between the Urbit title history
and the Bitcoin blockchain is that Bitcoin and its relatives are
designed to secure a complete, interdependent, collective transaction
history. Except for the parent-child relationship, Urbit wills are
independent of each other.

Bitcoin's use of UTXOs rather than balances reduces interdependency
somewhat. But the validity of each transaction is still dependent on
all the transactions that created its inputs. (Ethereum drops the
UTXO model, whose value in reducing dependencies may not match its
cost in complexity.)

Urbit is not a payment system or a shared ledger. Bitcoins are
divisible, but Urbit ships aren't. An Urbit will containing its
parent chain is self-validating and has no dependencies. There is no
collective history. There is no Merkle tree. There is no chain, with
or without blocks.

This simplification doesn't eliminate the double-sell problem in
theory, but makes it much more tractable in practice. The set of past
transactions (key transfers) that a new transaction could conflict
with is much smaller.

### Trust hierarchy and governance structure

The second major technical difference is that Bitcoin is a flat,
trustless, fully decentralized system. Urbit has a hierarchical,
polycentric governance system which is a trust hierarchy.

Now and for quite some time, urbits default to automatically accepting
OS updates from their parent, making this trust effectively absolute.
This is not a novelty -- all "evergreen" browsers now work this way.
You trust your browser quite a bit, which means you trust your browser
vendor.

And since few Bitcoin node operators code their own daemons, the same
dependency on a source distribution exists in Bitcoin. It's informal
and off-chain, though, which is not really a good thing. (Urbit is
like if Bitcoin Core hotpatched itself automatically by publishing
source-code diffs on the blockchain.)

To be on the safe side, we should think of Urbit as a centralized
system until the OS update that turns off automatic updates is
shipped. This of course requires a certain measure of perfection,
which cannot in any way be predicted.

After Arvo proper becomes "deciduous" (apps will of course always be
remotely hotpatched), child-to-parent trust should diminish to the
power of the parent to deny service to the child. This will always be
present without some major redesign.

But it's opposed by the equal and opposite power of the child to
switch to a different parent, creating a competitive market in
governance. This should deliver service at the highest quality and
lowest price, fortifying trust with incentives. The power of a
restaurant owner to deny you service does not give the food industry
the power to starve you to death.

And if no parent wants your business, with 2^16 stars who could accept
it, you probably shouldn't be on the network at all. Urbit, like a
real society, is designed to be a network of incentives that holds
everyone in productive tension. We want everyone to be free, and no
one to be unaccountable.

For example: a parent which extends its will also needs to send
updated signatures to its children and former children. Either will
otherwise be unable to propagate their dossiers to ships whose
cabinets have the updated parent will, _even if some other parent
adopts them_.

But Urbit is a collectively governed and updatable system. A star or
galaxy which denies service to its own children will (a) get a bad
reputation, (b) drive its children to other parents, and (c) force the
network to hardcode a ship-specific exception into the propagation
algorithm, overriding stale-key revocation.

In theory, a parent can extort its children by denying service. In
practice, since Urbit is self-governing, not ungoverned, and its
government can right this wrong with a source-code patch, the
extortion won't work. So it won't happen. So the act of government
won't be necessary, and won't happen either.

Of course a perfectly decentralized system would be freer. But worse,
as usual, is better. And since we are paying for this worseness,
imperfect decentralization, we'd like to get all the mileage out of it
that we can.

Again, Urbit, not being a trustless system, does not have to solve the
trustless consensus problem -- although we still very much want to
minimize and bound the delegation of trust. This is an obvious
relaxation of Bitcoin's hard theoretical problem.

### Routing: security through topology

Please don't laugh. Security through routing topology isn't a joke --
unless firewalls are a joke. Cisco sells too many firewalls for them
to be a joke.

In Bitcoin we may have all sorts of reasons to ask what ship holds
what coins. In Urbit, when we ask what key controls an ship, we are
either sending or receiving a message. Is our outgoing message safely
sealed to the current owner? Is our incoming message properly signed
by the current owner?

When the parent also forwards all packets until a P2P link is
established (Urbit forwarding resolves to STUN if either party has
full cone NAT, TURN if not), we can design in all kinds of
interactions between routing and certificate management.

In particular, a parent which is a single source of truth in some
sense is a very attractive design element. Again, we're paying for
our imperfect decentralization. We might as well use it.

For example: I want to send a packet to ship X. Two parties, A and B,
are competing for ownership of X. A is the rightful owner. I am
secure against B if either of these conditions are true: my packet can
only be decoded by A, or my packet is not sent to B. Both would be
ideal, of course. Either will do.

### Latency and friction tolerance

Confirmed Bitcoin payments aren't especially low-latency by payment
standards. They're reasonably low-friction by payment standards. But
fees are certainly a thing.

Urbit is digital real estate, not digital money. When we look at the
standards of latency and friction in actual real estate -- where a
transaction that takes a week is super-fast, a 5% payment overhead is
normal, and a third-party intermediary is standard -- we see a much,
much weaker set of requirements.

Obviously a week and a 5% overhead are incredibly sucky levels of
latency and friction. The point is that even if this is the only
level of performance Urbit can achieve, that's not necessarily the end
of the world for Urbit.

For instance: if we wait a week for a double-sell alert, and we don't
see one, either the gossip network is totally hosed (to a point we'd
surely find out about), or there wasn't a double-sell. This stuff is
just not that hard.

(One little-made point about Bitcoin, by the way, is that Bitcoin
enables trust-free _payments_, but not trust-free _exchanges_. The
seller still needs to deliver the goods either before or after the
payment; in either case, there is trust. Only Ethereum can solve this
problem -- and only for digital exchanges.)

## We can afford to be patient

With a better-is-better, general-purpose solution, one size fits all
until the end of time. With a worse-is-better, special-case solution,
the details of that case are critical.

But we actually don't know these details. One rule of the
worse-is-better school: never solve a problem before you have to. You
don't know all the details, and you need those details. (Of course,
with the better-is-better approach, the details don't matter at all.)

Is there such a thing as a transitive adjective? Grammarians are
unclear. But technically, the adjective "secure" is always an error.
Nothing is "secure." "Secure against X" is the correct usage, where X
is some threat model.

Urbit is an insecure test network with no sensitive data on it. This
will remain true for a while. No Urbit ship has ever been transferred
cryptographically. This will also remain the status quo for quite a
while.

We _don't know the threat model_. We _can't solve the problem_. It's
as simple as that. The best Urbit can do, at the present time, is map
out the ballpark of solutions.

And we have time to proceed patiently. One way to think about the
timing of cryptographic decentralization is to look at the DNS. It's
clear that now, a decentralized DNS with cryptographic domain-name
titles would be extremely desirable. It was never designed to happen.
It will probably never happen.

But if we look at when cryptographic DNS with allodial title _should_
have happened, it's probably sometime in the mid-90s. Ie, after over a
decade of production use of the Domain Name System. In short: there's
no need to hurry here.

## A map of the solution space

But we still need a map of the worse-is-better ballpark. Let's look
at some options, from least secure to most.

The essential question we can't answer, without a better sense of the
threat model, is how aggressively we need to propagate wills. We
especially are not sure about the threat model of malicious stars
(16-bit ships) and/or galaxies (8-bit ships).

We need to know what kinds of double-sell attacks are plausible. Since
we don't know this yet, we need not one propagation design, but a
range of designs -- stretching all the way up to a full blockchain.

### Acceptance model

What doesn't change is the will _acceptance_ model. A ship will
always accept a new will if (a) the new will extends the old will, (b)
the parent signature on the initial public key is at least as recent
as the ship's current version of that parent.

The parent clause implies that when a parent extends its will, it
needs to send updated initial signatures to all the children it's
launched. Otherwise, their own future updates will not be accepted by
ships that have seen the parent's update.

This is not a big deal in the world of parent responsibilities. But
like many such responsibilities, it lets a badly operated parent deny
service to its children.

A ship accepts all wills, new or updated, and stores them permanently.
If this is abused trivially as a DoS vector, Urbit will mitigate it by
the usual technique of degrading service to non-scarce ship tiers.
Scarcity rules.

### Level 0: passive propagation only

The Ames protocol can piggyback a will on any packet. Each ship also
permanently records which other ships hold which version of its own
will. An update is automatically sent when needed.

With level 0 propagation, all key exchanges in Ames are passive and
invisible to the programmer. When the sender has no will or symmetric
key for the receiver, the packet is signed, bundled with the will, and
sent as cleartext.

Signed cleartext? If you have no will for a peer, you've never talked
to this ship before. Your first words to a stranger probably won't be
super secret. If this isn't true, the programmer has to send an
innocuous message first and wait for it to be acknowledged. Kicking a
rare corner case up to the programmer is a classic worse-is-better
move.

With level 0 propagation only (the current implementation, because we
don't even care about key updates yet), an updated does not
effectively revoke the old key. If Alice updates to a new key,
Mallory steals the old key, then Mallory talks to Bob before Alice
does, Mallory can impersonate Alice.

So not only does level 0 not solve double-sell, it's also quite
insecure. But it's still fine for now (because Urbit isn't really
decentralized yet).

### Level 1: neighbor-only propagation with parent filtering

The list of other ships which hold your will, essentially the list of
all ships you've talked to, is your list of _neighbors_. You
essentially have permanent, if perhaps very sporadic, conversations
with all your cryptographic neighbors. Symmetric keys time out fast,
but wills are held forever.

By proactively pinging all your neighbors when you extend your will,
you prevent anyone who finds the old private key (ideally you update
when your old key is stale, not when it's actually been _stolen_) from
jumping into these conversations.

What about non-neighbors? We add a second feature: a parent will only
forward a packet if its sender matches the current will. So updating
your parent (who is always your neighbor) transforms it

There are two cases: where Alice's parent Trent is also Bob's parent,
and where Bob has a separate parent Walter. In the first case, the
expected packet flow is that Alice will send the packet to Trent, who
sends it to Bob. In the second case, Trent sends it to Walter, who
sends it to Bob.

In either flow, Bob or Walter is sure that the packet came through
Trent. Since Trent is Alice's parent and hence Alice's neighbor, and
hence is updated, Trent will forward no packets from Mallory. So
Mallory has no way to reach Bob.

Non-neighborly packets not matching this flow can't be accepted.
Suppose Mallory gets Bob's public IP address directly? If Bob gets a
non-forwarded packet marked "Alice," but Alice is not his neighbor,
that's super weird. He must reject the packet.

Level 1 is nice because it provides a reasonable level of security,
but it's still extremely simple. Not only does it not use a
blockchain, it doesn't even need a gossip flood!

And level 1 propagation also does a competent worse-is-better job on
the double-sell problem. Trent simply becomes the single source of
truth. The buyer of Alice needs to check that Trent, her parent, has
Alice's latest will from the buyer's perspective. If Alice's seller
propagates a different fork to other ships, this damages Alice's
ability to communicate, but produces no obvious gain for the seller.

Level 1 puts a lot of security weight on the parent. If Trent
misbehaves, for example by not filtering Mallory's packets, Alice can
be impersonated. And its solution to the double-sell problem is
adequate, but not ideal. Level 1 is the worse-is-better sweet spot
for a young Urbit, but will probably give way to level 2.

### Level 2: broadcast all wills

We can't say definitively that level 1 will be inadequate. But
intuitively, it feels slightly weak. We will probably need a gossip
protocol.

The only ships that can be transferred are galaxies, stars and
planets; if all updates of all wills of all these major ships are
broadcast, we hardly have a scaling problem like Bitcoin's. Even if
changing the lock on your front door counted as a real-estate
transaction, there are a lot fewer real-estate transactions than
credit-card payments.

Moreover, conflict detection (double-sell alerts) is a natural part of
any gossip protocol. Gossip should be between stars, not directly
between planets; horizontal gossip, vertical distribution.
Star-to-planet distribution may still be limited.

Especially since stars are somewhat trusted, ganking a gossip protocol
with random update edges is incredibly hard and requires a pretty
preposterous conspiracy. And flooding all planet wills does a lot to
keep stars honest. It would be incredibly stupid for a star to try a
double-sell attack against its own planets, but code is always more
powerful than mere incentives.

Finally, the exit model isn't fully baked yet, but it will probably
have more aggressive propagation needs. What's clear is that an exit
statement is another type of will entry, involving a signature both
from the previous key and the new parent. You can only escape to
another ship of your parent's class that agrees to adopt you.

In general, because escaping need to work for routing (without the
cooperation of the former parent), wills containing an exit statement
(a planet moving to a new star, or a star moving to a new galaxy)
exit) probably need to be flooded globally among all 8-bit galaxies
and 16-bit stars. Exits should be rare, so they shouldn't present
much of a scaling problem.

### Level 3: full blockchain

Obviously a blockchain can solve Urbit's problem. Probably the right
thing to do would be to use the Bitcoin blockchain, and confirm the
current Urbit key version with a "colored coin" of some kind. (This
should not be confused with the orthogonal idea of representing Urbit
_invitations_ as colored coins.)

This involves making all Urbit ships into Bitcoin SPV nodes at the
least. Not the worst fate in the world, but also a cost.
Alternatively, Urbit could have its own "altcoin" blockchain, with
actual Urbit-specific mining.

Again, given that level 2 seems like it should work quite well, it's
hard to see why level 3 propagation would be needed. But we can't
really know at this point. There's a reason Urbit can update itself
over the air. That's why we say: Urbit (probably) doesn't need a
blockchain. If it does, we can retrofit it.

## Retrospective note

This essay has presented the Urbit cryptographic title as a low-power,
stripped-down, worse-is-better variation of Nakamoto consensus.
That's clearly the right way to introduce it in 2016.

Actually, though, this part of Urbit was designed before the Bitcoin
paper was published. There were other academic approaches to
Byzantine consensus, but certainly none validated on a large scale as
Nakamoto consensus has been. It never seemed appropriate to treat
cryptographic titles to network addresses as a case of generalized
Byzantine consensus, and without the existence of Bitcoin there was no
temptation in this direction.

In a sense the secret of PKIs is that PKIs are easy. What's hard is
adapting an existing identity and authorization structure into a PKI.
If you build the simplest possible PKI, then force the human processes
to fit themselves to the protocol instead of vice versa, you have a
much easier job. Similarly, if you are not adding PKI to an existing
network, but building the network and the PKI as one system, many
simplifications are possible. This is once again the classic
worse-is-better method.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Common Objections to Urbit]]></title>
            <link>https://urbit.org/blog/common-objections-to-urbit</link>
            <guid>https://urbit.org/blog/common-objections-to-urbit</guid>
            <pubDate>Mon, 27 Jun 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/common-objections-to-urbit-1.jpg)

We love crowdsourced criticism. We've heard a lot of great
objections to Urbit. Surely there's more out there! We'll
revise this document to include anything new and interesting.

Here's our list right now:

- [Urbit is not ready for prime time.](#prime)
- [Nock jets are a total hoax.](#jets)
- [Urbit needs an infinitely extending packet/event log.](#log)
- [Urbit is a total scamcoin. It's 100% premined.](#scam)
- [Urbit isn't even really decentralized! It has a government!](#gov)
- [Sandstorm/IPFS/Ethereum is way ahead of Urbit.](#sand)
- [Urbit doesn't have enough planets for every human being.](#planet)
- [Cloud computing is inherently non-private.](#pwned)
- [Urbit will never be able to call any existing code.](#code)
- [Hoon is too weird. No one will be able to program in it.](#program)
- [Urbit programmers are stuck with Hoon.](#stuck)
- [Ordinary users will never be able to manage an Urbit server.](#user)
- [Urbit has no killer app.](#killer)
- [Urbit is sniffed at by Houyhnhyms.](#horse)

_"We choose to go to the moon, not because it is easy, but because it is hard."_
— [John F. Kennedy](https://www.youtube.com/watch?v=g25G1M4EXrQ)

## <a name="prime"></a>Urbit is not ready for prime time.

_TLDR_: we agree.

Urbit right now is a fun toy. It is fun to learn Hoon. It is
even fun and quite practical to make actual contributions.
(Hoon's IEEE floating-point was written by someone we've never
met: `~nym`, formerly `~nodpet-rinned`.) In fact, we have never
seen anyone _not_ have fun with Urbit.

But there is all kinds of stuff wrong with the codebase. Urbit's
documentation is much improved, but remains incredibly weak --
Arvo is almost totally undocumented. Scaling is poor at best.
Urbit's reliability is dubious. Its security is nil.

Urbit is feature-frozen. The only thing we're working on now,
and for the rest of 2016, is doc, debugging and and self-hosting.
In that order of importance -- teaching Urbit is more important
than fixing it, which is more important than making it useful.
But we're quite confident that these are all solvable problems.

The most important milestone about Urbit today is that it's ready
for technical decisions to be made collectively. A system like
Urbit can only be invented by a mad auteur. It can't be
maintained or stabilized by a mad auteur. Our primary goal today
is expanding the number of people who understand Urbit, and we
expect these pioneers to participate in technical governance.

## <a name="jets"></a>Nock jets are a total hoax.

_TLDR_: all of computing is a hoax. You can't compare a hoax
to nothing. You can only compare it to all the other hoaxes.

A "jet" is a sort of software device driver in Urbit. Urbit is
precisely defined in terms of an interpreter that fits on a
T-shirt, Nock. But a naive implementation of Nock is nowhere
near practical, because Nock has only one integer operation:
increment. For example, to decrement a number in Nock, you
increment a counter up to the number under it.

The only way an efficient Nock interpreter can work is to
recognize algorithms like decrement, and implement them
non-naively. By far the easiest way to do this is not to analyze
arbitrary code as it's being executed, but to register and match
well-known implementations in the standard library. No one
should be writing their own decrement.

But the semantics of the interpreter, _so long as the jet and the
jet harness are defined correctly_, are exactly those of Nock.
We are not extending or changing Nock in any way. We are just
taking a shortcut in certain cases we understand perfectly.

It's not at all unprecedented to have implementations much more
complex than the corresponding specification. The x86
instruction set is relatively simple; the complexity of its
decoding and execution path in a modern CPU is enormous. This
path may well have "peephole optimizations" that replace matched
algorithms, and if it doesn't the modern compiler does. People,
_bad_ people, use "jets" to cheat on benchmarks all the time.

Nock is designed as a standard. It's built like a standard.
Typically what causes real problems in standards is ambiguity.
Two implementations are incompatible, but each swears it has the
right interpretation of the natural-language spec. This simply
cannot happen in the Nock world. If two implementations
disagree, at least one of them is incorrect. This puts us firmly
in "with enough eyeballs, all bugs are shallow" territory.

The fact remains, however, that a Nock interpreter without jets
is completely useless. And there is not even an informal
document that tells you what jets you need for a reasonably
efficient Urbit. (There should be such a document.)

The correct way to think about jets is not to compare them to a
perfect interpreter created by unicorns. Jets are a combined
replacement for two other techniques in language implementation:
intrinsics and a foreign-function interface.

Compared to both intrinsics and an FFI, your jets have one key
disadvantage: they need to be specified in pure code. You may
not have this executable specification, which means you need to
write it. Is this really so bad for your development process?
An executable specification? Which can be trivially tested
against the efficient implementation?

Compared to intrinsics, jets give you true separation between
mechanism and policy; only the interpreter, not the programmer
and not the compiler, needs to know what's accelerated.

Compared to an FFI, jets preclude I/O, so can be trivially
sandboxed. Except that the programmer needs to mark routines
which may benefit from optimization with a hint, here too we
separate mechanism (efficient implementation) from policy.

Yes, formal verification of jet equivalence is desirable.
However, in the real world, many specifications, including quite
complex ones, are tested into equivalence by brute force.

Urbit has some jet abuses. The equivalence between our markdown
parser in Hoon and the CommonMark C library is super dubious. It
should be revisited.

But the miscomputation resulting from a minor jet discrepancy is
not a security hole or even fatal. It effectively means the
event history, computed correctly, does not match the current
state. The way to resolve this conflict is for the current state
to win, and the event history to be discarded -- not abnormal
anyway. See the next question.

## <a name="log"></a>Urbit needs an infinitely extending packet/event.

_TLDR_: no, it doesn't. Urbit can prune the log.

We can prune the event log because the Urbit transition function
doesn't have any access to the event history -- just the current
state and the current event.

Urbit defines the semantics of a complete event log. It doesn't
and can't require an implementation to maintain the whole log.
It can maintain a checkpoint and the log since that checkpoint.

However, any practical urbit maintains a periodically updated
checkpoint. Our present implementation doesn't provide a way to
prune the event log. But that's just a missing feature. We have
one or two of those!

## <a name="scam"></a>Urbit is a total scamcoin. It's 100% premined.

_TLDR_: yeah. But at least it's not the DAO.

Like a cryptocurrency, Urbit is a digital title. But Urbit is
digital land, not digital money. If you assess it as a currency,
it's a lousy currency. If you assess a cat as a dog, it's a
lousy dog.

In real-world economics, the crucial distinction between land and
money is that land (a) has intrinsic utility and (b) is
non-fungible.

Because of (b) alone, frictionless transactions in land are
impossible. A blockchain is only needed to ensure zero-cost
high-frequency transactions. So digital land doesn't need a
blockchain. Which means it doesn't need mining.

Of course, just because a digital title system doesn't need
mining, doesn't mean it can't distribute an initial allocation by
proof-of-work -- or by any other arbitrary method which is
careful not to benefit the system's own developers. Could we
give away the Urbit address space randomly? Sure. But why?

Probably the purest design is the "proof-of-burn" initial
allocation used by some coins. By any standard, proof-of-burn is
technically beautiful and results in an extraordinary level of
ethical independence. We can't help but admire it.

But any altcoin or metacoin is just way less work than Urbit. An
altcoin can afford to burn even its creation energy, capturing no
value at all from its seigniorage. Your altcoin doesn't have a
clean-slate system software stack to drive. If your rocket has
to go to the moon, it's going to leave a little bit of smoke in
the air.

Ethically, what makes "premining" feel wrong is that the creators
of the currency are rewarded disproportionately for their effort.
The scamcoin is a get-rich-quick scheme, vaguely pyramid-shaped.
Nothing about Urbit matches this pattern at all.

Curtis invented Urbit. So by the [homestead
principle](https://en.wikipedia.org/wiki/Homestead_principle), he
started out owning all of it. But by now, Urbit's 8-bit galaxies
have already been distributed among [57 separate individuals](https://github.com/urbit/arvo/blob/master/sys/vane/ames.hoon#L118-L373).
Curtis owns 20, or about 8%.

Tlon, the corporation which still runs Urbit development, has 95.
(Without Tlon, there is basically no Arvo.) 50 are reserved for
a hypothetical Urbit Foundation. Tlon employees have another 16.

The rest of the galaxies belong to donors, investors,
contributors, contest winners, and just random people who were in
the right place at the right time. One is a Silicon Valley
tycoon. Another is an Orthodox nun in a monastery in Greece. A
couple are ex-Tlon employees who might totally hate us. There is
nothing they all have in common, which is sort of the point.

This property distribution looks a lot like land ownership in the
real world -- complex and asymmetrical. That's no accident. If
you have a problem living in New York because New York's real
estate is not distributed equally among its residents, you may
have a similar problem with Urbit. The reality is that Urbit,
like New York, wasn't born yesterday and comes with a complex
ownership history which we couldn't possibly change, even if we
wanted to.

Decentralization is hard. The only real goal of a property
system in address space is to create and maintain
decentralization. The whole network has to exhibit centrifugal
force, not centripetal force. Proof-of-work systems certainly
seem to have unexpected centripetal qualities, producing
unanticipated concentrations of centralized hashpower. See the
next objection.

## <a name="gov"></a>Urbit isn't even really decentralized! It has a government!

_TLDR_: it's technically impossible for Urbit to be
decentralized at this stage of its life. Urbit is designed to
achieve decentralization, not be born with it.

A young network can't afford to be decentralized. It has to act
as a unit. Because it has no network effect, it needs every
scrap of efficiency it can get.

A decentralized general-purpose computing network like Urbit can
_only_ be bootstrapped by a central government. For example, by
default your urbit upgrades its OS automatically (like an
"evergreen" browser) with signed network updates. Whoever signs
these updates is a government by definition.

When it's impossible to eliminate centralized power, it becomes
necessary to tame, stabilize, and limit it. This should not be
surprising to anyone living under a constitutional government.

As we found out with the DAO, if a network isn't ready to be
decentralized, its developers shouldn't even try. If Ethereum is
hard-forked to roll back the DAO (which looks like the most
probable result), it acknowledges that it both has a central
government, and needs a central government. Decentralization is
good. Pretend decentralization -- "decentralization theater" --
is harmful, and not a effective path to actual decentralization.

A key test of a free software project's health is whether it can
fork. So long as the unity of the public-key hierarchy and the
network protocol is maintained, the Arvo kernel and Urbit system
can fork in all kinds of ways without disrupting the network.
Any stress will fragment the "government" that develops the
kernel, and as it fragments it grows more limited and stable.

Urbit is designed to govern itself collectively by address space
ownership -- effectively, "proof of stake." Any arbitrary power,
will tend to fracture along these property lines. For instance,
our hot updates are sent through the galaxy hierarchy; in a
development fork, active galaxies would pick upstream sources.
Two implementations of a standard are better than one.

And by fragmenting the galaxy space into 57 separate partitions,
we've created a global property map which is much more likely to
splinter further, than reunite.

In the long run, every galaxy should have a separate owner, who
is a human being rather than a corporation. Combining galaxy
holdings will damage the reputation of both galaxies. The only
reason to merge ownership is to move toward incipient monopoly.
Whether a galaxy admits this openly or denies it dishonestly, its
reputation will suffer.

The technical goal of Urbit is to create a network which, _if it
actually takes over the world_, inevitably becomes decentralized.
Even if Urbit takes over the world, no individual or coherent
organization takes over the world. There is nothing even close
to a single point of failure in a mature, successful Urbit.

This is the goal of all the new "web3" decentralized systems. If
IPFS, Sandstorm or Ethereum takes over the world, nobody takes
over the world. (The same is almost true of the Internet --
though it wouldn't be that surprising if a time traveler from
2116 revealed that ICANN had become a planetary government.)

Urbit, by starting out as a centralized network, just reduces the
technical problem to match the actual goal. Only long-term
decentralization matters.

It's very important that Urbit in 2116 be fully decentralized.
For Urbit in 2016, pretending to be decentralized would be a joke
at best, and a hoax at worst. And of course, no one can DAO us
-- since the property system is still just a central registry.
Among other things, we check it into GitHub. GitHub is not a
blockchain -- but still, good luck with that.

## <a name="sand"></a>Sandstorm/IPFS/Ethereum is way ahead of Urbit.

In general, web3 (next distributed web) solutions don't compete
with each other. They support each other. Concretely, they are
all part of each others' network effect.

IPFS, Sandstorm, Ethereum, and Urbit can all take over the world
at the same time. None of them competes with the others. They
enable each other.

For instance, IPFS and Urbit are both global immutable
namespaces. IPFS is a chord-routed, content-addressed namespace.
Urbit is a direct-routed, identity-addressed namespace. Urbit is
a typed revision-control system; IPFS is a blob store. IPFS
isn't a computer; the work hasn't been done, but Urbit can easily
mount the IPFS namespace and compute functionally against it.

So the better IPFS does, the less Urbit needs to struggle against
its lack of network effect. The better Urbit does, the easier it
is for IPFS to point to a functional language that can actually
use its referential transparency directly. So their relationship
is symbiotic, not competitive at all.

The closest thing to a general-purpose competitor that Urbit has
is Sandstorm. Sandstorm, which by the way rocks, is also a
personal server built around a network protocol.

But Sandstorm and Urbit compete in the way that, on the PC, the
OS and the browser compete. In theory, the OS could solve the
problems that the browser solves; or the browser could be the OS.
In practice, Windows is a great OS to run a browser on.

Similarly, a world in which Sandstorm takes off is an awesome
world for Urbit, because everyone who has a Sandstorm instance
has a great platform for running Urbit on. Urbit on Sandstorm
will be a sort of "double-hulled" personal server, safer and more
friendly than either system alone.

Sandstorm and Urbit have very different approaches to network
identification; Sandstorm uses capabilities, Urbit identity.
Broadly speaking, we believe, capabilities are optimal for
expressive power; but identity is optimal for the UI of the
common case. We'd need to see the Powerbox, Sandstorm's UI, more
fully fleshed out to understand its UI approach better.

## <a name="planet"></a>Urbit doesn't have enough planets for every human

A 32-bit planet is a tool, not a toy. Like a car, it's a device
for a responsible and independent adult. There aren't 4 billion
cars in the world, nor 4 billion independent adults.

If you aren't an independent adult, and you don't need or even
shouldn't have unconditional digital freedom (no one's 8-year-old
daughter needs unconditional digital freedom), a moon from
someone else's planet is fine. (Even most of today's independent
adults don't complain enough about being Facebook's moons.)

And limiting the supply of anything doesn't create a shortage.
It sets a price. Ideally, in the long run, we think a planet
should cost about $10. This could be off by an order of
magnitude either way, and it wouldn't be the end of the world.

If a planet costs $10, that means you paid $10 to get a planet.
A planet with no reputation has a positive reputation, because
someone paid $10 for it and hasn't yet done anything wrong.
Positive default reputation is the single quality that makes a
social network social.

There is always a tradeoff between free speech and free beer.
Urbit will always choose free speech.

## <a name="pwned"></a>Cloud computing is inherently non-private.

_TLDR_: a general-purpose cloud computer is much, much more
private than a special-purpose cloud computer. In general, a
cloud VM is secure against corporations but not governments.
With a global adversary, compute in your closet -- or even on
your body.

One reason we want the decentralized Internet is that we're tired
of giant corporations spying on us. Think about it this way:
Amazon is Netflix's main competitor. And yet, Netflix runs its
whole operation on AWS. Why is Netflix sure that Amazon won't
spy on it?

A general-purpose virtual machine is special from a privacy
standpoint, just because it's commercially realistic to design
terms of service that prevent the host from peeking and poking at
the customer's machine. Crossing this moat is technically
nontrivial and can't possibly happen by any reasonable accident.
No hosting contract could contemplate it.

Whereas when your cloud computer is a special-purpose machine --
just a database row on some corporation's mainframe -- there is
no way these services can promise not to handle your data.
Handling your data is _what they do_. On a special-purpose
server, the concept of privacy is not even defined.

Where even a general-purpose server falls down is where the user
has a sovereign adversary, which can secretly violate explicit or
implicit hosting contracts. Users with a sovereign adversary
must rely only on their own physical security.

However, most users don't have a sovereign adversary. And those
who do maximize their "herd immunity" if they can use the same
protocols as those who don't. Otherwise, the adversary could
simply focus on everyone who uses the secure protocols.

Also, the portability of a cloud server image is critical. Of
course, since Urbit is formally specified, it's trivially
portable. In fact, one strategy against sovereign adversaries
may be continuous rotation between hosts, like an MX missile.

## <a name="code"></a>Urbit will never be able to call any existing code.

_TLDR_: neither will Javascript. And dear Unix, the browser
does not miss interacting with your `$LD_LIBRARY_PATH` at all.

You can't talk to the OS or use system libraries from Javascript.
Therefore, there is no point in having any kind of gateway,
compatibility bridge, native methods, or other interface between
Javascript and C.

When in doubt, remember that Urbit is "the browser for the server
side." It plays by the same general rules. Isolation means
isolation.

## <a name="weird"></a>There's no way Urbit will ever be adopted. It's too weird.

_TLDR_: Urbit adoption is designed to be driven by ordinary end
users. Urbit isn't ready for ordinary end users yet. We're
working on it -- come help.

Right now, Urbit is a developer tool. Or rather, a developer toy
-- since the only thing it's useful for is developing Urbit. It
also could be a much better toy. We're working on that too.

But it's absolutely wrong to think of Urbit being adopted as a
developer tool in the conventional sense. If you think this is
almost impossible, you're right.

If we look at the way most successful platforms are adopted,
they're not adopted for their own virtues. They're adopted
because they're part of a larger solution. It's very hard to
displace a native component of an existing platform. Urbit is
not trying to do this.

C is a better language than Pascal, but it didn't beat Pascal
because it's a better language. C beat Pascal because C was the
native language of Unix, and people wanted to program in Unix.
People don't use Javascript because Javascript is a great
language, but because it's the native language of the browser.
Replacing the native language of a platform may be doable -- but
it's incredibly hard.

Hoon is not competing with C, or even Haskell, as a Unix
programming language. The only reason to program in Hoon is that
it's the native language of Urbit. Urbit is not competing with
node.js or Rails as a Web backend. The only reason to run Urbit
is to run a personal server.

Nock is cool, but it only gets adopted if Hoon gets adopted.
Hoon is cool, but it only gets adopted if Urbit gets adopted.
Urbit only gets adopted if it's useful as a personal server for
human beings -- most of whom won't be Hoon programmers, or
programmers at all.

## <a name="program"></a>Hoon is too weird. No one will be able to program in it.

_TLDR_: Hoon is ridiculously simple. Our documentation and
tooling are just immature.

It's pretty fair to assume that (a) functional programming is
hard and weird, (b) Hoon is weird even for a functional language,
so (c) Hoon must be hard-squared.

Actually, Hoon is weird even for a functional language because
it's an attempt to remove the hardest things about functional
programming: category theory, lazy evaluation, and gratuitous
abstraction. To know a language is to know what the compiler is
doing; all the semantics of the Hoon compiler fit in 2000 lines
of code.

It's too easy for us to wind up living in Isaac Asimov's Trantor,
a world in which everything got invented thousands of years ago
and the idea of new technology is just weird and scary. History
isn't over yet, and nor is technical history.

New things are harder to learn than old things. We ask smart
high-school students to learn calculus. Think about how much
harder it was for Newton and Leibniz to invent calculus, or for
their first students to pick it up. Hoon is nowhere near as hard
as calculus.

Most of the difference is just the collective certainty that our
society conveys to a high-school student that calculus is
learnable. When you're learning Urbit, you don't have this
collective knowledge; so you don't have the confidence that the
problem is solvable. Confidence makes a huge difference.
Moreover, any bug or glitch in the developer experience destroys
this confidence and takes a long time to heal.

Yes, we know: Hoon remains quite hard to learn. Again, we have
no reason to think this problem isn't solvable. Public
enlightenment remains our main priority.

## <a name="stuck"></a>Urbit programmers are stuck with Hoon.

_TLDR_: patience, grasshopper.

There's quite a straightforward way to implement any perfectly
specified language with a reliable interpreter in Hoon. First,
write an interpreter for that language in Hoon. Second, jet that intepreter function with the existing implementation.

It is not clear that Javascript is _quite_ well-defined enough
for this treatment. But Lua probably is.

## <a name="user"></a>Ordinary users will never be able to manage an Urbit server.

_TLDR_: Urbit's technical simplicity has always been designed
to drive human usability. But the polish is the last thing that
goes on. So we can't evaluate this claim right now.

Right now, Urbit is only for geeks. You already need to be able
to wrangle a Unix machine to run it. What's the point?

This Urbit isn't the real Urbit. It's an early milestone on the
way to the real Urbit.

The real Urbit -- for normal human beings -- is a hosted service.
Getting a planet is as easy as signing up for Facebook. Probably
many users will think of it as another web account. They might
not even know it can run more apps than the ones they use.

A deterministic, persistent cloud computer is something different
from a traditional server. Normally when we think of a server in
the cloud, we think of it like a live animal -- a creature that
needs to be cared for, fed, and herded. A file in the cloud is
more like a rock -- you can forget about it for ten years.

An urbit is a general-purpose computer, but it doesn't even have
the concept of a reboot. It upgrades itself. If you don't feed
it any packets for ten years, then turn it back on, it will spend
a day or two upgrading itself, then be back to normal. Maybe
it's something in between a rock and an animal -- a cactus?

Another huge difference versus an Internet server is that we're
confident that Urbit's limited supply of identities will make it
easy to keep abusers off the network. So far, so good -- but of
course, no one abuses a young network.

The bottom line is that managing your urbit has to be as easy as
managing your iPhone. Normally, it consists of deciding what
apps you want to be running, and how much you trust them.
Resources can't be free, so sometimes you have to play memory
police. Humans have shown that they can handle these tasks.

Our '70s OSes and networks, which were great designs in their day
and have matured into excellent industrial tools, give us a
totally misleading impression of how hard it should be to manage
a general-purpose computer. Computing isn't scary or dangerous.
Unix and the Internet are scary and dangerous. That's fine for
an industrial tool, but not a personal tool.

## <a name="killer"></a>Urbit has no killer app.

_TLDR_: the killer app is personal API aggregation.

It's a truism that any new platform has to be fundamentally much
better at solving some problem than the mature platform it seeks
to replace.

We can look at Urbit's killer app from two perspectives: as a
developer, and as a user.

From the developer's perspective, Urbit's advantage is that it's
a network stack which provides exactly-once delivery of typed,
validated, transactional, encrypted and authenticated messages.
The difference between an Urbit API and a REST API is like the
difference between a paved road and a dirt road. On the other
hand, you do need to learn a new functional language.

From the user's perspective, there's one task that any personal
server can perform, that can't be performed by any Web service:
unrestricted API aggregation.

Well before Urbit is ready to _replace_ any conventional web
services, it should be ready to _command_ them in place by API.
(Or if needed, by scraping.) If all you care about is being in
control of your own data, it's fine to leave it in the hands of
these services, as you have the API secrets to get it out.

Managing a set of security connections to your existing services
is one of the first important tasks of a modern personal server.
This is a stateful task that typically requires both a durable
API key and a temporary OAuth token. APIs change all the time,
so connection maintenance also requires evergreen updates.

The origin of this API key will vary, but usually the best way to
set it is BYOK: the user registers their own urbit as an "app."
And the neat thing about having your own API keys, for multiple
services, on a single general-purpose computer, is that none of
these services really has any practical way to control what you
do with your own data.

Terms of service which constrain the use of data (as opposed to
the abuse of the service) simply aren't realistic and will no
longer apply. This enables a variety of novel user experiences
which aren't implementable as traditional web services, and also
aren't available via conventional third-party API aggregators.

Also, since Urbit is after all quite immature, it doesn't make
much sense to restrict this security state to code within Urbit.
The Urbit interpreter `vere` runs as a Unix daemon that
implements the FUSE user-level filesystem protocol, and maps the
data on your services into the Unix filesystem. For example, one
of our demos lets you `ls` your GitHub issues.

So it's straightforward to build, for instance, a Python app that
uses Urbit as a gateway to mash up a bunch of web services. As a
Unix programmer, you might even just regard Urbit as a generic
Web API gateway daemon, without worrying about its internals.

We have other ideas for initial killer apps. But this, we feel,
is the best one. API libraries for `npm` et al abound.
Stateful, self-updating, generic API aggregators with FUSE
integration, also integrated with a reactive web server, are
rarer.

## <a name="horse"></a> Urbit is sniffed at by Houyhnhyms.

It's difficult to categorize [this awesome
essay](http://ngnghm.github.io/blog/2016/06/11/chapter-10-houyhnhnms-vs-martians/)
in a single bullet point. So I've saved it for last.

When reading this essay, it's important not to forget the amazing
absence of genuine, mutually critical discourse in computer
science (as in most sciences today). You never hear what Swift's
designers think of Go, or vice versa. And critical public
discourse decreases, not increases, with increasing academic
legitimacy.

The basic test of any field purportedly scientific in nature is
whether its researchers are genuinely interested in each others'
work, and willing to share these genuine responses publicly. If
this practice does not exist, the field may still be useful
and/or interesting. But it is not science.

What's awesome about Fare's essay is that he's _doing it right_.
All the actual details are irrelevant. And mostly wrong. But
that's of very little importance compared to _doing it right_.

Anyway, we've already addressed the idea that jets are a sham.
Some other points:

### Event-sourcing and/or caching is a pattern, not a layer

Fare' is perfectly right that "one size does not fit all" in
persistence. Generally, Urbit uses event-sourced persistence.

But it has multiple layers of event-sourcing: in the definition
of Urbit itself; in the application sandbox vane (Gall), and in
the application itself. Urbit also has a completely orthogonal
revision control system (Clay).

And there is not a single cache across the whole system, though
arguably there should be; for instance, the functional build
system (Ford, which Fare' the master of build systems might
appreciate) has its own internal cache.

It is a common mistake to confuse a design pattern with a layer
or feature, and equally fatal whichever direction you fail.

### Let's be clear about why DSLs suck

DSLs suck not because they are difficult to newbies in the base
language. DSLs suck because every time a programmer, even one
_experienced_ in the base language, comes into a new codebase or
project, she has to learn a new custom language.

You need enormous wins to justify this cost. It's the goal of
the base language designer to preempt these wins, creating a
language which is almost never so tiresome and full of
boilerplate that it requires a DSL or template layer.

Hoon is almost entirely made of macros -- but they are internal,
fixed, built-in macros (with no gensyms). This fixed set of
macros is essentially enough. Occasionally we want to add one or
two. But we never, ever pine for context-dependent macros.

### Determinism is not consensus, and is not constraining

Fare' is totally right that an urbit's data is meant for itself
alone. In fact, an urbit has the right to compute incorrectly if
it wants. We go to considerable lengths to ensure that you can't
gain any particular advantage by incorrect computing.

The whole point of Nock is that it's so low-level that there is
no conceivable advantage in upgrading it. Divergence is just
pointless. This is not a question of network integrity, just of
practical standardization.

This consistency stops at Nock. Without anyone violating the
correctness of their lifecycle functions, anyone or everyone in
Urbit could replace Hoon with Javascript. Determinism does not
cramp Urbit's semantic style in any way, shape or form.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The DAO as a Lesson in Decentralized Governance]]></title>
            <link>https://urbit.org/blog/the-dao-as-a-lesson-in-decentralized-governance</link>
            <guid>https://urbit.org/blog/the-dao-as-a-lesson-in-decentralized-governance</guid>
            <pubDate>Thu, 23 Jun 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
What's the right lesson for the decentralization community to
learn from the collapse of the DAO?

Perhaps the simplest lesson is that even decentralized networks
need governments, and have governments. Every network is a
state. Every state has a government.

## Decentralization theater considered harmful

In Dijkstra's terms: decentralization theater [considered harmful](https://en.wikipedia.org/wiki/Considered_harmful).

_Decentralization theater_ means any system that produces not
decentralization, but the appearance of decentralization.
[Security
theater](https://en.wikipedia.org/wiki/Security_theater) is the enemy of real security; decentralization
theater is the enemy of real decentralization.

A network without decentralization theater is one that admits:

- any network is a digital state with a central government.
- any new state is born at war with full emergency powers.
- limiting and/or eliminating governance is a slow, hard task.

TLDR: true decentralization isn't just a technical problem. It's
also a political problem, and not an easy one. Believing you've
solved it, before actually solving it, is not a way to solve it.

## Decentralization and legitimacy

Steve Randy Waldman is not alone in pointing out that [a
blockchain is a
parliament](http://www.interfluidity.com/v2/6581.html). It's
just the technical reality that a majority of miners in a
proof-of-work blockchain, or stakeholders under proof of stake,
have the mathematical power to govern the network absolutely.

But this power does not give them the legitimate authority to do
whatever they want. Mathematically, the Ethereum miners can
easily roll back the DAO. Do they have the _right_ to roll back
the DAO? As we write, this question is one much debated.

We have an easy answer: no. The most basic principle of law is
that _pacta sunt servanda_, agreements must be respected. A good
clue is that before the DAO hack, everyone swore great oaths to
"the steadfast iron will of immutable code." Methinks the lady
did protest too much. But these oaths make rolling back the DAO
blatantly illegitimate.

From a governance perspective, the line of lawlessness isn't the
line between soft and hard forks. It's any fork which makes an
exception for a specific address. Ethereum has already done this
by freezing the DAO contract. At this point, it might as well be
hanged for an ox, and go through with the full rollback.

## Illegitimacy and belligerency

Within the ethos of Ethereum (we are obviously not qualified to
comment on "real" law), a rollback is a _lawless act_. This does
not make it a wrongful act. It simply cannot be judged as an act
of law. Rather, it is an act of war.

And judged as an act of war, a DAO rollback is _exactly right_.
Ethereum is not dealing with a "participant." It is dealing with
a pirate, a thief, _hostis humani generis_.

As a state at war with an external enemy, the Ethereum network
shouldn't just zero the DAO hacker's booty. It must do all it
can to destroy her. If possible, it must dox and report her.
The right place for this fool is the supermax, not the Riviera.

But does Ethereum really want to be at war? And if Ethereum is
at war -- and this certainly isn't the only pirate in the sea --
how does it become decentralized? If Ethereum is at war, where
there is no law, how can it achieve its goal of creating a world
where code is law?

But we really shouldn't panic. It is actually possible to go
from wartime government to peacetime government, from absolute
martial law to absolute rule of law. It is just nontrivial.
It's a political engineering problem that can't be ignored.
If it has to be solved, it should be solved properly.

What really doesn't work is to declare martial law, execute all
traitors, terrorists and enemies of the state, then declare that
elections will proceed as scheduled next week. If the goal is
the decentralized rule of code as law, a rollback takes an
enormous step backward. Reversing this setback isn't trivial.

Should Ethereum actually go to war? Or should it just let the
hacker win? Clearly, from a pure blockchain perspective, the
only correct thing to do is let the DAO burn -- as a painful
warning to all future contract authors and participants.

At present, it seems that Ethereum's leadership has chosen war.
Certainly, neither choice is obviously imprudent. Ethereum is a
winner and probably has a bright future either way. But who
chooses war needs a plan to win that war, and return to peace.

## Sovereignty is conserved

For a government to even have the power to consider wartime
measures, a government has to exist in the first place.

Again, we can't remind ourselves too often that a blockchain just
puts absolute authority in the hands of the miners. We just
think of this power in terms of the law it's supposed to enforce.
But the two are different -- at least in wartime.

Why is it so hard to eliminate unaccountable power? Who watches
the watchmen? The German legal scholar [Carl
Schmitt](https://en.wikipedia.org/wiki/Carl_Schmitt) defined the
problem well when he wrote: "the sovereign is who decides the
exception."

In the American regime, the Supreme Court is sovereign by
Schmitt's definition. We have a complex system of laws, which
are not formal code but in some ways aspire to be; above it, we
have a judiciary system that can decide arbitrary exceptions to
those laws. Pure rule of law, Schmitt tells us, is always and
everywhere an illusion. We can and should strive to approach
this limit, but it's an infinity that we can't actually reach.

Schmitt's exception principle can be rephrased as "sovereignty is
conserved." There is always someone who answers to nobody. We
cannot eliminate government; the best we can do is tame it.

One way to think of the problem of reducing exceptional force to
zero is to compare it to a simple unstable equilibrium, like a
pencil standing on its point. The pencil on its point needs
almost no force to stay upright. But the farther it deviates
from this orderly, self-sustaining equilibrium, the more energy
must be applied to return it to vertical.

Vitalik seems to have grasped more or less Schmitt's point:
"_Intent is fundamentally complex_... we believe that we value
things like 'fairness', but it's hard to define what fairness
even means."

If we could define fairness, we would have a rule to which there
were no exceptions. We would need no judges, or governments, or
even soldiers. We would need no sovereignty. But since we can't
define fairness -- yet need to enforce some clear vision of
fairness -- sovereignty remains conserved.

## Bitcoin, a blockchain at peace

Bitcoin has done an excellent job of freezing the war power of
its own "parliament." Ironically, mining power in Bitcoin is
quite centralized -- a small number of Chinese mining-pool
managers, who have every opportunity to collude, could roll back
anything. But they never have and they probably never will.

Even if a single pool controlled 51% of Bitcoin mining power,
they'd have no incentive to break the rules -- quite the
converse. We equate physical decentralization with limited
governance, perhaps because we think of the physical difficulty
of coordination as the main protection against arbitrary power.

Bitcoin shows that this isn't true. As far as we can tell,
Bitcoin would keep working fine if there was only one miner.
This uni-miner would have still have no incentive to corrupt the
network -- though another party, such as a real government, might
have an incentive to coerce the miner.

The important success of Bitcoin is the collective acceptance --
mathematically false, but politically true -- that rollbacks in
Bitcoin are inconceivable. Bitcoin has governance problems, but
they're confined to relatively unimportant questions, like the
blocksize debate. "Decentralization" may not be quite the word,
but somehow Bitcoin has achieved limited government. The pencil
is standing on its point. For now.

## Ethereum's dilemma

A rollback creates a scary precedent. It's a sort of military
coup. Just as the miners have the power to rule any blockchain,
the military has the power to rule any country. Do they want it?
The first coup makes the next coup much easier. Same with the
first rollback.

In retrospect, the great mistake here was that Ethereum didn't
know it needed a government, and did its best to pretend it
didn't have one. After a rollback, Ethereum doesn't just have a
government. It has a military dictatorship.

Ethereum and Bitcoin are qualitatively different. Bitcoin has a
simple UI metaphor: cash. Everyone knows how cash works. A
smart contract has its own UI metaphor: law. But as we see,
mechanically administered law, law without judges, is a very
different thing from ordinary human law.

What the DAO shows is that Ethereum just wasn't ready to be
decentralized. It was not ready to allow a $150 million contract
with no supervision or appeals process. The problem was not
Ethereum's code per se -- although Solidity doesn't seem terribly
well designed for preventing these pitfalls -- but the human
understanding of its capabilities and limits.

A rollback acknowledges this. It acknowledges that Ethereum
wasn't ready for complete self-government, and _someone_ needed
to have stopped the DAO from trading. It's not quite clear what
the principle behind the rollback was.

Perhaps the best kind of DAO rollback would be a rollback which
understood this error fully, and acknowledged that -- for the
moment -- Ethereum needs a sovereign government, with the power
to restrict and/or steward contracts.

Contracts are not payments. They are infinitely more complex.
They will keep blowing up. Ethereum is full of buggy contracts,
scammy contracts, ponzis and casinos, etc. A governed Ethereum,
in the present state of the technology, might well choose to vet
all contracts centrally _before_ they started trading.

Would this be a permanent feature? Certainly not -- it would be
a way for the community to collectively define a good contract.
Once we know what a responsible, well-tested, non-scammy Ethereum
contract looks like, it's much easier to return to the principle
of _caveat emptor_ and let good contracts outcompete bad ones.

But after the DAO hack, how does anyone trust any contract?
Arguably, Ethereum is ready to be decentralized only when users
are able to make this decision rationally, and get it right.
This work simply hasn't been done.

Perhaps the worst-case scenario is one in which Ethereum approves
the hard fork, on the "just this once" principle. To save the
country, we need a military coup. But don't panic! "After
executing all traitors and enemies of the people, the generals
will immediately restore democracy and the rule of law."

The "just this once" fork takes us back to decentralization
theater, where Ethereum pretends not to have a government. But
now, this pretense is even more threadbare. The next hack, which
will certainly happen, will produce yet another coup -- or at
least a food fight over whether to have a coup. This is the path
to a "digital banana republic," where the tattered illusion of
law barely conceals the real law of nature.

The bottom line is that if a rollback happens once, we can expect
it to happen again. This time, the rollback can be treated as an
act of war, and no process is necessary. Next time, there needs
to be a process -- or the dream of code as law will drift further
away.

Having a central government isn't inconsistent with the ultimate
objective of eliminating central government. Certainly, before
Ethereum was released, its developers were its government. Every
government is born in a state of chaos and war.

The mistake is just in thinking something as complex as Ethereum
can jump directly to decentralization in a single step. The
pencil is not standing on its point, or anywhere close. Before
anyone can think about letting go, someone needs to actually lift
it. To reach law, first enforce peace.

## Constitutional structure

One of the governance problems of blockchains, related to the
fundamental error of decentralization theater, is the failure to
build deliberative institutions on top of the "parliament of
miners." Voting by proof of work is great, especially if the
majority is well above 51%, and can demonstrate its strength
without an actual hashing race. It's a good way to finalize
decisions. But not a good way to make them.

But blockchain governance would be considerably improved if the
miners actually had a formal way to delegate their power to a
structured institution that represented them. Both Bitcoin and
Ethereum have foundations and/or core teams, but authority in
these institutions isn't tied in any way to actual mining power.
Informal politics fills this void with personality cults and
eloquent blogposts, all hoping to create collective agreement
among the actual voting miners.

History shows this is not a great way to run a railroad.
Misalignment between a fundamental power, like the miners, and a
group purporting to represent them, like the foundations, is
inherently dangerous.

What's the alternative? An actual constitution. Perhaps the
first smart contract that Ethereum needs is not the DAO, not even
well-engineered, high-quality smart contracts like Augur and
Maker, but just its own equivalent of 1789. If Ethereum needs a
government, it must govern itself. It certainly has all the
technical tools it needs!

Or, of course, it could just let the hackers win. This is the
easiest path. And in the end, it may still be the best. War,
who needs it?

## A quick Urbit plug

Technically, Urbit needs governance much more than Ethereum.
Decentralization remains our goal -- but it's a long-term goal.
Decentralization theater has never even been a temptation. It's
just technically impossible.

For example, until the Urbit OS and language (Arvo and Hoon) are
frozen and perfect -- which, unlike Nock, will take a while --
Urbit is still "evergreen" -- it still needs automatic hotpatches
from the network.

Whatever institution signs these updates is, by any standard, an
absolute government. It's as if the Ethereum Foundation could
push a hardfork of all clients by signing the new code on the
blockchain. Getting out of this situation is a long-term goal --
where "long term" means years. Decentralization is hard.

Read our [interim
constitution](http://urbit.org/essays/interim-constitution) and our
[beliefs and principles](http://urbit.org//essays/beliefs-and-principles).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Interim Constitution]]></title>
            <link>https://urbit.org/blog/interim-constitution</link>
            <guid>https://urbit.org/blog/interim-constitution</guid>
            <pubDate>Sun, 15 May 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/interim-constitution.jpg)

## Declaration of purpose

Urbit is a new network created by the Tlon Corporation. Tlon's
broad intention is to surrender governance of Urbit to its users,
as soon as the community is collectively ready to receive it.

This constitution (which is not a legal contract, just our present
intent, which may be updated arbitrarily) describes our governance
process during this interim period. Its design borrows from validated
historical structures, mainly Roman and Anglo-American.

The last and most important task of the interim government is to
write the next version of the constitution. This document may or
may not incorporate any or all of the interim structures.

## Beliefs and principles

See our document of [beliefs and principles](/blog/beliefs-and-principles).

## Governance structures

The interim republic has four branches: an executive consulate, a
galactic senate, a stellar congress and a planetary assembly.

For the interim, full authority is held by the (Roman style)
consulate. The legislature (senate, congress, assembly) is
advisory. The senate is never consulted and the congress is
almost never consulted.

In the future, the assembly of planets specializes in technical
governance. The congress of stars specializes in internal, but
nontechnical, governance. The senate of galaxies selects the
consuls and holds them accountable, and specializes in compliance
with external powers. All votes, elections and other public
actions are logged in the Urbit global namespace.

As in most parliamentary systems, each of these structures sets
and enforces its own internal rules of operation.

### Consulate

A consulate is a two-person executive. The consuls must work out
their own organization and division of labor. Disagreements
between consuls are resolved by the senate.

A consul must be a senator. The senate, voting per galaxy,
replaces the consulate whenever either a vacancy exists, or a
vote of no confidence gains a majority. When electing consuls,
first a plurality selects one consul; then the plurality of those
who voted for anyone but the winner selects the second.

### Senate

The _senate_ is the set of all galaxy holders, voting per galaxy.
It does not convene except to replace the consuls. Its
proceedings are in private.

To avoid growing the network too quickly, galaxies are activated
gradually. Initially, only one galaxy is active, the root `~zod`
(galaxy 0).

Further activation is at the discretion of the consuls, who
control `urbit.org` and will only bind activated galaxies to
`galaxy.urbit.org`. Routing at the galaxy layer is by DNS, so
unbound galaxies, and any stars or planets they launch, hear no
packets.

When any galaxy, activated or not, creates its initial
certificate, the consuls add its fingerprint to the galaxy table.
Non-activated galaxies can still be rekeyed.

### Congress

The _congress_ is the set of all active independent stars.
voting per star. An _independent star_ is any star _not_ owned
by anyone who is either a senator, or has some connection to one
that would pose a conflict of interest.

The congress of stars is designed to exercise project and
community governance. Its proceedings are in private. The
consuls convene it at their pleasure, and keep it informed.

### Assembly

The _assembly_ is the set of all active primary planets, voting
per planet. A _primary planet_ is the main planet of a unique
human (no sockpuppets).

The assembly is responsible for technical governance. Its
proceedings are in public.

### The next constitution

The congress proposes, and the senate approves, the next version
of this constitution. Future constitutions should be defined in
a smart contract platform, such as Ethereum.

## Galaxy table

95 galaxies are held by the [Tlon Corporation](https://tlon.io/). 50,
reserved for urbit.org, the future community foundation. 40, by
Tlon employees and their family members (24 by Curtis, who
started in 2002; 16 by everyone else, who started in 2014). 34,
by outside investors in Tlon. 37, by 33 other individuals, who
donated to the project, contributed code or services, won a
contest, or were just at the right place at the right time.

Note that while Tlon and its employees still control a majority
of galaxies, the senate is a ceremonial body; the consulate is
effectively equivalent to Tlon.

## Inception

This constitution takes effect as soon as the initial public
presale of Urbit address space is complete.

## Endowment

The 50 galaxies marked "urbit.org" in the galaxy table are
intended as property of the republic, and will be used only in
the interests of the republic and Urbit as a whole.

Externally, these galaxies are held by Tlon; internally, they are
managed and voted by Tlon. Once the republic acquires a legal
identity and an independent human organization, Tlon pledges to
donate the `urbit.org` galaxies, the DNS domain, and the GitHub
`urbit` account to it.

## First consuls

The first consuls are Galen Wolfe-Pauly and Raymond Pasco.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Magic]]></title>
            <link>https://urbit.org/blog/magic</link>
            <guid>https://urbit.org/blog/magic</guid>
            <pubDate>Sun, 15 May 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/magic.jpg)

It's easy to get too obsessed with Urbit's alien technology. We
didn't build Urbit for its tech. We built it for people to use.

It's also hard to understand the power of Urbit, because it's
still quite immature. Unless you understand it already, it's
just a weird OS that doesn't work all that well.

And this OS is supposedly designed as a new kind of product: a
personal server. What is a personal server? If you had one,
you'd know. Since you don't, you don't. So both your problem
and our solution are totally unclear.

One way to understand Urbit is to forget the technology totally.
Instead, let's build the same product out of magic. Technology
is hard and imperfect and slow. Magic is easy and perfect and
fast. Why not use it? At least for a demo?

## Magic step one: total integration.

Make a list of all the cloud apps which have your personal data.
OK, just imagine making a list. OK, use magic.

By magic, we make some giant company buy all these apps. It
could be any of them, but let's say it's Facebook. Facebook buys
_all the apps_. As of now, _all your cloud computing happens in
your Facebook profile_.

Your Facebook is now your Dropbox and your Evernote and your
Wordpress and your Gmail. And it's not just Web apps; all your
servers move to Facebook. Your Nest talks to a Facebook server.
Your iPhone talks to Facebook instead of iCloud. Your Fitbit
records your heart rate in a Facebook log. Your Facebook
manages your finances and pays your bills. Got bitcoin?
Facebook is your wallet. Shop online? Check out the Facebook
Store -- it sells everything!

In short, you can just lock your browser to `facebook.com`. The
Web is dead. Or more precisely, it's an obsolete protocol which
you use to log in to Facebook.

Does this sound creepy? Sure. It's incredibly creepy. But look
on the bright side: it's also incredibly convenient. (And
incredibly secure, at least with a 2-factor key.)

For the first time ever, _all your data is in one place_. For
example, the engineers at Facebook, who are awesome, would never
leave Dropbox, Instagram and iCloud as three separate things.
You don't need an "integration" between them. Your profile is
one thing: you. Your entire digital life.

(In fact, if you're a geek and have Unix boxes, your Facebook is
magically integrated with Unix. You can just open your laptop
and type `ls /photos/2016/May/` -- as if your digital life was a
chip in a box in your backpack, not redundant servers in multiple
secure data centers.)

Imagine we all lived in hotels, all the time, even in just one
city. Imagine you don't even have one room with a long-term
lease. You sleep in one pod Mondays, another on Tuesdays...
then, someone offers you a home. Your own house. With your own
furniture, your own books in your own bookcases...

## Magic step two: free your data.

The good news is, you get your own house. The bad news is, it's
in North Korea.

Having your whole life owned by Facebook is still creepy. Or so
most people would think. It's not actually clear that it's more
creepy to be owned by one corporation, than nine corporations.
But it _feels_ creepier.

By magic, Facebook cares. So it decides to free you. Actually,
Facebook's business is owning you. So freedom will destroy its
business. But magically, Facebook doesn't mind.

Right now, the software behind your Facebook experience is a
million lines of Facebook goo. It solves your problems and shows
your ads and does whatever the heck it wants with your data.
(Not that it's "your" data. It's Facebook's data, about you.)

Without changing the functionality of your Facebook experience,
Facebook replaces every component of this goo with an "agent."
(You have about as many agents as you used to have apps.) If you
don't care about being free, you won't notice the change. If you
do care, everything changes.

One, you don't have to run Facebook's agents. You can replace
them with anyone else's software, free or paid. Agents upgrade
themselves automatically, but you are never locked in; you can
always switch agents and/or vendors without damaging your data.

Don't like your email UI? Change it. Don't like to see ads?
You no longer see any ads -- why would someone use an agent that
showed them ads? Ick. Unless it's something ridiculously
specialized, an agent is either free software or costs $3.99.

Two, agents _act as you_. Facebook is no longer the Panopticon.
It is not a giant mainframe where all the code can access all the
data. An agent can use as much of your own data as you give it;
it cannot use anyone else's data. At least not without asking.

When anyone can write an agent, only code can be law. Privacy is
no longer enforced by the informal decisions of Facebook product
managers. It must be enforced by formal security policies.

This might constrict the services Facebook can offer, but only a
little. Since privacy is a human universal, apps that don't
respect it (for instance, image face tagging) feel weird. A
service like this can't be broken up into personal agents; it
still requires a Big Data mainframe somewhere. But it's okay;
the agents can still talk to it.

For the most part, Big Data (everyone's) has become little data
(yours). You no longer have a Facebook profile -- a fancy UI
backed by a million lines of Facebook goo on one big mainframe.
Now what you have is a Facebook _server_: a real computer. Or at
least, a virtual computer (which is much more reliable than any
one physical computer).

Is this computer hard to manage? You have the same basic job as
someone who owns an iPhone: deciding what software to run. If
you skip this job, your iPhone or your Facebook is still pretty
useful. You also need to decide what data to keep. An iPhone
has finite, free storage; the cloud has infinite, non-free
storage. You still want a warning when your server gets fat.
But at least it keeps working.

## Magic step three: free your server.

This agent-oriented Facebook can't show you ads. But this is not
actually a huge business problem. Since Facebook owns everyone's
life, it has the mother of all monopoly lockins. It can just
bill you $9.99 a month for running your Facebook server. This is
a great deal, for you and for Facebook.

But you're still a slave, Neo. A Facebook server still isn't a
personal server. Monopolies suck.

Magic works, so Facebook feels guilty. It goes all the way
toward freeing you, and ruins its own business.

Now, your server is just a big file whose format is precisely
defined. You can move it to any hosting service, or even run it
on a home PC. Since hosting is now a commodity, it costs almost
nothing and has zero profit margin. It may even come bundled
with your Internet service.

Every data center is owned by the local government. If you have
data to hide from the authorities, compute at home. Most people
don't have anything to hide and should run in the cloud, because
the cloud works better. But using the _same platform_ as those
who do have something to hide creates "herd immunity". You don't
have to choose between a secure platform with no network effect,
and a non-secure platform that everyone else uses.

## Magic step four: free your name.

Freeing your server also means freeing your identity. It's no
longer true that Facebook decides who you are. Facebook just
wrote the algorithm. Your server contains cryptographic secrets
that control your identity. If your identity was a bitcoin, your
server would be a giant bitcoin wallet.

The bad news: lose the file, lose the identity. The good news:
your server is genuinely personal now. It's yours in every way.
It's so personal that if you destroy it, it's gone.

Facebook doesn't even keep its power to create new servers. The
"real name" policy has done great things to control spam, because
spam always depends on disposable accounts. But it implies a
central authority.

Instead, Facebook borrows an idea from bitcoin and just limits
the number of identities. If you need one, you have to buy one.
They don't cost that much; just enough to deter spammers.

(Is your real name still linked to your identity? Maybe, maybe
not. There's a role for name validation, but not everyone needs
to have a real name, and not everyone else needs to know it. A
dissident, or anyone who wants to speak out and let the words
speak for themselves, might want a second anonymous identity.
But sock puppets remain evil -- two names for the same person
should not interact in the same place.)

## Magic step five: call it Urbit.

And, with magic, we've succeeded in turning Facebook into Urbit.
Technically, Urbit is pretty close to magic, but there is no way
it's going to happen this way. See the [roadmap](/blog/roadmap) for how it
actually happens.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Urbit Address Space]]></title>
            <link>https://urbit.org/blog/the-urbit-address-space</link>
            <guid>https://urbit.org/blog/the-urbit-address-space</guid>
            <pubDate>Sun, 15 May 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/the-urbit-address-space.jpg)

## Basics

Urbit contains a lot of new technology. As an ordinary user, all you
need to understand is Urbit's identity model. If you're in a hurry,
just read these simplified basics.

An Urbit identity, or "ship," is a string like `~firbyr-napbes`. It
means nothing, but it's easy to remember and say out loud.
`~firbyr-napbes` is actually just a 32-bit number, like an IP address,
that we turn into a human-memorable string.

Technically, a ship is a secure digital identity that you own and
control with a cryptographic key, like a Bitcoin wallet. As in
Bitcoin, the supply of ships is mathematically limited. This keeps
the network friendly, by making spam and abuse expensive.

A ship name is just a number; smaller numbers make shorter names.
Shorter names are easier to remember, so they're more valuable. So
ships are classified by the number of bits in their name. (A ship
name is just a scrambled base-256 representation of the number.)

A 32-bit ship (like `~firbyr-napbes`) is called a "planet." A 16-bit
ship (like `~pollev)` is a "star." An 8-bit ship (like `~mun`) is a
"galaxy." A planet is an identity for an independent, adult human.
Stars and galaxies are network infrastructure.

Each planet or star is launched by its "parent," the star or galaxy
whose number is its bottom half. So the planet `~firbyr-napbes`,
`0xdead.beef` or `3.735.928.559`, is the child of `~pollev`, `0xbeef`
or `48.879`, whose parent is `~mun`, `0xef`, `239`. The parent of
`~mun` and all galaxies is `~zod`, `0`.

If Bitcoin is money, Urbit is land. Much as all real-estate titles in
England trace back to William the Conqueror, all certificates in Urbit
trace back to `~zod`.

But this universe is worthless unless dispersed. It's already quite
well fragmented. And as it grows distributed, it grows decentralized.
The endpoint is a virtual city of 4 billion (`2^32`) citizens, all
owners of their own independent digital identities. The stars and
galaxies continue as a federated governance and service network.

This city is a social network, a peer-to-peer packet network, and a
public-key infrastructure (PKI). In the social layer, your ship is
your name. In the packet layer, your ship is your network address.
In the PKI, your ship is your cryptographic identity. Perhaps more
intuitively, a ship is a sort of pronounceable phone number.

And once Urbit is built, no one owns the city. No one can control it.
It does need governance; but it governs itself as a digital republic.

## Details

As an Urbit user, these basics are all you need to know. As a
developer, a few more details might interest you. (An even more
comprehensive treatment is in the [whitepaper](https://media.urbit.org/whitepaper.pdf)).

### Design goals

An identity system has three goals: a name wants to be secure,
human-meaningful, and decentralized. A principle called "Zooko's
triangle" says that a practical identity system can achieve any two of
these goals.

The art of OS design is the art of using strategic tradeoffs to almost
solve unsolvable problems. Urbit's goals are to be secure,
human-_memorable_, and _eventually_ decentralized. We sacrifice
meaning (Urbit is not competing with the DNS), and postpone
decentralization. These tradeoffs buy us a simple system that can
actually be built.

### Comparison to existing identity layers

The Internet doesn't have anything like Urbit ships, so you may need
to stretch your brain a little here.

There are three levels of naming on the Internet: raw, numeric IP
addresses (like `126.78.92.112`), domain names (like
`foobar.com`), and user identities (like `galen@tlon.io` or
`@galenwp`).

Urbit (or more precisely, its Ames protocol) squeezes all three layers
into one. At the network level, Urbit is a P2P overlay network; your
ship is your network address. It's also the name of your server.
Finally, it's your secure digital pseudonym. And we map your ship
name into the DNS, at `ship.urbit.org`.

(One way to use Urbit is as an identity for the Internet, which
doesn't have a standard system of secure authentication. Urbit has a
single-signon API which lets any Web server accept Urbit logins, like
a normal social login -- but not captive to any central mainframe.)

### Cryptographic ownership

You own an Urbit ship cryptographically, like a Bitcoin wallet. But
Urbit doesn't use a blockchain or mining.

You transfer a ship by signing a new public key with the old private
key, then broadcasting the signature. Any urbit that receives this
new certificate will no longer trust the old key.

Urbit is digital land, not digital money. A currency needs to support
high-frequency, zero-friction transfers. Real estate transfers are
low frequency and high friction, so the "double spend" problem (which
mining solves) is much less pressing.

Don't expect urbits to be tradeable on cryptocurrency exchanges. A
trade adds at least one signature to the ship's certificate, or two if
the parties don't trust each other and an intermediary is needed. A
bulky certificate isn't free, since it slows down new connections.

This isn't a serious problem if urbits are treated like land. But it
prevents Urbit from being a competent currency. This is a feature,
not a bug. Urbit has no need to compete with Bitcoin or Ethereum,
and every reason not to.

## Moons and comets

In the general case, a ship is actually a 128-bit number. A full
table of ship classes:

```
8 bits    galaxy  router  ~syd
16 bits   star    router  ~delsym
32 bits   planet  human   ~mighex-forfem
64 bits   moon    device  ~dabnev-nisseb-nomlec-sormug
128 bits  comet   bot     ~satnet-rinsyr-silsec-navhut--bacnec-todmeb-harwen-fabtev
```

Moons are for clients and connected devices: a laptop, a phone, a
digital thermostat. A moon is not independent; its parent planet has
to sign its key updates. (We don't want rogue clients floating
randomly around the universe.)

A comet's address is the hash of its initial public key. Anyone can
launch a comet. Nothing stops you from using a comet as your
identity, except that the name is a mouthful and everyone will assume
you're a bot.

### Scarcity, reputation, friendliness and trust

A crucial difference between Urbit and other networks is that planets
are scarce. Even when the network is fully populated, there are only
4 billion. Early in Urbit's life, most stars and galaxies are not yet
operating, so far fewer are available. No one will ever be able to
get planets trivially and for free.

Urbit is a _friendly network_: a network on which you can assume that
a stranger is nice until proven nasty. Friendliness is a direct
consequence of scarce, individually owned identities. We're not
changing human nature, just creating the right economic incentives.

Most forms of network abuse are "Sybil attacks": they rely on an
infinite supply of fresh identities. Scarcity makes reputation work.
Spam is a business; if the cost of a new planet exceeds the amount of
money you can make by spamming from that planet until its reputation
is trashed, there will be no spam.

Shady stars and galaxies that sell blocks of planets to spammers will
also develop reputations as "bad neighborhoods," damaging the value of
the whole block. Abuse at any level is designed to be
counterproductive and economically self-terminating.

Urbit has no reputation system at all at the moment, simply because
we're so small that friendliness is automatic. The clear and rigorous
structure of the address space is not a reputation system; it is a
platform on which any number of such systems can and should be built.
But we can't build one until we need one.

### Initial allocation and rationale

In cryptocurrency terms, Urbit is "100% premined." Why? Three
reasons.

One, Urbit doesn't need mining. Two, Urbit is a much more ambitious
software project than Bitcoin or even Ethereum. To fund its own
development, the project needs to capture the potential value of its
own real estate.

Three, most theories of property agree that anyone whoever creates or
discovers new property starts out by owning it. Because galaxies are
premined, Urbit starts as a centralized system. But it has two strong
motivations to decentralize.

One, the more decentralized Urbit is, the more Urbit is worth. Two,
the only way for Urbit to fund its own development is to homestead its
own real estate.

Urbit was created by Curtis Yarvin, who has distributed the 256
galaxies as follows (allocation as of June 1, 2016):

95, to the [Tlon Corporation](/blog/company). 50, to urbit.org, the future
community foundation. 40, to Tlon employees and their family members
(24 to Curtis, who started in 2002; 16 to everyone else, who started
in 2014). 34, to outside investors in Tlon. 37, to 33 other
individuals, who donated to the project, contributed code or services,
won a contest, or were just in the right place at the right time.

What's critical is that the whole system is unlikely to collapse back
into a single landlord. This is why we've intentionally scattered
Urbit's ownership across a diverse set of entities.

Furthermore, we've defined informal conventions designed to motivate a
healthy ownership structure by punishing violators with reputation
cost. Address blocks should only split, never merge; galaxies and
stars should be owned by different parties; galaxies should be owned
by true individuals, not corporations. Urbit does not live up to
these ideals at present, but must always progress toward them.

### Federated services, adoption and escape

Urbit is a peer-to-peer network. Urbits that live behind a firewall
or on a home network need "supernodes" to help them route packets.
The supernode is the parent. So a parent's work isn't done once it's
launched all its children.

There's no way to enforce this responsibility. So a star or planet
can be _adopted_ by a new parent of the same class, letting it escape
from a bad default parent. If your parent stops serving you, and no
other parent is willing to adopt you, you're probably a bad actor.

Supernode routing is just one example of why you need a parent. A
mature Urbit will naturally develop all kinds of other _federated
services_ -- from technical standardization and update approval, to
certificate update broadcast, to reputation and friend lookup. All
these services are delivered by cooperating stars and galaxies. Bad
actors at this level should be rare.

Especially when Urbit is young, the level of trust that a child places
in its parent is high. The trust implied by automatic kernel updates
is almost infinite. You can disable updates, but that's nowhere near
practical yet. (Ideally we will be able to freeze the Arvo kernel,
like Nock, and turn off kernel updates; but this will take years at
least.)

### Code is law: seeing like a pattern language of great cities

Constitutional innovation is dangerous. Our vision of digital
governance isn't ours, but is synthesized as best we can from the work
of four great 20th-century thinkers: the legal scholar Lawrence
Lessig, the political scientist James C. Scott, the urbanist Jane
Jacobs and the architect Christopher Alexander.

All decentralized computation systems rely to some extent on Lessig's
principle: "code is law." Where law uses human interpretation to
determine an outcome, code uses mathematics. It is code, not law,
that decides who owns a Bitcoin wallet.

But all these systems, including Bitcoin, need governance. They need
as little as possible, but not none. In the digital world as in the
real world, _laissez-faire_ is always necessary, never sufficient.
Governance is a human universal.

That's why we call Urbit a "virtual city." And as a city, it can't be
a corporate gated community. It might start as that, but it has to
grow up into a true city-state: a self-governing digital republic.
This pattern is not just blind clinging to Anglo-American tradition;
like every prudent constitution, it fits the actual virtues and vices
of its target population.

Urbit's galactic hierarchy resembles the natural patterns we find in
many existing human political systems. As Alexander wrote:

> Wherever possible, work toward the evolution of independent regions
> in the world, each with its own natural and geographic boundaries;
> each with its own economy; each one autonomous and self-governing;
> each with a seat in a world government, without the intervening power
> of larger states or countries.

We adapt Alexander's vision to a digital republic as the pattern that
_authority is proportional to property_. This pattern already has a
name in the cryptocurrency community, which calls it _proof of stake_.
Urbit's launch hierarchy is a sort of built-in proof of stake.

Another governance pattern, a political cliche but no less valuable
for it, is the system of checks and balances. The address space of
Urbit is covered by three independent tiers, galaxies, stars and
planets; which should govern? The obvious design is a three-chambered
legislature balanced against itself.

For more on Urbit's governance design, see our [beliefs and
principles](/posts/principles/) and our [interim constitution](/posts/constitution/).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2016.5.16 Urbit Roadmap 2016]]></title>
            <link>https://urbit.org/updates/2016-5-16-roadmap</link>
            <guid>https://urbit.org/updates/2016-5-16-roadmap</guid>
            <pubDate>Sun, 15 May 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
Urbit is in early beta. It works. It doesn't work well enough to be
particularly useful, though it's not that far away.

It's important to understand that the present Hoon codebase was
developed almost entirely by three full-time engineers (Curtis,
Philip, Anton). We are good, but not superhuman.

We have four separate problems to attack in 2016: community, maturity,
utility, and governance.

## Community

Working on Urbit is incredibly fun. We've kind of bogarted that fun.
We're sorry -- no, we're not actually sorry -- but we're going to
change that.

Since 2013, the community status of Urbit has been that it's open
source and you can mess with it if you want, but we don't really do
much to encourage you. Or to put it differently: open source,
secretly wishing it was still stealth.

The sad truth is that we've been doing research, and research doesn't
scale. This is one of the reasons why open-source projects are
notoriously focused on copying proprietary products. Open source is
great for incremental maintenance and development -- almost nothing in
software is as mature as a mature open-source project, because "with
enough eyeballs, all bugs are shallow." But it's terrible for
creative research, because the smallest decisions invite the notorious
"bikeshedding" syndrome.

Now that Urbit does all the things we want it to do, in (pretty much)
the way we want it to do them, our focus is changing. All we really
care about going forward is maturity and traction. Also, it's a lot
harder to argue about what color the bikeshed should be painted, if
the bikeshed is already painted.

So, working on Urbit is incredibly fun. If only because it's the
programmer's equivalent of astrobiology. But not only because --
Urbit is very far from being a mere esoteric curiosity.

The first challenge we face is making sure Urbit is properly
documented. (See below.) We'll also be:

- holding weekly public meetings / office hours
- maintaining public developer blogs
- (probably) running open contests with address-space prizes

## Maturity

At the systems layer, Urbit has enough features for right now. What
it needs is maturity.

Aside from mere bugs and issues, maturity comes in five flavors:
documentation, dogfooding, optimization, security, and testing.

### Documentation

Anyone outside the core team who's done any serious work in Urbit has
earned their scout badge in Reverse Engineering. The number of people
who have done this is impressive, but also slightly embarrassing.
Since Urbit is so technically unusual, we have no excuse for leaving
any part of it undocumented.

Documenting Urbit is not just a matter of writing down specifications
for the code as it exists. That would be easy if the code was
perfect. It's not perfect.

One truism of CS is Knuth's observation that "premature optimization
is the root of all evil." Yes, but premature documentation is at
least the trunk of all evil. "Documenting into existence" -- making
something that doesn't exist exist, by describing it -- is the trap of
all vaporware projects.

On the other hand, Urbit does exist. It doesn't need to be documented
into existence. It does need to be documented into completion. This
doesn't mean simply describing the codebase.

Documenting to completion is a two-way process. It always produces a
nontrivial set of technical revisions. Large design questions are not
open for discussion, but small ones are. This makes documenting to
completion a fun and fascinating community process, which neither
reduces to mere stenography, nor descends into endless bikeshedding.

Nock is completely done, and completely documented. Hoon still has a
few small rough spots; its reference documentation is decent but not
perfect; its tutorial documentation needs more work, but is reasonably
adequate.

The real target of documentation into completion is Arvo (including
the Hoon library). The ideal point at which to prepare stable
documentation is the point Arvo is at now: basically working, but
largely undocumented.

Since Hoon is a programming language for Arvo, not for Unix, Hoon
documentation without Arvo documentation remains mostly useless -- so
we've got a strong incentive to get this done. But not without
actually getting it right.

### Dogfooding

Urbit has no alternative but to dogfood itself into maturity. If the
Urbit team itself doesn't solve some problem with Urbit, who else can
be expected to? Any use of any external tool in the Urbit development
process is a damaging energy leak.

We already use Urbit to publish documents about Urbit, to chat about
Urbit, and of course to deliver Urbit updates. With this release,
we're adding a public chat stream and public comments.

The next dogfooding steps: using GitHub as a backup to Clay, not Clay
as downstream from GitHub; our own internal issue tracker; and
replacing internal email with long-form `:talk` messages.

### Optimization

You'll notice that some aspects of Urbit are slower than you might
expect. This is because of our approach to optimization, which is to
throw some elbow grease at it when it gets annoying.

Death by unsolvable slowness is a common cause of mortality in
language-oriented projects like Urbit. But Urbit actually has two big
advantages in optimization.

First, our profiler is simple, but quite effective, because it's
integrated with the language and runtime at a level usually not found
in profilers. Second, anything that's slow can be jetted; as long as
there's an inner loop, that inner loop is vulnerable to anyone who can
write C. And there's always an inner loop.

### Testing

There is plenty of design work to be done in even figuring out how to
systematically test Urbit.

We've done appallingly little systematic testing. We've mostly relied
on simplicity and elbow grease to get the system to the reliability
level it's at now. `~zod` has been up for a few months and has a 22GB
event log. There's no reason to think that if we replayed that log,
we'd end up with any different bits.

Simplicity buys a lot. Urbit is not always as simple as we want it to
be, though. There are plenty of known bugs; and we're nowhere ready
to declare Urbit ready for mission-critical data.

### Security

Urbit is not yet secure at all. We don't even think it's secure. And
this is just the first step in making it secure. After that comes an
independent audit and penetration testing.

## Utility

However much we want Urbit to succeed because we're geeks and love
functional programming, it can only go somewhere by being useful -- to
people who don't care about the technology. Moreover, even for geeks,
the amount of fun in working on something that's permanently un-useful
is quite limited.

What is Urbit? Urbit is a general-purpose personal server whose
long-term goal is to replace the whole web-service ecosystem. The
long term takes a long time by definition and is always preceded by
the short term.

Fortunately, Urbit isn't that far from being useful in the short term.
Three directions we're pushing in: APIs, publishing, and distributed
chat. Urbit is a general-purpose system, of course, and it's very
hard for us to know what "killer app" will catch on first. It might
not even be any of these.

### API aggregation

It takes a long time to replace Facebook -- or any other mature Web
service. But most of these services have APIs. Early in its life,
your general-purpose personal server puts most of its energy into
controlling special-purpose personal servers.

The use case seems a little trivial, but Urbit is actually a great API
client. An API client is stateful; it has keys and tokens to manage.
And APIs are notoriously unstable, which requires over-the-air
hotpatches, which Urbit is quite good at.

Also, having your own personal API token on your own personal server
is enormously empowering. Most services make it quite easy to
register yourself as an "app." Unlike a third-party startup, this "me
app" doesn't have to obey any TOS constraints on user experience.

For example, if you build an API-driven web service that shows an
integrated Facebook and Twitter feed, your API key will be revoked.
If you write an Urbit app that delivers the same experience, so long
as users bring their own API keys ("BYOK"), nothing bad will happen.
It's good for adoption when Urbit can present a user experience that
nothing else can.

Another area we're focusing on is using Urbit as a shim to put your
Unix box in control of your API-driven services. With Urbit and FUSE,
you can actually mount remote services in your filesystem. Our first
prototypes of this are quite exciting, though they could use some
optimization.

API drivers are also a great area for people to contribute code to
Urbit. There's an almost infinite number of drivers to write, each of
them is slightly different from the others,

### Personal publishing

If you put it behind nginx, Urbit already works quite well as a
personal publishing tool. You can copy a tree of Markdown files into
a directory and have a website or a blog. There's no reason why a
well-cached functional publishing system shouldn't replace a static
site generator.

Key features we need for Urbit publishing: Let's Encrypt support for
people who need their own secure domains, and a DNS server in stars so
that `planet.urbit.org` doesn't have to be proxied.

### Decentralized chat

A lot of people want an encrypted, decentralized, persistent chat
network. Urbit already is this, though its human interface is nowhere
near as refined as a marvelous product like Slack.

Urbit needs chat because it needs to talk about itself. But the most
mature parts of Urbit will always be the ones we dogfood, and chat is
central to this list.

Can Urbit gain traction as a messaging platform alone? It's certainly
conceivable. It's difficult, to put it mildly, to understand what
makes one messaging network more popular than another. Ideally,
someone who cares deeply about decentralized messaging would take this
ball and run with it.

## Governance

See the [interim constitution](/blog/interim-constitution).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[An Urbit Overview]]></title>
            <link>https://urbit.org/blog/an-urbit-overview</link>
            <guid>https://urbit.org/blog/an-urbit-overview</guid>
            <pubDate>Tue, 10 May 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/an-urbit-overview.jpg)

## What Urbit is

Urbit is a virtual city of general-purpose personal servers.

## Your old personal server

What's a personal server? In a sense, you already have one. Your
personal server is the combination of all the cloud services you use
now.

This "server" is a mess. It's broken into 17 different fragments
which are scattered all over the planet. You have no control at all
over any of the pieces. The more we depend on Web services, the more
we realize how unsustainable this situation is.

Can you remember all the services you have accounts for? How about
the username and password for each? Some of them will let you pull
your data out somehow, some won't. Sometimes you can move your data
between them, sometimes you can't. But they're all good at
showing you ads.

## Your new personal server

Your urbit is your own general-purpose server. It holds your
data; runs your apps; wrangles your connected devices; and
defines your secure identity. If you still need your old
services, it drives them with APIs.

Your urbit presents your whole digital life as a single web
service. And since it's yours, open source and patent-free, it
never shows you ads. Or loses your data. Or updates without
your consent.

Technically, Urbit is a new kind of OS that has a precise formal
definition. (Urbit is actually a [single mathematical function](https://media.urbit.org/whitepaper.pdf).) One advantage of a math-based OS is that Urbit is perfectly
portable. It can't tell whether it's in a cloud data center or on
your home PC.

Concerned about mass surveillance? Download your urbit and restart it
on your laptop, or move to a new host in Iceland. Urbit's formal
simplicity makes managing it as easy as managing an iPhone: all you
have to decide is what apps to add.

Each urbit is a node on a global, encrypted P2P network. Your Urbit
name, a generated pseudonym like `~talsur-todres`, is also your
network address. Like Bitcoin, Urbit address space is a cryptographic
asset with a limited supply.

By keeping addresses scarce, we make spam and abuse expensive. Urbit
is a "friendly network," like the Internet in 1986, where a stranger
is nice until proven nasty. As it matures, Urbit will grow into a
decentralized, self-governing virtual city both safe and free.

## The Urbit future

In an Urbit world, your data is no longer trapped in a jumble of
proprietary servers. Your urbit is a permanent, versioned, typed
archive the size of your digital life. Even before you move your data
from a Web service to a local Urbit app, your urbit can drive your
account with an API or scraper.

And within Urbit, data is never locked inside apps. Imagine if you
could painlessly switch between Facebook and Google+, Asana and
Trello, Tumblr and WordPress. Not only does your urbit upgrade itself
and its apps automatically, you can "sidegrade" a running app to
another vendor without losing data.

Your urbit is also your digital identity. Along with your data
lifestream of media, messages and documents, it has the keys and
tokens to manage all your legacy Web services. It holds the keys
for your cryptocurrency wallets, so it can buy and sell for you.
(With one personal server to secure, not 17 different accounts,
you actually have the bandwidth to take security seriously.)

You still use network services. But instead of interacting with
the service provider's HTML UI, which phones home using
proprietary HTTP APIs, you interact with a third-party app on
your urbit, which talks to multiple service providers using
public, typed Urbit protocols. For example, your urbit runs a
single shopping app, which downloads catalogs and uploads orders.
This app is one store which sells everything in the world, with a
salesman who's 100% on your side and always has the best price.
Every computing experience is different when the UI is working
exclusively for the user.

Finally, your urbit is the hub for your network of connected
devices. Your smart thermostat, your wristband, your phone and
tablet, all run satellite urbits which talk securely to your main
urbit in the cloud.

## A chance for digital freedom

The promise of the personal server isn't just convenience.
General-purpose computing is magic. This magic must be in the
hands of all, not just those who can master Unix. The computer
is a bicycle for the mind. It's an open vehicle for exploration
and discovery. It's not a way to optimize ad delivery.

Urbit, as virtual city, is a platform that brings together all our
datastreams -- from emails to heartbeats -- in a way that we ourselves
control. Can we work together to match faces in photos, without
submitting to some panopticon in Mountain View? While the first step
in freedom is the right to be left alone, the second is the power to
form new intentional communities, to create and evolve a voluntary
definition of public space. We have no idea at all what people will
do with this power.

General-purpose computing is digital freedom. And today, a cloud data
center is the technically optimal locus of computation. The cloud is
always on, always available, never loses data. Hosts are sometimes
attacked; but they never intentionally tamper with their virtual
computers. The cloud can never be secure against a global adversary;
but most people don't have a global adversary. A single portable
platform provides "herd immunity" for the few who do need direct
physical control over their main computers.

Though even laptops are atrophying into mere browsers, mass-market,
general-purpose computing on the client side remains an endangered
species that must be protected. But on the server side, this species
has never even _existed_. There has never been anything like a
mass-market personal server. Why not?

## Freedom is an engineering problem

Urbit is not a difficult idea. Urbit is like a flying car: the idea
is not the hard part. Almost everyone we talk to about Urbit turns
out to have had pretty much the same idea themselves. The problem is
building it.

A server is a computer. It's running some operating system. This OS
is a flavor of Unix. There are no alternatives. It's connected to
some network. This network is the Internet. It has no competitors.
You can have a personal server, if it's a Unix server on the Internet.

Almost no one thinks being a Unix system administrator is fun. Not
even Unix system administrators think running an Internet server is
fun. So the personal Unix/Internet server is like the personal
bulldozer. This is not a consumer product. Any number of engineers
can't turn a bulldozer into a bicycle.

How did we build the personal bulldozer? We didn't. We started
from scratch. (The people who built the first PCs didn't start
with a mainframe OS, either.) We created a new platform: Urbit.

Urbit doesn't compete with Unix and the Internet. It's a new,
opaque layer on top of them. Your browser runs on a native OS,
but it doesn't give Web apps any way to talk to the native OS.
Urbit is like a browser for the server side: code within Urbit is
formally isolated from the platform it runs on top of.

Your urbit is a Unix process, in a data center or your PC. It sends
UDP packets over the Internet. It can both load and serve web pages
over HTTP. Except for character sets and crypto, nothing in Urbit
reuses or depends on any 20th-century code.

Urbit is a complete, clean-slate system software stack: a
non-lambda interpreter (Nock), a functional language (Hoon), and
an event-driven OS (Arvo), with its own encrypted protocol
(Ames), typed revision control (Clay), reactive web server (Eyre)
and functional build system (Ford). The full system, including
basic apps, is only 30,000 lines of Hoon.

The first end-to-end prototype of Urbit took one engineer eleven
years. The current beta took three more years, with about three
engineers on average.

How does it take 14 years to write 30,000 lines of code? The code
wasn't the hard part. The hard part was rewriting it until it was
right. We think we've solved all the real CS problems, and we're
certainly done changing major interfaces. But it will take more than
our small team to deliver a polished Urbit user experience that can
actually challenge modern web apps.

## Where we are, what we're doing

Urbit is in feature freeze. It's a minimum viable product in
early beta. It still needs quite a bit of fit-and-finish work.
We certainly don't recommend it for end users or consider it in
any way secure. But it's fun to play with, if you're a hacker.

This summer, we're making the switch to an open and transparent
development and specification process. A system as unusual as
Urbit can't be invented in public. But it has to be finished and
maintained in public.

Additionally, we're creating an open political and economic process,
with a small, fixed-price public presale of Urbit address space. Join
us and help make this future actually happen.

To keep reading, learn more about [Urbit's address
space](/blog/the-urbit-address-space); share our vision of the Urbit user
experience, from the [top down](/blog/what-is-urbit-for) or the [bottom
up](/blog/magic); check out the [development roadmap](/blog/roadmap);
evaluate Urbit's [beliefs and principles](/blog/beliefs-and-principles) or its
[interim constitution](/blog/interim-constitution).

(For technical readers, check out our [documentation](https://urbit.org/docs/) or
the [whitepaper](https://media.urbit.org/whitepaper.pdf)).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Beliefs and Principles Guiding the Urbit Project]]></title>
            <link>https://urbit.org/blog/beliefs-and-principles</link>
            <guid>https://urbit.org/blog/beliefs-and-principles</guid>
            <pubDate>Tue, 10 May 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/beliefs-and-principles.jpg)

## Beliefs

We believe that general-purpose computing is an essential tool to
unlock the power of individual creativity.

We believe that ownership, privacy and control don't need to be
sacrificed in exchange for usability, accessibility and reliability.

We believe in the power of the informed crowd to develop and maintain
software, through the IETF principles of sincerity and rough consensus.
The ability of the engineering community to govern itself through
republican forms is not an abstract theory; it's a proven fact.

We believe in both free speech and individual accountability. We
believe that a healthy network is one with diverse and well-defined
communities, and clear, user-controlled, boundaries between public and
private space.

We believe that no software system can replace human trust and
communication. Dialogue, judgment and governance are essential to
communities of all scales. Code and law can reduce conflict in the
common case; they can never handle all exceptions.

## Principles

Here are some principles of Urbit. Where principles conflict,
the first stated takes precedence.

### Digital independence

Digital independence is independent control of your own
general-purpose computer which holds your own primary data.
Urbit's ultimate purpose is to make practical digital
independence a useful and widely available product.

### Code is law

Wherever possible, the rules of Urbit must be executable as code.
Wherever possible, code must be self-enforcing. If not, it must
be perfectly defined. If not, it must not be stated.

### Sovereignty is conserved

Even where code is law, exceptional situations demanding
effective collective action will always arise. There must
always be a collective authority to solve these problems.

Two known problems in Urbit that require central authority are
approval of software updates and activation of the network. But
there will certainly be others.

### Purpose of collective authority

Urbit, as opposed to the Tlon corporation, is a republic. Its
government has one task: promoting, preserving and protecting Urbit.
It may take any legal action which advances this goal. Any other
actions are _ultra vires_, out of scope. Urbit is not a
general-purpose charity.

### Decentralized control

Urbit should never fall under any kind of central control. All
transitions in galaxy ownership should divide positions, not
unite them.

Galaxy and star ownership should also be separated. It is
harmful for a single entity to hold both galaxies and stars.

### Property is contingent

Property rights are contingent and accidental, not moral or
meritorious. A property register does not record why an owner
deserves some property. Ownership is neither a reward nor a
right; it is a fact.

### Governance is by stake

Ultimately, Urbit must be governed by those who own it. In each
tier, equal stakes must hold equal authority.

### Content-neutral

Urbit does not admit a tradeoff between anarchy and tyranny,
order and liberty. Urbit has zero tolerance for abuse, nor does
it facilitate censorship.

Urbit will do everything possible to help you block content you
don't want to see. It does nothing to help you block content you
don't want others to see.

### Trolling considered harmful

If you post content on Urbit which may offend or disturb any
significant group of users, it is your responsibility to mark it
properly for automatic blocking.

### Sockpuppets considered harmful

The only legitimate reason for one individual to use multiple
identities is to maintain multiple active pseudonyms. But
multiple identities must never interact in the same context.

### Not a darknet

Urbit is not a darknet. It does not break real-world laws. It
is not designed to facilitate the breaking of real-world laws.
For any problem that lawbreakers have, there must always be a
better solution that is not Urbit.

### Responsibility to route

As long as they are not facilitating violations of any of these
principles, or laws in their own jurisdictions, stars and
galaxies are responsible for routing their children. They are
also collectively responsible for escape-routing the children of
stars and galaxies which fail in their responsibility.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What is Urbit For?]]></title>
            <link>https://urbit.org/blog/what-is-urbit-for</link>
            <guid>https://urbit.org/blog/what-is-urbit-for</guid>
            <pubDate>Tue, 10 May 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/posts/essays/what-is-urbit-for.jpg)

Open platforms don't beat closed systems just because they're open.
They win because you can do more exciting things with them. We
believe we're overdue for new infrastructure not purely on principle:
but because we think you can build better products on top.

We look forward to a future where your fleet of Urbits run the devices
throughout your house, keep your biometric data in sync with the data
center and hold your secure medical and financial data. Today Urbit
is just a proof of concept — but we see a road from here to there.

## Today

These are things that work but are under development today. We expect
them to improve and stabilize in the coming months.

### Making the web programmable

The first thing your Urbit can do is act as a transparent layer to
your existing services. We'd like urbit to be usable as a self-hosted
IFTTT for geeks. Your urbit can hold your keys, store data, run
programs and seamlessly connect to your existing services. Plus, with
a global revision controlled filesystem it's easy to share API
connectors and keep them up to date.

With an Urbit running on your machine you can `ls` your Gmail from
Unix. Write a short script to poll Twitter on a keyword and deliver
the results to your email or into a Slack channel. Send an SMS when
an HTTP request doesn't resolve. These are just a few examples. Your
Urbit is designed to make data trapped in your existing services feel
like an extension of your local programming environment.

### Self-hosted publishing and communication

Additionally your Urbit is a flexible platform for publishing data to
the web and communicating with others. Sort of like a self-hosted
Slack, WordPress and Wiki in one. It's more common to use many tools
for sharing our content and communicating. Urbit is designed to bring
those tools together; giving the individual control over their
creative output.

Simply write markdown in your favorite editor and have an Urbit sync
them to the cloud. Use React components to control your layout and
extend our toolset. Host your own discussion channels and comment
threads. On a computer you own and control, whose source is 100%
open.

### Cryptographic identity

Your Urbit is your digital identity, cryptographically secured but not
controlled by any central authority. The Urbit PKI fills a gap that
remains unsolved on the web. We can send encrypted messages, securely
exchange digital currency, but how do I know who anyone is?

Your Urbit can post public proof to your third party services and its
validity is easily auditable. Using Urbit as an identity scheme for
new services would be a great decentralized alternative to 'Sign in
with [company x]'.

## Tomorrow

Urbit's crypto isn't tested, the network still gets rebooted from time
to time. The next milestone comes when Urbit matures to the point
that it's as reliable as its SaaS counterparts.

### Lifestreams, finally

The combination of great API tools and great publishing tools means we
can finally build an integrated interface for today's social networks.
The web is full of streams of data. For the user there's not much
utility in bouncing from service to service. Instead, it'd be great
to have general-purpose tools for consuming and publishing data.
Imagine a Medium-quality interface that makes no distinction between
Facebook and Twitter; SMS and Skype.

### Secret storage, web3

Bitcoin and Ethereum are both part of a new era of decentralized
infrastructure that's just beginning. For the blockchain to realize
its potential individuals need ought to have a way to host their own
nodes. At the very least, individuals need a reliable place to keep
their secrets. What's more, the blockchain isn't designed for
computation. It's great for contracts and currency, but too slow for
practical computing.

Urbit is a great complement to the blockchain. Your Urbit can safely
store your keys, providing an always-available keychain on the
network. Even better, your Urbit can hold your blockchain assets and
provide an off-chain computation layer. Urbit's computation doesn't
provide any kind of distributed consensus, but our computation model
is very simple and lends itself well to auditing. This makes it a
very blockchain-friendly platform.

## Over the horizon

If there's one thing we know from the history of personal computers
it's that computers are always expanding into more and more of our
lives. The more _personal_ our computers get the more they need to
reflect our thinking and our relationships. We don't know exactly
what this will look like, but we can certainly speculate on the areas
that deserve the most attention.

### Data permanence and software competition

Right now applications and data are practically the same thing.
There's no practical way for the user to separate them. Apps come and
go, either by falling out of fashion or actually shutting down. In
both cases our data becomes orphaned. There's no practical way for us
to get it back. The raw data from your LiveJournal is as good as a
floppy disk from the 80s. Computers hold the records of our lives.
Losing the history of the world to bitrot is a preventable problem.

Since each person owns their own Urbit there's no way to separate the
user from their data. When you run software on your Urbit you
_actually run it_ and your programs manipulate data that _you own_.
The individual has permanent access to their data by design. Ensuring
its durability is a technical problem, not a license agreement
problem.

When individuals are running their own software it's no longer
possible to lock them in by controlling their data. Instead, software
has to actually compete on utility. If one could trivially replace
the interface for Evernote with one from another developer for $10
wouldn't it be worth it? Even more so with Urbit, since after
installing software you're not dependent on the developer staying
alive. You're running a local copy. This model puts pressure on
applications to interoperate better and become more modular.

### Reputation

With a working identity system it's possible to build up contextual
reputation systems that aren't held hostage by their applications.
Just like the marriage of applications and data, reputation is
permanently tethered to and jealously guarded by the services we use.

For example, today we have karma systems on a per-site basis, like
Reddit. Is there any reason that individuals shouldn't have karma
scores per-topic? An individual's authority on a certain topic could
be verified by other experts while still denied by detractors. It's
easy to extend this to services like Yelp. With a strong identity
system it's possible for pseudonymous reviews to be counted with real
value. We'd no longer need a central authority for deciding on the
reputation of a restaurant, but just a way to pseudonymously aggregate
individual opinions. There's a broad swath of territory ripe for
exploration here.

### Privacy

With a reliably secure place to store your data on the network,
wouldn't you want to store even more personal information yourself?
Why is it that we don't store our own medical records, biometric data
or financial data? In a world where we have a safe place to keep them
we wouldn't require anyone else to keep them for us.

Furthermore, we'd be able to share them pseudonymously. One could
imagine medical research or census-like polling being done without
compromising the privacy of those involved. This also lowers the
barrier to entry for fintech and medical software developers. If I
can run my own personal health and finance software that can reliably
access my own transactions and medical records, what would developers
come up with?

### IoT

What needs a network _and_ computation? Devices. Turning a unix box
into a usable platform for hardware isn't something that any
individual manufacturer is incentivized to do. For the internet of
things to actually work we need a platform for devices to interoperate
simply and securely. Urbit is up to the task. Your Urbit isn't just
a single instance, it can sign the keys for a whole network of Urbits
intended to be used for your devices, sensors, appliances, machines,
robots, VR helmet, etc.

The future of the individual's computing experience may very likely be
among many different devices. Bret Victor's 'Seeing Spaces' is a
great exploration of what this future may look like. For the
industrial enterprise there's a whole other set of parallel problems:
tracking inventory, controlling a vast array of machines, and managing
logistics. In both cases we need a decentralized network and
computing platform. Urbit is up to the task.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[After hours: Bootstrapping Urbit from the Ethereum blockchain]]></title>
            <link>https://urbit.org/events/2017-08-11-after-hours-bootstrapping-urbit-from-the-ethereum-blockchain</link>
            <guid>https://urbit.org/events/2017-08-11-after-hours-bootstrapping-urbit-from-the-ethereum-blockchain</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
One thing that's been keeping us busy over the past month is designing the relationship between Urbit and the Ethereum blockchain.  We'll present our current design for this (from ~8:30 - 9) for people to comment on and ask questions about.

Otherwise, as usual, there will be plenty of time to hang out and chat with other Urbit people.

The backyard is really nice in the evening!  Feel free to bring friends"
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[After hours: Fun with %arvo (the Urbit OS)]]></title>
            <link>https://urbit.org/events/2017-09-22-after-hours-fun-with-arvo-the-urbit-os</link>
            <guid>https://urbit.org/events/2017-09-22-after-hours-fun-with-arvo-the-urbit-os</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Ted, the newest addition to our team, has been working on making changes to %arvo all over the place.  He'll give a short talk about some of his adventures in the Urbit OS and how they're going to make Urbit faster and easier to use.

That, and discussing why Equifax should have never been holding all that customer data in the first place.

Oh yeah, and we just got a fresh batch of Nock shirts!"
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[After hours: Designing robust human systems]]></title>
            <link>https://urbit.org/events/2017-10-26-after-hours-designing-robust-human-systems</link>
            <guid>https://urbit.org/events/2017-10-26-after-hours-designing-robust-human-systems</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Galen is going to give a short (~20m) talk on designing robust human systems.  No code, no math, no time in the terminal.  This is a completely non-technical talk about design principles.  It was originally given at the IDEO Blueprint event a few weeks ago.

Above all, these meetups are for meeting other people crazy enough to think the internet can be replaced.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[After hours: Visiting contributors]]></title>
            <link>https://urbit.org/events/2017-11-16-after-hours-visiting-contributors</link>
            <guid>https://urbit.org/events/2017-11-16-after-hours-visiting-contributors</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
This week we have ~mastyr-morzod, ~littel-ponnys and ~mastyr-harlud visiting the office. They've all been contributing great stuff from afar, so we figured out how to get them all in the same room to hack on Urbit for the week. On Thursday evening they'll talk about what they've been coming up with.

We'll also spend plenty of time just hanging around and talking about Parity, BCH, and everything else crypto-related. Feel free to bring friends!"
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2018.1]]></title>
            <link>https://urbit.org/events/2018-01-26-urbit-irl-20181</link>
            <guid>https://urbit.org/events/2018-01-26-urbit-irl-20181</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Turns out that just getting Urbit fans in one room is pretty fun — so come join. No demos or talks this time. Just some time to hang, listen to music and meet up IRL. The room is full of desks and the internet is pretty fast. So impromptu demos and tutorials are the norm. Bring your laptop and we'll install Urbit for you.

Feel free to bring friends!"
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2018.2]]></title>
            <link>https://urbit.org/events/2018-02-23-urbit-irl-20182</link>
            <guid>https://urbit.org/events/2018-02-23-urbit-irl-20182</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
No demos or talks. Just some time to hang, listen to music and meet up IRL. The room is full of desks and the internet is pretty fast. So impromptu demos and tutorials are the norm. Bring your laptop and we'll install Urbit for you. Or just relax and talk to people.

Feel free to bring friends!"
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.3 Hoon School]]></title>
            <link>https://urbit.org/events/2018-03-11-20183-hoon-school</link>
            <guid>https://urbit.org/events/2018-03-11-20183-hoon-school</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
There's no lesson per-se, think of it more like an 'independent projects' class. A few of us will be around to help you get started working on whatever you're interested in. It's completely fine if you're new to the language. We're going to start with only 10 spots so we can help everyone individually.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2018.3]]></title>
            <link>https://urbit.org/events/2018-03-23-urbit-irl-20183</link>
            <guid>https://urbit.org/events/2018-03-23-urbit-irl-20183</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
No demos or talks. Just some time to hang, listen to music and meet up IRL. The room is full of desks and the internet is pretty fast. So impromptu demos and tutorials are the norm. Bring your laptop and we'll install Urbit for you. Or just relax and talk to the weird array of people who also want to replace the internet.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[~2018.4 Hoon School]]></title>
            <link>https://urbit.org/events/2018-04-08-20184-hoon-school</link>
            <guid>https://urbit.org/events/2018-04-08-20184-hoon-school</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
There's no lesson per-se, think of it more like an 'independent projects' class. A few of us will be around to help you get started working on whatever you're interested in. It's completely fine if you're new to the language. We're going to start with 20 spots so we can help everyone individually.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2018.5]]></title>
            <link>https://urbit.org/events/2018-05-25-urbit-irl-20185</link>
            <guid>https://urbit.org/events/2018-05-25-urbit-irl-20185</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Ted will give a quick update on Urbit's new build system, ford. Then it's time to hang, listen to music (our friend Grayson will be playing records) and meet up IRL. The room is full of desks and the internet is pretty fast. Impromptu demos and tutorials are the norm. Bring your laptop and we'll install Urbit for you. Or just relax and talk to the weird array of people who also want to replace the internet.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[After hours 'decentralized web summit']]></title>
            <link>https://urbit.org/events/2018-08-03-after-hours-decentralized-web-summit</link>
            <guid>https://urbit.org/events/2018-08-03-after-hours-decentralized-web-summit</guid>
            <pubDate>Invalid Date</pubDate>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2018.8]]></title>
            <link>https://urbit.org/events/2018-08-17-urbit-irl-20188</link>
            <guid>https://urbit.org/events/2018-08-17-urbit-irl-20188</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Turns out that just getting Urbit fans in one room is pretty fun — so come hang out and have a beer.

No demos or talks this time, but we will be hosting Hoon School again soon. Just some time to hang, listen to music and meet up IRL. The room is full of desks and the internet is pretty fast. So impromptu demos and tutorials are the norm. Bring your laptop and we'll install Urbit for you. Or just relax and talk to the weird array of people who also want to replace the internet.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2018.9]]></title>
            <link>https://urbit.org/events/2018-09-21-urbit-irl-20189</link>
            <guid>https://urbit.org/events/2018-09-21-urbit-irl-20189</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Gavin will give an update on Urbit design at 8:30. Then it's time to hang, listen to music and meet up IRL. The room has tables and the internet is pretty fast. Impromptu demos and tutorials are the norm. Bring your laptop and we'll install Urbit for you. Or just relax and talk to the weird array of people who also want to replace the internet.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit + Zcash: 'Blockchain Week']]></title>
            <link>https://urbit.org/events/2018-10-10-urbit-zcash-blockchain-week</link>
            <guid>https://urbit.org/events/2018-10-10-urbit-zcash-blockchain-week</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
~Schedule

7 - 8: Come on time for hot pizza!

8 - 8:30: Alejandro Machado, researcher, advocate, and member of the Zcash community will speak

8:30 - 9: Galen Wolfe-Pauly will tell you things about Urbit and our wallet

9 - 10: Hangout
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[After hours: It's just a party, man]]></title>
            <link>https://urbit.org/events/2018-12-20-after-hours-its-just-a-party-man</link>
            <guid>https://urbit.org/events/2018-12-20-after-hours-its-just-a-party-man</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Come have a beer, connect with Urbit developers, fans and friends IRL, and ask questions about the address space going on-chain (if you have them).

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[After hours: Ask Galen Anything]]></title>
            <link>https://urbit.org/events/2019-03-01-after-hours-ask-galen-anything</link>
            <guid>https://urbit.org/events/2019-03-01-after-hours-ask-galen-anything</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
8:00-9:00pm: AMA

Afterwards, have a beer, connect with Urbit developers, fans, and friends IRL.

Feel free to bring friends and share the primer. <a href="https://urbit.org/primer" class="linkified">https://urbit.org/primer</a>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL: Austin, TX]]></title>
            <link>https://urbit.org/events/2019-03-08-urbit-irl-austin-tx</link>
            <guid>https://urbit.org/events/2019-03-08-urbit-irl-austin-tx</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Thank you to our friends over at Garage for hosting us. We'll be there from 5-7 PM.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2019.4]]></title>
            <link>https://urbit.org/events/2019-04-19-urbit-irl-20194</link>
            <guid>https://urbit.org/events/2019-04-19-urbit-irl-20194</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
By popular demand: we'll try to keep this one QUIET so everybody can talk.

Come for a quick update on what we're working on. Stay to relax and talk to a weird array of people who also want to replace the internet.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2019.5]]></title>
            <link>https://urbit.org/events/2019-05-17-urbit-irl-20195</link>
            <guid>https://urbit.org/events/2019-05-17-urbit-irl-20195</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
This time we'll give a brief update on what we've been up to around 8pm. Turning the music down worked well, so we'll do that again. And if you want help installing Urbit, bring a laptop.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2019.6]]></title>
            <link>https://urbit.org/events/2019-06-21-urbit-irl-20196</link>
            <guid>https://urbit.org/events/2019-06-21-urbit-irl-20196</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
This time we'll give a brief update on what we've been up to around 8pm. Turning the music down worked well, so we'll do that again. And if you want help installing Urbit, bring a laptop.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2019.7]]></title>
            <link>https://urbit.org/events/2019-07-19-urbit-irl-20197</link>
            <guid>https://urbit.org/events/2019-07-19-urbit-irl-20197</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Turning the music down has worked well, so we'll continue doing that. And if you want help installing Urbit, bring a laptop.

Feel free to bring friends!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit Austin ~2019.8]]></title>
            <link>https://urbit.org/events/2019-08-29-urbit-austin-20198</link>
            <guid>https://urbit.org/events/2019-08-29-urbit-austin-20198</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Come have a drink on us, and bring friends! We'll be there 6–8pm.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2019.10]]></title>
            <link>https://urbit.org/events/2019-10-04-urbit-irl-201910</link>
            <guid>https://urbit.org/events/2019-10-04-urbit-irl-201910</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
We're calling it Urbit IRL. You can use it to see your friends face-to-face, converse about Urbit, even to share a beer. And we're trying it out Friday, October 4.

We hope to see you there! If you want help installing Urbit, bring a laptop. And bring a friend, especially if they are interested in replacing the internet.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2019.11]]></title>
            <link>https://urbit.org/events/2019-11-15-urbit-irl-201911</link>
            <guid>https://urbit.org/events/2019-11-15-urbit-irl-201911</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
We're calling it Urbit IRL. You can use it to see your friends face-to-face, converse about Urbit, even to share a beer. And we're trying it out Friday, November 15.

We hope to see you there! If you want help installing Urbit, bring a laptop. And bring a friend, especially if they are interested in replacing the internet.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2019.12]]></title>
            <link>https://urbit.org/events/2019-12-13-urbit-irl-201912</link>
            <guid>https://urbit.org/events/2019-12-13-urbit-irl-201912</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
We're getting together to savor the moment and get hype about what the next decade holds (the whole replacing the internet thing).

We hope to see you there!

Things to bring:

-A friend

-A laptop, if you want help installing Urbit

-Good cheer
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2020.1]]></title>
            <link>https://urbit.org/events/2020-01-24-urbit-irl-20201</link>
            <guid>https://urbit.org/events/2020-01-24-urbit-irl-20201</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
It's 2020 and Urbit is accelerating. We've got a lot going live this year.

Replacing the internet is a thing to behold. Come by the offices to hang out, have a drink, and hear the latest.

Bring a laptop if you want help installing Urbit.

And as always, bring a friend!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit IRL ~2020.2]]></title>
            <link>https://urbit.org/events/2020-02-28-urbit-irl-20202</link>
            <guid>https://urbit.org/events/2020-02-28-urbit-irl-20202</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Before we go headlong into that unknown region, we're gonna have a party at basecamp (aka the office). Come hang out and have a drink with your fellow Urbit explorers.

Bring your laptop if you want to install Urbit.

And as always, drag a friend!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit OS1 Launch Party]]></title>
            <link>https://urbit.org/events/2020-04-03-urbit-os1-launch-party</link>
            <guid>https://urbit.org/events/2020-04-03-urbit-os1-launch-party</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
The presentation will begin at 7pm Pacific.

Join the live conversation on Urbit itself: `~/~dopzod/os1-premiere`

[There is also a VR viewing party for this event, hosted by `~naltyc-wornes`](https://account.altvr.com/events/1435581121923383472).

To receive the event merch, RSVP on this event page by midnight!

Ready to launch OS1? Check out our install guide:

[https://urbit.org/using/install/](https://urbit.org/using/install/)

Want address space for your friends? Apply for an Urbit Community Grant:

[https://urbit.org/community/community-grants/](https://urbit.org/community/community-grants/)

Interested in contributing to Urbit? Sign up for Hoon School:

[https://urbit.org/community/hoonschool/](https://urbit.org/community/hoonschool/)

Get the latest on Urbit:

Blog: <a href="https://urbit.org/blog/" class="linkified">https://urbit.org/blog/</a>

Urbit Twitter: <a href="https://twitter.com/urbit" class="linkified">https://twitter.com/urbit</a>

Urbit Github: <a href="https://github.com/urbit" class="linkified">https://github.com/urbit</a>

Still confused about what Urbit is?

<a href="https://urbit.org/understanding-urbit/" class="linkified">https://urbit.org/understanding-urbit/</a>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit Hosting Launch Event]]></title>
            <link>https://urbit.org/events/2020-10-09-urbit-hosting-launch-event</link>
            <guid>https://urbit.org/events/2020-10-09-urbit-hosting-launch-event</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
We've been busy building, testing and refining — and now it's time to show off what we've been up to.

We're going to do a live demo of Tlon's Urbit hosting solution, check out some of the new features of Landscape and generally catch up on what both we (at Tlon) and the community have been up to.

Since the OS 1 launch, back in April, we've been living on Urbit day to day. Urbit has gotten gotten a lot faster, more reliable and nicer to use. Most importantly, we've got an easy way for friends to come join us without running their own node. We're really excited to let people explore what's possible with Urbit and build communities without ever touching the command-line.

Join the waitlist for hosting here: <a href="https://tlon.io/" class="linkified">https://tlon.io/</a>

---

Got a group of friends who want to use Urbit together? We periodically give away blocks of planets and help people get set up. Apply for a community grant:<br/><a href="https://urbit.org/community/community-grants/" class="linkified">https://urbit.org/community/community-grants/</a>

Interested developing on Urbit? Hoon School is a community-run program to teach you the basics of the language and system. Sign up here:<br/><a href="https://hooniversity.org" class="linkified">https://hooniversity.org</a>

Mostly, you can find us on Urbit in the Urbit Community group. But you can also follow along here:<br/><a href="https://urbit.org/blog/" class="linkified">https://urbit.org/blog/</a><br/><a href="https://twitter.com/urbit" class="linkified">https://twitter.com/urbit</a><br/><a href="https://github.com/urbit" class="linkified">https://github.com/urbit</a>

And if you're still confused about what Urbit is, try these:<br/><a href="https://urbit.org/understanding-urbit/" class="linkified">https://urbit.org/understanding-urbit/</a>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Graph Store]]></title>
            <link>https://urbit.org/events/2020-11-05-developer-call-graph-store</link>
            <guid>https://urbit.org/events/2020-11-05-developer-call-graph-store</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Developer calls are focused on the technologies that underpin Urbit, from the top of the stack to the very bottom. They’re an opportunity for the people developing and contributing to Urbit to share their knowledge and expertise, including things that typically don’t make it into the docs, such as how and why Urbit works the way it does.

This call will feature a discussion by Tlon engineer Logan Allen about graph-store, the general-purpose store that is gradually replacing the bespoke stores behind Chat, Publish and Links.

You can join the event by clicking the gotowebinar.com link posted here. Details for joining the conversation were also emailed to all registered attendees, and will be sent again shortly before the event starts. Please check your email inbox for a message from Meetup.com.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: BitTorrent tracking on Urbit]]></title>
            <link>https://urbit.org/events/2020-11-19-developer-call-bittorrent-tracking-on-urbit</link>
            <guid>https://urbit.org/events/2020-11-19-developer-call-bittorrent-tracking-on-urbit</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
This call will feature a discussion by Tlon engineer Mark Staarink, also known as ~palfun-foslup, about writing an HTTP BitTorrent tracker and command line app in 1500 lines of code.

The livestream will be held on YouTube, and a group video call will be made available via Google Meet after the talk for casual discussion and in-person conversation.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Injecting External Services into Urbit]]></title>
            <link>https://urbit.org/events/2020-12-10-developer-call-injecting-external-services-into-urbit</link>
            <guid>https://urbit.org/events/2020-12-10-developer-call-injecting-external-services-into-urbit</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
This call will feature a discussion by well-known developer in the Urbit community, ~timluc-miptev. ~timluc will be discussing the work he's been doing to provide access to a Bitcoin full node, which will enable Urbit ships to make Bitcoin payments to other ships. More generally, he'll be discussing the patterns that he's using to manage an Urbit ship's connection to externally-running infrastructure, and how access to that infrastructure can be provided to other Urbit nodes.

Developer calls are focused on the technologies that underpin Urbit, from the top of the stack to the very bottom. They’re an opportunity for the people developing and contributing to Urbit to share their knowledge and expertise, including things that typically don’t make it into the docs, such as how and why Urbit works the way it does.

The livestream will be held on YouTube, and a group video call will be made available via Google Meet after the talk for casual discussion and in-person conversation."
+++
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Architectural Idea Maze]]></title>
            <link>https://urbit.org/events/2021-02-04-developer-call-architectural-idea-maze</link>
            <guid>https://urbit.org/events/2021-02-04-developer-call-architectural-idea-maze</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Tlon Engineer Philip Monk is interviewed by Poprox in an "Architectural Idea Maze" discussion, where Phil will discuss the choices made, and possibly more importantly, the choices _not_ made in the design of a component of Urbit. In this discussion, Phil will be focusing on subscriptions in all their forms throughout Urbit.

Developer calls are focused on the technologies that underpin Urbit, from the top of the stack to the very bottom. They’re an opportunity for the people developing and contributing to Urbit to share their knowledge and expertise, including things that typically don’t make it into the docs, such as how and why Urbit works the way it does.

The livestream will be held on YouTube, and a group video call will be made available via Google Meet after the talk for casual discussion and in-person conversation.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Scaling Azimuth]]></title>
            <link>https://urbit.org/events/2021-03-04-developer-call-scaling-azimuth</link>
            <guid>https://urbit.org/events/2021-03-04-developer-call-scaling-azimuth</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Urbit engineer Philip Monk will be discussing the solution space to scaling Azimuth, the infrastructure for Urbit ID that's built on Ethereum.

Unless you're living under a rock, you know that Ethereum is thoroughly congested and, as a result the cost of working with it is quite high. Most pertinently for Urbit, this means that the cost of bringing new planets onto the network is unacceptably high.

Phil has been doing a ton of research for the past few months on different approaches to scaling Azimuth. In this talk, he'll lay out the what's been explored so far, the relevant considerations for Urbit, and the emerging solutions that are being pursued.

As usual, this talk will feature a presentation, a Q&amp;A period and a follow-up video call that anyone from the audience can join.

See you there!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Pressure and Protolith]]></title>
            <link>https://urbit.org/events/2021-03-18-developer-call-pressure-and-protolith</link>
            <guid>https://urbit.org/events/2021-03-18-developer-call-pressure-and-protolith</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Landscape was an experiment. Now it’s Tlon's flagship client for the Urbit project: a product, a full-stack application, spread across a variety of Gall agents and libraries, lighting the way forward against the dwindling unknowns in the reality of Urbit userspace development and distribution.

Matilde Park, Landscape team lead, talks about the distinctions between the Landscape product and basic Urbit development, and the significance of building Landscape for Tlon — the role of “high-pressure experiments” in forcing our computer toward something rock-hard, diamond-perfect. With a few examples of ongoing deployments, she also outlines the problems being solved right now and the ones still a touch further out.

As usual, join us after the talk on the call to ask questions and hang out.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: JavaScript Apps on Urbit]]></title>
            <link>https://urbit.org/events/2021-04-01-developer-call-javascript-apps-on-urbit</link>
            <guid>https://urbit.org/events/2021-04-01-developer-call-javascript-apps-on-urbit</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Urbit provides a powerful and extensible platform for all kinds of app development. It can serve as a general-purpose datastore, decentralized network, and identity solution for a variety of front-end applications. The client that ships with Urbit, Landscape, provides one example of the kind of applications that can be built on the platform. However, other developers can use the same tools used to create Landscape to power their own interfaces and clients for Urbit.

Tyler Brown Cifu Shuster (~radbur-sivmus) has worked with the Landscape team over the past few months to extract these tools into reusable Javascript packages. In this talk, he will explain how to use them to develop a client for Urbit independent of Landscape. He will cover the basic lifecycle of a client and explain how Javascript interface and state frameworks pair with Urbit's data model.

This talk should enable anyone familiar with modern Javascript development and HTTP grammar to build an application on top of Urbit without writing any back-end code
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: 3rd Party Software Distribution]]></title>
            <link>https://urbit.org/events/2021-04-15-developer-call-software-distribution</link>
            <guid>https://urbit.org/events/2021-04-15-developer-call-software-distribution</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Some exciting work has been going on behind the scenes to provide the foundation for 3rd party software distribution. In this talk Phil (~wicdev-wisryt) and Raghu (~sovmep-ripsum) will discuss the work they've been doing to clay to provide "virtual desks"—an integral part of the infrastructure needed to have safe, generic software distribution.

Raghu is a software engineer at Hudson River Trading who is perhaps best known for his work on ucal, the Urbit calendar application. The work he's doing with Phil on virtual desks is being done through our Scholarships program, in which community developers pair up with Tlon infrastructure engineers to work on infrastructure projects. We'll spend some time at the beginning of the call to introduce Raghu and hear about his experience working on the Urbit kernel.

As usual, there'll be an opportunity to jump on the call with us afterward to ask questions and hang out.

## Resources

- [Original mailing list discussion of 3rd party software distribution](https://groups.google.com/a/urbit.org)
- [ucal](https://github.com/taalhavras/ucal)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Bitcoin Launch]]></title>
            <link>https://urbit.org/events/2021-04-27-bitcoin-launch</link>
            <guid>https://urbit.org/events/2021-04-27-bitcoin-launch</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Bitcoin is coming to Urbit! With the upcoming release of the Bitcoin Wallet, you will be able to pay Urbit ships directly with BTC.

We’d like to take a moment to show it off, and discuss the future of commerce on Urbit. First, Christian and Josh will demo the wallet, then, our good friend Marty Bent will moderate a panel with Christian, Tim, and Ed. We will have time at the end for questions.

The event will have a live stream on Youtube, and a live-chat on Urbit, links to come.

Join the Bitcoin dev conversation in the Urbitcoiners group: [~pindet-timmut/urbitcoin-cash](web+urbitgraph://group/~pindet-timmut/urbitcoin-cash)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Real-Time Communication on Urbit]]></title>
            <link>https://urbit.org/events/2021-04-29-developer-call-real-time-communications-on-urbit</link>
            <guid>https://urbit.org/events/2021-04-29-developer-call-real-time-communications-on-urbit</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Video chat on Urbit? It's nearly here using the WebRTC protocol. Edward Amsden (`~ritpub-sipsyl`) will be giving us a look at the WebRTC Airlock library that he has developed that handles all the hard parts of WebRTC. This will allow developers to simply call or answer calls by ship or app name. Edward will also be giving us a live text-based demo of WebRTC on urbit. Please join us for an exciting presentation.

Edward is a software developer and the principal of Black River Software LLC. He has several years experience building both backend and IoT software in Haskell, and in particular building IoT control and software deployment infrastructure. He also has academic background in programming language research.

As usual, there'll be an opportunity to jump on the call with us afterward to ask questions and hang out.

## Resources

- [Urbit WebRTC on GitHub](https://github.com/black-river-software/urbit-webrtc)
- Check out WebRTC progress reports on `~ritpub-sipsyl/webrtc-on-urbit`
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: P2P Versioned Networking]]></title>
            <link>https://urbit.org/events/2021-05-13-developer-call-versioned-networking</link>
            <guid>https://urbit.org/events/2021-05-13-developer-call-versioned-networking</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Building solid networking infrastructure has been a major focus of the Urbit project since its inception. There's a lot going on under the hood
that ensures our servers reliably stay connected. Liam Fitzgerald (~hastuc-dibtux) will be explaining how Urbit is able to deploy changes without breaking the network. Anyone designing userspace applications will be interested in the approach he has designed.

Liam is an Interface Engineer working at Tlon working on the Landscape team. He will be discussing networking userspace applications in depth and going into detail about the new versioning system.

As usual, there will be an opportunity to jump on the call with us afterward to ask questions and hang out.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Town Hall]]></title>
            <link>https://urbit.org/events/2021-05-27-town-hall</link>
            <guid>https://urbit.org/events/2021-05-27-town-hall</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
The Urbit community has grown at a rapid clip throughout 2021. There are so many exciting things going on that it's hard to convey them all, even with Developer Calls happening every two weeks. This event will function as a virtual "mini-conference" where we'll give a series of important and exciting announcements, including both formal and informal talks from many members of our community.

Here's a rundown of what we'll be discussing:

## Introduction: State of the Network

_12:00 PDT, Josh Lehman_

Urbit is under heavy, active development by both Tlon and a wide range of contributors. Josh Lehman will discuss some of the most important areas of work being undertaken, provide a picture of where Tlon and community efforts are going in the future, and even has a few exciting announcements to make.

## Taisho, Urbit's Port City

_~12:20 PDT, Hunter Miller_

Piloting an Urbit ship requires expertise that many lack. To achieve the rich and prosperous ecosystem we've all envisioned requires making that journey easier. In this talk, Hunter Miller introduces a new way for users to join the network with minimal effort.

## Keynote: The Revenge of Teleology

_~13:00 PDT, Justin Murphy_

Teleology—or inquiry into ultimate ends—has been out of fashion since the seventeenth century, when Francis Bacon said that, “like a virgin consecrated to God,” it “produces nothing.” I argue that the digital revolution is inverting Bacon’s claim. Baconian instrumentalism is now suffering from diminishing returns—it is what the youth today call a Boomer Ideology. Rather, the greatest gains are going to individuals and communities with teleological attitudes. This talk will observe some examples and present a model consistent with the observations. Bitcoin inquires after the telos of money, the most winning independent “content creators” inquire after the telos of media, and Urbit inquires after the telos of personal computing.

## Lightning Talks

_14:00 PDT, you?_

After the scheduled talks we'll break out into a series of 30 minute talks led by community members. There will be up to three talks given in parallel at each of 14:00 PDT, 14:30 PDT and 15:00 PDT (so nine talks total).

If you'd like to give a talk, please use [this form to sign up](https://airtable.com/shr0Xmqcv1HSy47EP). You can see the full list of [proposed talks here](https://airtable.com/shreGQ4kCU8RA5GJS/tblTZxCpqedJBwSkE), and if you'd like to voice your support for any of these specifically, [cast a vote using this form](https://airtable.com/shrhNRUAGCqZ38VXA).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: The Urbit Runtime and its Future]]></title>
            <link>https://urbit.org/events/2021-07-01-developer-call-runtime-future</link>
            <guid>https://urbit.org/events/2021-07-01-developer-call-runtime-future</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Please join us for a look behind the curtain at the Urbit Runtime. Host Ted Blackman (~rovnys-ricfer) will be interviewing Joe Bryan (~master-morzod). Topics will include event log truncation, plans for storing more than 2GB, multithreading implementation, and much more.

Ted Blackman (~rovnys-ricfer) has worked on Urbit since 2017, mostly on the kernel, with forays into the runtime and userspace. Before Urbit, he worked in sensor fusion, robotics, web development, distributed systems, and data engineering. He has a degree in physics from MIT.

As always, join us for happy hour after the talk.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Urbit Yakshaving]]></title>
            <link>https://urbit.org/events/2021-07-15-developer-call-yakshaving</link>
            <guid>https://urbit.org/events/2021-07-15-developer-call-yakshaving</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
This week Jake Miller (~littel-wolfer) will be giving us a look at his development process, walking through his "urbit-emacs" setup and how he uses org-mode and tmux for hoon development. He'll also be giving us a quick demo of his work-in-progress Roam importer.

Jake considers himself a recovering Fintech engineer currently working at Tlon. He is interested in building learning systems and tools in Urbit.

Please join us for Happy Hour after the talk to ensure all your burning yakshaving questions get answered.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit DC Meetup Q3 2021]]></title>
            <link>https://urbit.org/events/2021-09-02-21q3-dc-meetup</link>
            <guid>https://urbit.org/events/2021-09-02-21q3-dc-meetup</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Come on out to the Urbit Meetup! Whether you are an OG Martian or just curious about the decentralized internet, come say hello and hang out with us! There will be a brief presentation on Urbit followed by a socializing and drinks nearby.

**Please note that the meetup takes place on September 2nd at 5:30. The date above is incorrect.**

[Please RSVP](https://www.meetup.com/DC-Urbit-Meetup-Group/events/279885879/)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Azimuth, Scaled]]></title>
            <link>https://urbit.org/events/2021-09-16-developer-call-azimuth-scaled</link>
            <guid>https://urbit.org/events/2021-09-16-developer-call-azimuth-scaled</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
ETH Gas prices are too high! The growth of Urbit has been greatly hampered this year by the cost of activating planets. Join Philip Monk (`~wicdev-wisryt`) and the entire L2 team as they present the work completed to date to implement Layer 2 naive rollups. Come see a demo of the new Bridge front end, first migrating a star and spawning some planets, then activating a planet, all on L2.

This call will be a great opportunity for galaxy owners to get their questions answered for the upcoming vote on Layer 2 implementation. It will also be good for anyone in the community that wants a comprehensive look at how naive rollups will work to bring down planet activation costs. If you're technically inclined, be sure to check out [Philip's walkthrough](https://www.youtube.com/watch?v=lQdqCwYIBoU) of the naive rollup code ahead of time so you can ask questions.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Urbit Outside]]></title>
            <link>https://urbit.org/events/2021-09-24-urbit-outside</link>
            <guid>https://urbit.org/events/2021-09-24-urbit-outside</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
![](https://secure.meetupstatic.com/photos/event/3/0/5/7/clean_498732375.jpeg)

For our second post-Covid Urbit IRL, we're heading to the East Bay!

Please join us at Sibley Preserve for a hangout and (optional) hike.

We'll meet at the Sibley Staging Area at 3:00PM, and leave for a casual walk to the caldera and labyrinth at 4:00PM.

Hiking shoes, snacks, water, and picnic blankets/chairs are encouraged! There are restrooms and water at the Staging Area.

Please join the channel 'Urbit Outside ~[masked]' in ~bitbet-bolbel/urbit-community to get in touch with the gang.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Assembly]]></title>
            <link>https://urbit.org/events/2021-10-15-assembly</link>
            <guid>https://urbit.org/events/2021-10-15-assembly</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
![](https://storage.googleapis.com/media.urbit.org/site/events/assembly-event-image.png)

Assembly 2021 marks a pivotal moment in Urbit: software distribution. Yes, Urbit is ready to be built upon. We’ll spend three days together doing just that.

- Learn about building applications on Urbit (it’s easy).
- Find out how to work and create on a platform that is fully owned by you.
- Meet with the growing ecosystem of communities and businesses built on Urbit.

If you’re simply into calm computing, well, there will be plenty of that too.

You’ll choose between two tracks:

- Assembly: Assemble software or work together on projects in small groups
- Workshop: A two day workshop taught by Neal Davis, Urbit for Developers
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Developer Call: Urbit Visor - Transforming the Web Browser Into an Urbit Client]]></title>
            <link>https://urbit.org/events/20211007-developer-call-visor</link>
            <guid>https://urbit.org/events/20211007-developer-call-visor</guid>
            <pubDate>Invalid Date</pubDate>
            <content:encoded><![CDATA[
Please join us for a deep dive into Urbit Visor, a brand new web extension which transforms your browser into a first class Urbit client. Robert Kornacki from dcSpark will be taking viewers step-by-step through the history of how Urbit Visor came to be, starting off with his initial work on the Rust airlock implementation, moving into Login With Urbit, and finally arriving at the final product of Urbit Visor that we have today.

From there Robert will hit on many topics including:

- Live demonstration of how Urbit Visor works
- How Urbit Visor improves and increases the security of the Landscape login experience
- An overview of the first Urbit Web App: Urbit Dashboard
- Ship hot-swapping
- Streamlining the developer experience for any JS/TS dev to jump into the ecosystem and start building immediately
- UV Extensions and how they will allow Urbit and the current web to integrate seamlessly
- The long term goals and vision of Urbit Visor

Robert Kornacki (~mocrux-nomdep) is CSO at dcSpark and has been in the Urbit ecosystem since 2019. Robert has significant experience working in the crypto industry over the past several years, developing tooling and smart contract protocols which hold millions of dollars of assets to this day.

Hosted by Josh Lehman, the Director of the Urbit Foundation.
]]></content:encoded>
        </item>
    </channel>
</rss>